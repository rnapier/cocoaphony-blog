<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Cocoaphony]]></title>
  <link href="https://robnapier.net/atom.xml" rel="self"/>
  <link href="https://robnapier.net/"/>
  <updated>2019-04-22T18:01:32-04:00</updated>
  <id>https://robnapier.net/</id>
  <author>
    <name><![CDATA[Rob Napier]]></name>
    <email><![CDATA[rob@neverwood.org]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Protocols I: Start With a Protocol]]></title>
    <link href="https://robnapier.net/start-with-a-protocol"/>
    <updated>2019-04-22T00:00:00-04:00</updated>
    <id>https://robnapier.net/start-with-a-protocol</id>
    <content type="html"><![CDATA[<h2>In the beginning, Crusty</h2>

<p>In 2015, at WWDC, <a href="https://twitter.com/DaveAbrahams">Dave Abrahams</a> gave what I believe is still the greatest Swift talk ever given, and certainly the most influential. <a href="https://developer.apple.com/videos/play/wwdc2015/408/">”Protocol-Oriented Programming in Swift,”</a> or as it is more affectionately known, “The Crusty Talk.”</p>

<p>This is the talk that introduced the phrase “protocol oriented programming.” The first time I watched it, I took away just one key phrase:</p>

<blockquote><p>Start with a protocol.</p></blockquote>

<p>And so, dutifully, I started with a protocol. I made a UserProtocol and a DocumentProtocol and a ShapeProtocol and on and on, and then started implementing all those protocols with generic subclasses and eventually I found myself in a corner.</p>

<pre><code>Protocol 'P' can only be used as a generic constraint because it has Self or associated type requirements
</code></pre>

<p>And then I started throwing things.</p>

<!--more-->


<p>For several years, I was rather annoyed at the phrase &ldquo;protocol-oriented programming.&rdquo; If by &ldquo;protocol&rdquo; you just mean &ldquo;interface,&rdquo; then Go is much more &ldquo;protocol oriented&rdquo; than Swift. But the more I&rsquo;ve wrestled with this new paradigm, the more I realized that POP isn&rsquo;t really about the protocols. It&rsquo;s about the extensions. But &ldquo;extension-oriented programming&rdquo; would be an even worse name. And more than just extensions, it&rsquo;s really, deeply, about generic algorithms. And &ldquo;algorithm-oriented programming,&rdquo; well, aren&rsquo;t we all?</p>

<p>Naming a paradigm is always fraught with trouble. Most modern &ldquo;object-oriented&rdquo; languages aren&rsquo;t object-oriented at all. They&rsquo;re class-oriented (vs Smalltalk and JavaScript). And most &ldquo;functional programming&rdquo; languages are mostly value-oriented (vs FP and point-free). But the point of the names is shorthand for concepts bigger than a word, so let&rsquo;s not get too caught up on the &ldquo;protocol&rdquo; in protocol-oriented programming. The Holy Roman Empire was in no way holy, nor Roman, nor an empire. Discuss.</p>

<h2>Beware quotes traveling sans context</h2>

<p>The famous &ldquo;start with a protocol&rdquo; quote is actually the end of a longer paragraph:</p>

<blockquote><p>For example, if you want to write a generalized sort or binary search…Don&rsquo;t start with a class. Start with a protocol.</p></blockquote>

<p>Or as Dave <a href="https://twitter.com/cocoaphony/status/1104114233288151043">clarified on Twitter</a>:</p>

<blockquote><p>Use value types, then if you need polymorphism, make them conform to protocols.  Avoid classes.</p></blockquote>

<p><em>If</em> you&rsquo;re reaching for class inheritance, try a protocol and value type instead. That&rsquo;s very different from &ldquo;start with a protocol for every problem.&rdquo; <a href="https://twitter.com/AirspeedSwift">Ben Cohen</a> covered this in much more detail in the WWDC 2018 talk <a href="https://developer.apple.com/videos/play/wwdc2018/406/">Swift Generics (Expanded)</a>.</p>

<blockquote><p>So notice that we considered a varied number of concrete types first. And now, we&rsquo;re thinking about a kind of protocol that could join them all together. And, it&rsquo;s important to think of things as this way around. To start with some concrete types, and then try and unify them with a protocol.</p></blockquote>

<p><span class='pullquote-right' data-pullquote='Write concrete code first. Then work out the generics.'>
If you take away one thing from this series, I want it to be this: <em>Write concrete code first. Then work out the generics.</em> Start with concrete types and clear use cases, and find the places that duplication happens. Then find abstractions to fix those problems. The power of protocol-oriented programming is that you don’t have to decide when you make a type exactly how that type will be used. When you work with inheritance, you have to design your class hierarchy from the start. But with protocols, you can wait until later.
</span></p>

<p>When I most get into trouble with protocols is when I try to write code &ldquo;as generically as possible.&rdquo; That doesn&rsquo;t really mean anything. Abstractions are choices, and when you make a choice to be flexible in one direction, you generally make it harder to be flexible in other directions. Without some clear use cases, you don&rsquo;t know what abstractions make sense.</p>

<p>So today, I want to come to protocol-oriented programming fresh, with a focus on very every-day problems we face when developing iOS apps in Swift.</p>

<h2>Setting the stage</h2>

<p>In the next several articles, I&rsquo;ll be developing a very common system, a general-purpose networking stack that can fetch data asynchronously and decode arbitrary types. You may have built a system like this yourself in Swift. You may have used a framework that does it. The point of this exercise isn&rsquo;t really the end result (though I think it&rsquo;s quite useful code), but the process. What questions should you ask, and when, and how do you know what good answers look like? And most importantly, how does this &ldquo;protocol oriented programming&rdquo; thing guide us? How is it different than other approaches?</p>

<p>So to get started, I want to show a common starting point that never goes well for me. I&rsquo;ve tried to build it this way several times myself, and I always find myself in a corner eventually. I see a lot of other people make this same mistake.</p>

<pre><code>// This will not go well.
// Trying to model a Request as something that can fetch and parse a Response.
protocol Request {
    associatedtype Response
    func parse(data: Data) throws -&gt; Response
    var urlRequest: URLRequest { get }
}
</code></pre>

<p>How do I know this won&rsquo;t go well? I&rsquo;ll discuss it much more in depth later, but Request is a protocol with associated type (PAT). Any time you create a PAT, you should ask yourself &ldquo;will I ever want to put this in an Array?&rdquo; If the answer is yes, you don&rsquo;t want a PAT. Requests are certainly something you&rsquo;d want to put in an Array. Lists of pending requests, lists of requests that need to be retried, request priority queues. There are lots of reasons to put a Request in an Array.</p>

<p>You might be tempted to look for a work-around, but don&rsquo;t. Type-eraser? No. Generalized Existential?!?! &hellip;no&hellip; Even if you find some &ldquo;work-around&rdquo; to the problem at hand you&rsquo;ll run into other walls very quickly (and I&rsquo;ve seen that again and again). That <code>can only be used as a generic constraint</code> is actually telling you something important. This isn&rsquo;t a problem with Swift. This just isn&rsquo;t what PATs are for. We&rsquo;ll get to what they&rsquo;re for soon, but the basic problem here is starting with a protocol before we even know what algorithm we want to write.</p>

<p>So what does &ldquo;know the algorithm&rdquo; look like in practice? Glad you asked. Stay tuned for part two.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Conditional Breakpoint]]></title>
    <link href="https://robnapier.net/conditional-breakpoint"/>
    <updated>2017-04-23T11:59:20-04:00</updated>
    <id>https://robnapier.net/conditional-breakpoint</id>
    <content type="html"><![CDATA[<p><a href="https://twitter.com/jamesdempsey/status/855979622655291392">I&rsquo;m now a Conditional Breakpoint.</a> It&rsquo;s been a dream of mine for long time, and it finally happened at <a href="http://cocoaconf.com/chicago-2017/sessions/breakpoint-jam">CocoaConf Chicago</a>. There are folks who have played extensively with <a href="http://jamesdempsey.net/2013/03/02/introducing-the-breakpoint-jam-at-cocoaconf-chicago/">James Dempsey</a>, and those are the Breakpoints. If you&rsquo;ve only played occasionally (even once), you&rsquo;re a Conditional Breakpoint.</p>

<!--more-->


<p>Originally, I wasn&rsquo;t comfortable being a full &ldquo;Conditional.&rdquo; I&rsquo;m not much of a guitarist. I can play along reasonably if there&rsquo;s someone to cover my mistakes, and a group probably sounds slightly better with me than without. But listening to me play alone is an act of love and friendship, not something you&rsquo;d do on purpose. So I kind of wanted to be called a &ldquo;Provisional Breakpoint&rdquo; instead. But that was wrong. Someone who&rsquo;s played at a Breakpoint Jam is a Conditional Breakpoint. That&rsquo;s what it means. If you&rsquo;ve done it, you&rsquo;ve earned it.</p>

<p>Everyone who played guitar that night was a Conditional, but <a href="https://twitter.com/designatednerd">Ellen Shapiro</a> was clearly our leader. She plays with an energy and style that I want to emulate. She&rsquo;s much better than I am, but what I&rsquo;ve played in years, she&rsquo;s played in decades, so maybe that&rsquo;s natural. <a href="https://robnapier.net/copying">Choosing the right people to copy is a worthwhile skill in itself.</a> There&rsquo;s nothing wrong with being a beginner. There&rsquo;s nothing wrong with learning and flailing and trying again. There&rsquo;s nothing wrong with letting someone mentor you. And there are a lot of ways to mentor. You might not even know when you&rsquo;re doing it.</p>

<p>When I first asked to play with the Breakpoints a few weeks ago, James said yes, and I immediately panicked a little on the inside, and I asked for the whole setlist so I could practice. And he said sure and sent them. But then he said, you know, it’s fine to just play some of the songs, or even drop out of parts if you’re not up for it. It’s better to have a few songs you’re good at than a bunch you stumble through. And I said yeah, yeah, yeah, I know that. I’m cool. And I did kind of know. But not really. I’d been planning to practice them all and just beat myself up a lot everywhere I stumbled. I needed someone who knows more than me to give me permission to be a beginner, but still let me play. Sometimes you&rsquo;ll never know the impact of a small kindness.</p>

<p>After the show, <a href="https://twitter.com/ejknapp">Eric Knapp</a> asked me a very useful question. &ldquo;So, that was your dream, and now you&rsquo;ve done it. What&rsquo;s your next dream?&rdquo; It&rsquo;s easy to lose your direction when you get to a destination. If you want to keep growing, your goals have to grow with you. My next goal is to be good enough that I can play alone and you&rsquo;d rather stay than leave, even if you&rsquo;re not my friend. It&rsquo;s what I call &ldquo;a mediocre guitarist.&rdquo; Eric thought it was a good goal, but suggested a more concrete one: Play one song at an open mic night. And he passed on some wisdom he&rsquo;d received and I needed. &ldquo;Don&rsquo;t wait until you&rsquo;re ready. Go play before you&rsquo;re ready. There are lessons you can only learn by doing.&rdquo; Eric has forgotten more about playing than I know (and I don&rsquo;t believe I&rsquo;m exaggerating). It&rsquo;s good advice.</p>

<p>I talk a bit about learning guitar and make a bit of noise about being a beginner. Some of that is because I love to tell stories, and I hope my stories can help other people. But of course saying &ldquo;I&rsquo;m a beginner&rdquo; lowers expectations and overdone is a cheap way of getting praise. It&rsquo;s a dangerous thing to make too big a deal about. For all my &ldquo;I&rsquo;m a beginner and I&rsquo;m scared,&rdquo; <a href="https://twitter.com/savinola">Laura Savino</a> has been playing guitar for less time than I have, and this <em>wasn&rsquo;t</em> her first Breakpoint Jam. So sometimes the brave ones don&rsquo;t make as much noise. You have to look or you&rsquo;ll never notice.</p>

<p>I may just have been lucky so far, but I&rsquo;ve found the guitar community to be incredibly welcoming. James isn&rsquo;t alone in inviting beginners to play, but the Breakpoints has a special history of it. Except for Ellen, the rest of us (Laura, myself, and <a href="https://twitter.com/kognate">Josh Smith</a>) all made our first public performances at Breakpoint Jams. Creating that kind of opportunity is a gift and how you create and sustain a community. If we all &ldquo;only hire the best,&rdquo; where do you think the next generation will grow? Thankfully, James is willing to play with folks who are just trying their best. Are we as willing to develop software the same way?</p>

<p>There are senior developers and there are junior developers, and there are developers in between. Different people have different experience and skill. You might be a senior developer in one language or platform or style, and just learning another. But there&rsquo;s no point talking about &ldquo;real&rdquo; developers. If you write software and it runs, you&rsquo;re a real developer. That&rsquo;s what it means. You develop software. If you&rsquo;ve done it, you&rsquo;ve earned it.</p>

<p>And if you develop software in Cocoa, then you really want to listen to <a href="https://itunes.apple.com/us/album/backtrace/id926558924">Backtrace</a>. Hope to see you at the <a href="http://jamesdempsey.net/splash/jdbp2017">next show</a> to benefit <a href="http://appcamp4girls.com">App Camp For Girls</a>!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Refactoring Slow and Steady]]></title>
    <link href="https://robnapier.net/refactoring"/>
    <updated>2017-02-13T12:21:55-05:00</updated>
    <id>https://robnapier.net/refactoring</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been talking with folks on a Slack about refactoring today, and I thought I&rsquo;d put some of my thoughts here. Maybe a little less polished than I&rsquo;d like, but I wanted to get them out of my head and down on &ldquo;paper.&rdquo;</p>

<!--more-->


<p><em>The conversation started by referencing the classic Joel piece, <a href="https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/">Things You should Never Do, Part I</a>. Leading to my thoughts:</em></p>

<p>Just finished some major refactoring work, moving ObjC to Swift and completely redesigning its state machine. I absolutely stand behind the pieces I rewrote (which were a constant source of subtle race conditions and bugs, with every fix causing two new problems). I absolutely stand behind the pieces that I have delayed rewriting (which are a spaghetti mess, and incredibly difficult to safely modify, but after some minor tweaks are stable enough to leave alone).</p>

<p><span class='pullquote-right' data-pullquote='I’m a big fan of &#8220;radical refactoring.&#8221;'>
I’m a big fan of &ldquo;radical refactoring.&rdquo; I’ve refactored several code bases until there was almost nothing left of the original code. But it was done steadily, only doing major rewrites to individual pieces after painstakingly detangling them from the rest of the code (usually over the course of several releases). And at the end, there was always some “ball of mud” part that was a bit crazy, but just worked and didn’t need to be touched that often, so we let it be.
</span></p>

<p>I’ve even refactored a C program into a Go program, by turning it into two independent processes that communicated over sockets, and moving bits from one side of the API to the other.</p>

<p>(So even “we need to switch languages/platforms entirely” doesn’t stop you from evolving towards a goal.)</p>

<p>But there&rsquo;s an exception that Joel doesn’t mention (but I think Martin Fowler does): if you have incredibly <em>buggy</em> code, that is, if you <em>don’t</em> have working code, then that’s the time to consider a rewrite. Not ugly code. Not badly designed or horrible to work with code. But code that doesn’t actually work, and several attempts to make it work have failed. That’s when a rewrite (at least of those portions) is likely appropriate.</p>

<p><em>The discussion then turned to unit testing, and particluarly <a href="http://hamletdarcy.blogspot.com/2009/06/forgotten-refactorings.html">Forgotten Refactorings</a>.</em></p>

<p>Having had some very successful radical refactors on code without solid unit test coverage, I think it’s worth discussing how that can be done.</p>

<p><span class='pullquote-right' data-pullquote='redesigning for testablity will *itself* require massive refactoring without unit tests'>
First, unit test coverage is absolutely the best first step. That said, sometimes it is impossible in any meaningful way. When all the most likely and common bugs in your system are race conditions and corner cases involving things outside the program (non-trivial networking, bluetooth, version-specific OS interactions, complex animations, etc), I&rsquo;ve found unit tests rapidly become tests of mocks, and not tests of the system. We can debate whether or not it is possible or profitable to redesign your system so it is more testable. I&rsquo;ll even concede that it is and leave arguments about TDD for another day (I&rsquo;m actually a fan of TDD). But redesigning for testablity will <em>itself</em> require massive refactoring without unit tests (because you can&rsquo;t unit test until you make it testable). Even if you have lots of tests, refactoring often means changing the tests dramatically (which means you&rsquo;re not really testing the same thing). So at <em>some</em> point, you&rsquo;re going to find yourself needing to refactor without perfect (or even barely sufficient) unit tests. How do you do it?
</span></p>

<p>Slow down.</p>

<p><span class='pullquote-right' data-pullquote='Slow. Down. Expect your refactor to take many releases.'>
I cannot stress this enough. Slow. Down. Expect your refactor to take many releases. Do a small piece of refactoring, and run it through a full QA cycle (whatever that means for you) and ship it. Do it again and again. My &ldquo;convert a C project to Go&rdquo; project included a release where we just shipped the Go code alongside the C code, without even calling the Go code, just to prove it would install and not break anything. Then we built one, tiny, new feature in the Go code. It was so minor and impacted so few users, we were ready to declare it unsupported if it didn&rsquo;t work. We&rsquo;d been working on the Go code for almost two years before we cut over to it &ldquo;for real&rdquo; (and the vast majority of the code was still in C at that point). But at each step along the way, the system was better, and saner, and more reliable. And at each step along the way, it shipped, and got real field exercise. And we built a lot of tests for it, and we still found bugs that we were unable to build automated tests for. &ldquo;Fails to determine domain on Mac previously joined to AD domain, but then removed, only on OS X prior to 10.8&rdquo; or &ldquo;SMB connection fails to Window 2000 server if username contains space&rdquo; or &ldquo;fails to determine correct IP address on Mac with case-sensitive file system if on Cisco VPN.&rdquo; That kind of stuff.
</span></p>

<p>Second point that goes along with this is to keep your refactor steps contained. I&rsquo;ve had so many experimental refactor branches that I threw away because they spiraled out of control and touched too many pieces of the system in non-trivial ways. Don&rsquo;t be afraid to throw away several attempts at refactoring until you can get your change focused enough that the risk is contained. Sometimes that means creating &ldquo;firebreaks,&rdquo; an object that wraps the thing you&rsquo;re refactoring and provides the old API for code you don&rsquo;t want to touch yet. Creating a firebreak often starts as just a pass-through that does nothing but call methods on the original. Tedious, but often invaluable. They make it possible to move to your new API piece by piece rather than having to touch half the system in one go.</p>

<p>I strongly recommend keeping your commits very focused. &ldquo;Rename FooAdapter to Foo&rdquo; should be its own commit. Don&rsquo;t mix it with changes to API. &ldquo;Rename X to Y&rdquo; commits are really easy to code review, even if they touch hundreds of files. But if you also changed logic in there, then it&rsquo;s a monster. Similarly, anything that is an easy win with little risk (like naming things sanely, or moving some duplicated code into a function), do those first and get them into the main code base. That way, when you discover that your ambitious new design is out of control and have to start over, you don&rsquo;t lose your easy wins.</p>

<p><span class='pullquote-right' data-pullquote='go slow and steady and keep shipping.'>
Testing is great. Testing is critical. Testing is necessary. But unit testing is not sufficient. And when there are hundreds of test cases that need to be rewritten, they can be a <em>hindrance</em> to refactoring. The more important rule in my experience is go slow and steady and keep shipping.
</span></p>

<p>And yes. Write your unit tests. We&rsquo;re professionals here.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Talking and Teaching]]></title>
    <link href="https://robnapier.net/talking"/>
    <updated>2016-11-29T10:35:09-05:00</updated>
    <id>https://robnapier.net/talking</id>
    <content type="html"><![CDATA[<p><a href="https://twitter.com/pepibumur">Pedro Piñera</a> makes some important points in his article <a href="http://ppinera.es/2016/11/16/in-a-world.html">In a world&hellip;</a>. There are a number of things in there, and you should go read it, but I want to focus on one part, which is the observation that the core &ldquo;iOS speaker circle&rdquo; is a fairly small group of people. Pedro notes:</p>

<blockquote><p>There’s a huge difference when you compare a talk from someone that has been working a lot on the topic and from someone that studied the topic for giving a talk. Why do people do it then? Talks with a lot of value usually come from unknown people. From these people that from the anonymity worked on a topic and they achieved something that they were willing to share. &hellip; People don’t care about the company that person had worked for, or the newsletter that the person had written, but instead, what that person wants to share.</p></blockquote>

<p>While I agree with Pedro&rsquo;s concern, I disagree that this is the proper ideal.</p>

<!--more-->


<p>I&rsquo;ve learned more about programming from listening to <a href="https://twitter.com/dimsumthinking">Daniel Steinberg</a> talk about baking cookies than I have from a dozen talks from intelligent, highly experienced people who don&rsquo;t have his skill for teaching. There are a number of speakers whose sessions I will attend no matter their topic because it&rsquo;ll always be worth the time. I get inspired every time I listen to <a href="https://twitter.com/jaimeejaimee">Jaimee Newberry</a>, even though almost everything about her life and style is different than mine. If I watch <a href="https://twitter.com/chriseidhof">Chris Eidhof</a> live-code, I know I&rsquo;m going to see some amazing idea that forces me to rethink something in my code.</p>

<p><span class='pullquote-right' data-pullquote='I absolutely care who&#8217;s giving the talk.'>
I absolutely care who&rsquo;s giving the talk. And if we&rsquo;re going to ask people to spend hours or days of their time and hundreds or thousands of dollars to attend conferences, I think we owe the best we can offer.
</span></p>

<p>But while I disagree with some of Pedro&rsquo;s analysis, he raises a very important point. A community with many teachers and broad sharing is better than one with few teachers and a hierarchical flow of knowledge. How do we improve?<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p>We should recognize that there&rsquo;s nothing wrong with having a core group of known, skilled speakers who draw a crowd. We should celebrate that. We should grow that group, and we should use them to make things even better.</p>

<p>At dotSwift, Daniel Steinberg reached out to all the speakers and offered assistance refining their talks. Conference organizers should encourage and facilitate that kind of mentorship, and use it to reduce the risks of inexperienced speakers. I hope conference organizers speak to each other and share names of promising speakers whom they didn&rsquo;t have room for. CocoaHeads and other local groups should strive to video their local talks and <a href="http://cocoaheads.tv">make them available</a>. Conference organizers should use those to find and contact promising speakers outside the usual suspects. Local lightning talks have a very low barrier to entry and make an excellent way to get into speaking. Not everyone has a local group, but it&rsquo;s a start.</p>

<p>For those without a local group to video them, I always recommend blogging. Learning to write well is a major part of learning to speak well, and the barrier to entry for blogs is lower. A blog doesn&rsquo;t have to be constantly updated to be helpful. A single, well-written article can be a huge value. This is another important place for conference organizers to search for new speakers, and I think those who are already well known have a duty to amplify lesser-known blogs that are well written and insightful.</p>

<p>To those who want to speak, I&rsquo;d like to offer a little advice. I&rsquo;m not a top-tier speaker. I don&rsquo;t get invited to many different conferences (thanks to <a href="http://cocoaconf.com">CocoaConf</a> for making room for me so often), and most of my CfP submissions are rejected, but I&rsquo;ve spoken at 11 conferences over the last 4 years and some of my talks have been very well received, so take my advice for what it&rsquo;s worth, remembering that it comes from someone with a lot of privilege. Not all of it applies easily to marginalized groups, but hopefully it can be of some help.</p>

<p>First, I want to quote Pedro again:</p>

<blockquote><p>New announcements from Apple are the perfect source of topics for talks, grabbing it quickly is crucial: Protocol Oriented, Swift Open Source, Extension, Swift in the server… You can build your developer brand around the topic. After a few conferences talking about it, the community will tag you as the expert in the topic X. You might not have worked in a production environment with that new thing, you might not have faced the real use cases and issues, but documentation is perfect to prepare a talk based on it, isn’t it?</p></blockquote>

<p><span class='pullquote-right' data-pullquote='You don&#8217;t have to chase the &#8220;current cool thing.&#8221;'>
Yes! I totally agree with most of this, except that this is <em>positive</em>. I take exception to a few points, though. First, &ldquo;grabbing it quickly&rdquo; is not crucial. Few people talk about Bluetooth or CoreMotion despite them being around for years. If those interest you, there&rsquo;s plenty of room for new talks. (I sure would love some more on Bluetooth!) Would you be a better speaker if you shipped many production products with them? Of course. But you can still help a lot of people understand what&rsquo;s possible by spending a few months going a little further than most and coming back and teaching. Don&rsquo;t think you have to know everything before you&rsquo;re allowed to say something! Just be honest and don&rsquo;t pretend to know more than you do. There are many topics to explore. <a href="https://twitter.com/batalia">Natalia Berdys</a> gives a <a href="https://realm.io/news/tryswift-natalia-berdy-random-talk-consistent-world-noise-swift-gamekit-ios/">brilliant talk</a> on random number generation. You can&rsquo;t get much more niche than that. You don&rsquo;t have to chase the &ldquo;current cool thing.&rdquo;
</span></p>

<p>I don&rsquo;t know how it is for most speakers, but for me, preparing a talk is very difficult. It took me nearly five months to develop my <a href="https://realm.io/news/tryswift-rob-napier-swift-legacy-functional-programming/">talk for try! Swift</a>. I completely rewrote it four times and practiced it for weeks. I think many speakers are much faster at this than I am, so it may not be so hard for you. But if you find it challenging and find yourself throwing away draft after draft because you can&rsquo;t figure out what you&rsquo;re trying to say, just know you&rsquo;re not alone. If it matters to you, keep at it, and don&rsquo;t be afraid to throw away a draft that isn&rsquo;t working.<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>

<p>If you want to give a talk, and think I can help you make it better, please reach out. I&rsquo;ve critiqued talks before, and I&rsquo;m happy to keep doing it. (I will start by asking you to evaluate the talk using <a href="http://www.slideshare.net/garrets/goethes-three-questions">Goethe&rsquo;s Three Questions</a>. You have been warned.)</p>

<p>And if you read all this and say &ldquo;hey, I don&rsquo;t even <em>want</em> to give a talk,&rdquo; that is absolutely fine. Most people don&rsquo;t. As anyone who&rsquo;s scheduled CocoaHeads talks before knows, public speaking isn&rsquo;t for everyone and one reason there&rsquo;s a small group who speaks so often is because they&rsquo;re the ones willing to do it. It&rsquo;s hard and it&rsquo;s scary and it&rsquo;s rewarding and it&rsquo;s valuable. And sometimes it&rsquo;s even fun. I hope we can include everyone who wants to be part of it. And I hope there&rsquo;s always a venue for those who want to listen.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>I&rsquo;m only talking here about whether and how to broaden the number of unique speakers, because I believe this is Pedro&rsquo;s point. I think there&rsquo;s a different, very important discussion about diversity of background and drawing from marginalized groups. What I&rsquo;m going to discuss can help, but that problem requires and deserves more targeted effort than I&rsquo;m discussing here.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>This advice assumes a lot of privilege. I know there are many people who don&rsquo;t have the kind of time I do and don&rsquo;t have the kind of family support I have. I don&rsquo;t know the answer for that. If I didn&rsquo;t have much of the privilege I have, I don&rsquo;t know how I would speak at conferences. Take my advice for what it&rsquo;s worth; it doesn&rsquo;t apply to everyone.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Copying]]></title>
    <link href="https://robnapier.net/copying"/>
    <updated>2016-09-03T13:56:14-04:00</updated>
    <id>https://robnapier.net/copying</id>
    <content type="html"><![CDATA[<p>I&rsquo;m on my way back from <a href="http://tryswiftnyc.com">try! Swift</a>, which was fantastic. Of course it had those obvious things I&rsquo;d hope for. Interesting talks, friendly people. Making new friends, and reuniting with old ones. But it also had some surprising delights and lessons.</p>

<p>I travel pretty well, but sometimes I make mistakes, and this was one of those times. The deodorant I thought I&rsquo;d packed turned out to be body wash. Now there are a dozen reason that this shouldn&rsquo;t really matter, and wouldn&rsquo;t really matter given the A/C and the weather, etc., but I&rsquo;m a product of my culture, and it was a bit stressful. I tried to find a drug store on the way to the conference, but I was afraid of being late and finally resigned myself to accepting things as they are and moving on.</p>

<p>And then, in the conference rest room, I discovered a small cache of toiletries under a try! Swift sign saying &ldquo;if you need one, please take one.&rdquo; I was dumbfounded. It was a very small kindness, but it mattered to me.</p>

<!--more-->


<p>I spoke to the conference organizer, <a href="https://twitter.com/NatashaTheRobot">Natasha</a>, to thank her. She immediately told me it wasn&rsquo;t her idea, she&rsquo;d just copied it from <a href="https://twitter.com/erikpub/">Erik Romijn</a>. I went to thank Erik, and he assured me it wasn&rsquo;t his idea, he&rsquo;d just copied it from Django conferences he&rsquo;d been a part of. So I just wanted to say thanks to whomever came up with this very kind idea.</p>

<hr />

<p>To me, the best part of try! Swift was chatting with people during the breaks and in office hours. Hopefully the videos will be up soon, since I missed a few presentations due to conversations that ran long. So if you only &ldquo;attend&rdquo; by watching the videos online (like I did for the first one in Tokyo), you&rsquo;ll unfortunately miss the best parts. I wish I could change that for you, but I can&rsquo;t. I&rsquo;m sorry.</p>

<p>One of the more interesting talks I had was about cut and pasting from Stack Overflow. This practice <a href="https://www.gitbook.com/book/tra38/essential-copying-and-pasting-from-stack-overflow/details">gets a lot of shaming</a>, and we were discussing that. I can&rsquo;t promise that this conversation actually took the form of a Platonic dialog, but I can&rsquo;t promise it didn&rsquo;t, either. You&rsquo;ll have to see me at a conference to find out.</p>

<p><strong>Anubis:</strong> I&rsquo;ve only been programming for a little while. Swift is my first language, and I really don&rsquo;t know anything yet. I find myself just searching Stack Overflow and cutting and pasting code. I know that&rsquo;s a horrible way to program, but I don&rsquo;t know what else to do. Before the Internet, I guess people had to figure it out themselves, but we&rsquo;ve all gotten so lazy.</p>

<p><strong>Kakophonis:</strong> Most of my first years programming were just copying BASIC out of <a href="http://www.nibblemagazine.com/Nibble_Magazines.htm">Nibble magazine</a>.</p>

<p><strong>Anubis:</strong> You mean reading articles and implementing what they taught?</p>

<p><strong>Kakophonis:</strong> Oh, no. I mean typing hundreds and hundreds of lines of code for full programs that they included.</p>

<p><strong>Anubis:</strong> So you didn&rsquo;t really learn much those first few years.</p>

<p><strong>Kakophonis:</strong> I learned a lot. I learned to use my tools. I learned to debug because I made a lot of typing mistakes. But most of all, I learned what good programs looked like. These were working programs written by good programmers. And I didn&rsquo;t just read their code, I started changing it. Not a lot. I didn&rsquo;t know a lot. But I learned to change the colors, or add a trivial feature, or just make random changes that made me happier with it.</p>

<p><strong>Anubis:</strong> When did you stop copying other people&rsquo;s code and become a real programmer?</p>

<p><strong>Kakophonis:</strong> I copy code all the time.</p>

<p><strong>Anubis:</strong> As a short-cut, right? To make a deadline?</p>

<p><strong>Kakophonis:</strong> Not at all. I use others' code whenever it&rsquo;s beautiful and useful and they&rsquo;ve shared it. But you&rsquo;re right that I copy code a little differently than a beginner does.</p>

<p><strong>Anubis:</strong> How so?</p>

<p><span class='pullquote-right' data-pullquote='I usually retype the code by hand.'>
<strong>Kakophonis:</strong> I rarely cut and paste. Maybe it&rsquo;s a habit from my magazine days, but I usually retype the code by hand. Stack Overflow answers aren&rsquo;t very long, and retyping gives me a chance to really think about what the code is doing. And then, if the code works and solves my problem, I usually restyle it to match my preferences and make it a little more my own. I almost always rename things. Sometimes I rewrite it from scratch. I make sure I know what each line does and why it&rsquo;s there.
</span></p>

<p><strong>Anubis:</strong> Is that all?</p>

<p><strong>Kakophonis:</strong> If the code is more than a line or two, I generally add a comment crediting the source.</p>

<p><strong>Anubis:</strong> For politeness?</p>

<p><strong>Kakophonis:</strong> Yes, but more importantly, I want future maintainers, which is sometimes me, to know the context around the code, why it does things this way. That keeps them from creating regression bugs if they ever need to rewrite it further.</p>

<p><strong>Anubis:</strong> It sounds like you might learn more about programming from copying that way than from doing it yourself.</p>

<p><span class='pullquote-right' data-pullquote='A mark of a good programmer is the ability to distinguish what they should copy from what they shouldn&#8217;t.'>
<strong>Kakophonis:</strong> Exactly. But copying only improves your code and your understanding if you choose the right things to copy. Many answers on Stack Overflow are incorrect, or they&rsquo;re presented as magic incantations that may work, but are fragile. A mark of a good programmer is the ability to distinguish what they should copy from what they shouldn&rsquo;t. Stack Overflow provides beginners some clues about quality, like votes and reputation and comments, but ultimately it&rsquo;s experience that will help you recognize good code.
</span></p>

<p><strong>Anubis:</strong> So Stack Overflow doesn&rsquo;t make us weak programmers?</p>

<p><strong>Kakophonis:</strong> It&rsquo;s a tool. It is what you make of it. Programmers today have many more resources than they did before the Internet. It&rsquo;s easy to think that the previous generations had it much harder. But computers and programs were also much, much simpler. No networking. No threading. Not even a GUI. I&rsquo;m amazed that anyone is able to jump straight to building an iOS app with no programming experience. I had 25 years of experience before I encountered my first multi-threaded program. No, I don&rsquo;t think beginning programmers today are weak.</p>

<hr />

<p>Sometimes life is not unlike programming. Who and what we choose to copy says a lot about us. Choosing to use someone&rsquo;s idea is still a choice. Give credit to your inspirations, but don&rsquo;t discount the wisdom in picking something beautiful to copy.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Inspiration]]></title>
    <link href="https://robnapier.net/inspiration"/>
    <updated>2016-08-26T15:46:27-04:00</updated>
    <id>https://robnapier.net/inspiration</id>
    <content type="html"><![CDATA[<p>As a speaker, writer, and member of our community, <a href="http://dimsumthinking.com">Daniel Steinberg</a> is my inspiration. That&rsquo;s not a secret. If you and I have spent much time talking after a conference, I&rsquo;ve probably mentioned it. It&rsquo;s not the sort of thing you usually say to someone, and I don&rsquo;t think I ever have, but I&rsquo;ve learned a lot from his speaking style, and I constantly try to live up to his standard of kindness. I&rsquo;m not by nature very kind, so if you see me behaving that way, I&rsquo;m likely trying to do what I think Daniel might.</p>

<p>This isn&rsquo;t to say we&rsquo;re close. We see each other at conferences. We email and tweet. We&rsquo;re members of a community. So of course I have some idealized picture of him in my mind, without all the this and that of a real person. Even so, he inspires me. When my wife, Janet, and I talk about what&rsquo;s ahead for our future, we always talk about Daniel and his wife, Kim. I&rsquo;ve seen them at conferences, traveling together, independent but a team, and I think, hey, we could pull that off when the kids go to school. And Janet and I talk about how to make that work. And we know we only have the shallowest understanding of their real lives, but they inspire us.</p>

<p>Kim died this week. I didn&rsquo;t know her well. We&rsquo;d met, and she was nice to me. She and Daniel always seemed so &ldquo;together&rdquo; even when they were apart most of the day. Hearing the news unmoored me and scared me and made me think about myself and my family and my plans. And then my heart broke for Daniel.</p>

<p>I&rsquo;m not kind by nature. But I&rsquo;m part of a community that is, and part of that is Daniel&rsquo;s influence on us. <a href="https://twitter.com/designatednerd">Ellen Shapiro</a> has been kind and <a href="http://support.smiletrain.org/site/RedirectHandler?type=goto&amp;key=ios-for-kim">set up a fund</a> to let us support SmileTrain, where Daniel and his daughter Maggie have asked us to give in Kim&rsquo;s name. I had never heard of SmileTrain, but it is so perfect. It is kind. And it is practical. It is literally the gift of a smile. It is Daniel and Kim.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSData, My Old Friend]]></title>
    <link href="https://robnapier.net/nsdata"/>
    <updated>2015-10-07T20:27:00-04:00</updated>
    <id>https://robnapier.net/nsdata</id>
    <content type="html"><![CDATA[<h2>Or&hellip; &ldquo;How I learned to stop worrying, and love Foundation.&rdquo;</h2>

<blockquote><p>Forgive me, NSData. I was running around with that flashy [UInt8], acting like you didn&rsquo;t have everything I need. I&rsquo;ve learned my lesson.</p>

<p>&mdash; Rob Napier (@cocoaphony) <a href="https://twitter.com/cocoaphony/status/648514927678910464">September 28, 2015</a></p></blockquote>

<p>I did a lot of writing and rewriting of the <a href="https://github.com/RNCryptor/RNCryptor/releases/tag/RNCryptor-4.0.0-beta.1">Swift version of RNCryptor</a>. I struggled especially with what type to use for data. I gravitated quickly to <code>[UInt8]</code> with all its apparent Swiftiness. But in the end, after many iterations, I refactored back to <code>NSData</code>, and I&rsquo;m really glad I did.</p>

<p>This is the story of why.</p>

<!-- MORE -->


<h3>In fair frameworks, where we lay our scene</h3>

<p>First, I want to be clear that I don&rsquo;t think <code>[UInt8]</code> is bad. In some places it&rsquo;s better than <code>NSData</code>, but there are tradeoffs, and ultimately I found the tradeoffs favored <code>NSData</code> today. Some of those will improve in Future Swift, and I suspect something more Swifty than <code>NSData</code> will be the way of the future. But today, in the kinds of projects I work on, there&rsquo;s a lot going for <code>NSData</code>.</p>

<p>&ldquo;In the kinds of projects I work on&rdquo; is an important caveat. I mostly build things that are used by other developers; frameworks, engines, services, even just snippets of code. I don&rsquo;t build a lot of full applications that an end user would see. And the systems I build typically have a very small API surface. They typically do just one thing, and they&rsquo;re built to be easily clicked together with things that I didn&rsquo;t write.</p>

<p>To achieve that, I try to make most of my code as self-contained as possible, with minimal dependencies. I try to make it easy to plug into whatever system you prefer. That usually means sticking as much as possible to the types provided by the system. Much as I love <a href="https://github.com/antitypical/Result"><code>Result</code></a>, none of my systems use it externally (and only a few use it internally). I try to avoid exposing my caller to any cleverness. If they&rsquo;re familiar with the platform, I want them to find my API obvious, even boring. If they have a preferred error handling system, they probably have a way to convert <code>throws</code> to it, since that&rsquo;s what Cocoa generates. So I use <code>throws</code>.</p>

<h3>The elephant in the room</h3>

<p>I see a lot of Swift devs behaving as though Cocoa has somehow disappeared. Cocoa has become the embarrassing uncle that no one wants to acknowledge, even though he&rsquo;s sitting right there at Thanksgiving dinner passing you the potatoes. And this is crazy. First, Cocoa is a <em>great</em> framework, filled with all kinds of tools that we use every day, implemented well and refined for years. And second, Cocoa is a <em>required</em> framework, filled with tools that we <em>have</em> to use every day if we want to write apps.</p>

<p>Trying to cordon off Cocoa means constantly converting your types and patterns. That&rsquo;s horrible for programs, and it&rsquo;s very unswifty. Swift is all about integrating cleanly with Cocoa.</p>

<p>If you&rsquo;re writing Cocoa apps you wind up with <code>NSData</code> all the time. You get it when you read or write files, when you download things from the network, when you create PNGs, when you serialize. You can&rsquo;t escape <code>NSData</code>. Swift automatically bridges <code>NSString</code> and <code>String</code>, <code>NSArray</code> and <code>Array</code>, <code>NSError</code> and <code>ErrorType</code>. Some day I hope <a href="http://www.openradar.me/23010231"><code>NSData</code> gets a bridge</a>, but it doesn&rsquo;t have one today. So the question is what to do in the meantime?</p>

<p>There are basically two options: build the bridge or use <code>NSData</code>. Building the bridge (without modifying stdlib) is tricky if you want to avoid copying. It&rsquo;s not hard if you&rsquo;re not worried about performance, but an <code>NSData</code> can easily be multiple megabytes and that&rsquo;s both time and memory. Even temporary copies raise your high water mark, which hurts the whole system. Yes, I know all about premature optimization, but when you&rsquo;re building frameworks you need to avoid patterns that are reasonably likely to cause performance problems. Even when you&rsquo;re building just one app, there&rsquo;s a difference between &ldquo;build simply, then optimize&rdquo; and &ldquo;throw performance out the window until Apple rejects your app, then optimize.&rdquo; If it were just one copy, and it made everything else really simple, that might be worth discussing. But making a copy every time you move from one part of the system to another is a problem.</p>

<p>With enough work you can solve this problem. It&rsquo;s not tons of code, but it is a little bit tricky to be certain you&rsquo;ve done it exactly right and won&rsquo;t leak or crash (and much trickier to do from outside of stdlib). But is that work and complexity worth it? What problems were we really solving converting <code>NSData</code> to <code>[UInt8]</code>?</p>

<h3>The magic that is <code>Array</code></h3>

<p>Even if you don&rsquo;t care about <code>NSData</code> interop, using <code>[UInt8]</code> doesn&rsquo;t give you a magical unicorn API. <code>Array</code> has all kinds of little sharp edges that surprise and confuse if you want to very careful of making copies.</p>

<p>Let&rsquo;s start with a simple function using <code>NSData</code> and see what happens with <code>[UInt8]</code>. This function takes a <code>CCCryptorRef</code> and updates it with some data, writes the resulting encrypted data to a buffer and returns the buffer.</p>

<pre><code>func updateCryptor(cryptor: CCCryptorRef, data: NSData) -&gt; NSData {
    let outputLength = CCCryptorGetOutputLength(cryptor, data.length, false)
    let buffer = NSMutableData(length: outputLength)!
    var dataOutMoved: Int = 0

    let result = CCCryptorUpdate(cryptor,
        data.bytes, data.length,
        buffer.mutableBytes, buffer.length,
        &amp;dataOutMoved)
    guard result == 0 else { fatalError() }

    buffer.length = dataOutMoved
    return buffer
}
</code></pre>

<p>No problems there IMO. That&rsquo;s a fine implementation. Easy to read and understand (if you understand <code>CCCryptorRef</code>). The <code>[UInt8]</code> implementation is about the same. I don&rsquo;t think you could say one is really much cleaner than the other.</p>

<pre><code>func updateCryptor_(cryptor: CCCryptorRef, data: [UInt8]) -&gt; [UInt8] {
    let outputLength = CCCryptorGetOutputLength(cryptor, data.length, false)
    var buffer = [UInt8](count: outputLength, repeatedValue: 0)
    var dataOutMoved: Int = 0

    let result = CCCryptorUpdate(cryptor,
        data, data.count,
        &amp;buffer, buffer.count,
        &amp;dataOutMoved)
    guard result == 0 else { fatalError() }

    buffer[dataOutMoved..&lt;buffer.endIndex] = []
    return buffer
}
</code></pre>

<p>But is it correct? Can we be certain that <code>data</code> is contiguous memory and isn&rsquo;t really an <code>NSArray&lt;NSNumber&gt;</code> under the covers? If it is an <code>NSArray</code>, will this work or will we get the wrong data? Should we use <code>.withUnsafePointer</code> here? I studied the docs, and talked to several devs (including Apple devs), and in the end am pretty sure that this will always work. But I&rsquo;m only &ldquo;pretty sure.&rdquo; And that&rsquo;s only because of kind people at Apple (especially @jckarter) taking time to walk through it with me. Not everyone has that.</p>

<p>This &ldquo;but is it correct?&rdquo; came up all over the place. Would this operation cause a copy? Exactly how long is an <code>UnsafeBufferPointer</code> valid? There&rsquo;s a lot of bridging magic in <code>Array</code>, and it&rsquo;s not always clear what is <em>promised</em>. Testing only gets you so far if the current implementation just happens to work. Sometimes behaviors change just by importing Foundation.</p>

<p>I thought I might avoid the Cocoa-bridging ambiguities of <code>Array</code> by using <code>ContiguousArray</code> instead. That way I could be very precise about my expectations. But it turns out that passing <code>ContiguousArray</code> to C behaves very differently than passing <code>Array</code>. <code>Array</code> gets turned into a pointer to the first element, but <code>ContiguousArray</code> gets turned into a pointer to the struct. So the <code>ContiguousArray</code> gets corrupted and you crash. <code>Array</code> is more magical than you think. Magic is wonderful until your program crashes and you don&rsquo;t know why.</p>

<p>I struggled with copy-on-write behavior. How do I know if an array&rsquo;s buffer is shared so that a copy will happen on mutation? Will this code allocate 10MB or 20MB?</p>

<pre><code>func makeArray() -&gt; [UInt8] {
    return Array(count: 10_000_000, repeatedValue: 0)
}
var array = makeArray() + [1]
</code></pre>

<p>What tests would prove that? Is it promised or just the current implementation? Does optimization level matter? Is it the same if <code>makeArray()</code> is in another module than the caller? Would small changes in my code lead to dramatic and surprising performance changes in apps that use my framework? This was a common problem in Scala before the <code>@tailrec</code> annotation was added. Very small tweaks to a recursive function could cause your stack to explode because you quietly broke tail call optimization. All your unit tests still pass, but the program crashes.</p>

<p>In the end, I spent hours trying to be certain of the precise behaviors of <code>Array</code> bridging and copying. And all that to replace <code>NSData</code> code that is perfectly fine.</p>

<h3>Slice and dice</h3>

<p>When updating the cryptor, it is common that you&rsquo;ll only want some of the data you were passed. You might want to slice off a header, or you might want to chunk the data up to reduce your encryption buffer size. In either case, you want to pass <code>updateCryptor()</code> a slice.</p>

<p>For an immutable <code>NSData</code> that&rsquo;s easy. Call <code>.subdataWithRange()</code> and you get another <code>NSData</code> back with no copying.</p>

<p>But the <code>SubSequence</code> of <code>Array</code> is <code>ArraySlice</code>, and <code>updateCryptor()</code> doesn&rsquo;t accept that. Of course you can copy your slice into a new <code>Array</code>, but unnecessary copying was what we wanted to avoid.</p>

<p>We could make all the functions take <code>ArraySlice</code> and overload all the functions with an <code>Array</code> interface that forwards to the <code>ArraySlice</code> interface. But it&rsquo;s a lot of duplication.</p>

<p>So I decided to just convert everything to <code>UnsafeBufferPointer</code> and then pass that around internally. Easier semantics after a one-time conversion. No bridging worries. No unexpected copies. It seemed like a good idea at the time.</p>

<p>The problem is that using <code>UnsafeBufferPointer</code> everywhere tends to turn your code inside out. Where you used to say:</p>

<pre><code>updateCryptor(cryptor, data: data)
</code></pre>

<p>You now have to say:</p>

<pre><code>data.withUnsafeBufferPointer { updateCryptor(cryptor, data: $0) }
</code></pre>

<p>Two solutions present themselves. First you decide that you are very clever, and use the <code>UnsafeBufferPointer</code> constructor:</p>

<pre><code>// Never do this
updateCryptor(cryptor, data: UnsafeBufferPointer(start: data, count: data.count))
</code></pre>

<p>Then @jckarter points out that by the time <code>updateCryptor</code> runs, there&rsquo;s no promise that the <code>UnsafeBufferPointer</code> is still valid. ARC could destroy <code>data</code> before the statement even completes. (If you know that <code>data</code> is life-extended, then it is possible to know this will work, but it&rsquo;s very unsafe, fragile, and hard to audit. Coding that way breaks everything Swift was trying to fix.)</p>

<p>So then you start creating function overloads to accept <code>Array</code> and <code>ArraySlice</code> and convert them into <code>UnsafeBufferPointer</code>, and you have even more duplicated code. And then you realize you want to accept <code>NSData</code> here, too, so you write an extension that adds <code>.withUnsafeBufferPointer()</code> to <code>NSData</code>, and now you have four versions of every function, and you realize you really should use a protocol instead. Brilliant!</p>

<pre><code>protocol BufferType {
    func withUnsafeBufferPointer&lt;R&gt;(body: (UnsafeBufferPointer&lt;UInt8&gt;) throws -&gt; R) rethrows -&gt; R
}
</code></pre>

<p>This really feels like it&rsquo;ll solve all these problems very elegantly. Except for this one problem. You want <code>[UInt8]</code> to be a <code>BufferType</code>, but you don&rsquo;t want <code>[String]</code> to be a <code>BufferType</code>. And then you discover that while you can write extensions that only apply to <code>[UInt8]</code>, you can&rsquo;t use those extensions to conform to a protocol. And that&rsquo;s when the screaming starts. And then the barginning, and then the drinking.</p>

<p>When you get to the muttering, you came back and start building a <code>Buffer</code> class to wrap <code>Array</code>, <code>ArraySlice</code>, <code>NSData</code>, and even <code>CollectionType</code> to give it all a consistent interface. It&rsquo;s ok, but it creates another &ldquo;thing&rdquo; for callers to deal with. In almost all cases, they have an <code>NSData</code>. There is almost no chance they had a <code>[UInt8]</code>. This is all just an extra layer for callers to deal with and to get in the way of the optimizer.</p>

<p>I want to remind you that all of this, all these many, many hours of struggle, were to avoid the simple <code>NSData</code> code that took two minutes to write, works great, and is pretty darn Swifty as long as you don&rsquo;t define &ldquo;Swifty&rdquo; as &ldquo;does not import Foundation.&rdquo;</p>

<h2>What&rsquo;s the matter with NSData?</h2>

<p>So why did I resist using <code>NSData</code> anyway? Well, even though I believe the Foundation is absolutely a part of Swift, some of it isn&rsquo;t <em>great</em> Swift. Notably <code>NSData</code> isn&rsquo;t a <code>CollectionType</code>. But fixing that is <a href="https://gist.github.com/rnapier/da148690af63c401097d">pretty easy</a>.</p>

<p>End-to-end <code>NSData</code> also opened up some other opportunities for me, namely <code>dispatch_data</code>, which had threatened to be another can of worms with <code>[UInt8]</code>.</p>

<p>For some, none of this will matter. The vast majority of my problems come from trying to dodge unnecessary copies. Much of this is very simple if you&rsquo;re willing to just copy the data all over the place. For many kinds of problems, that&rsquo;s fine. Use whatever you like. The copy-on-write system is actually pretty awesome and for most problems you can certainly trust it.</p>

<p>But for those in my situation, where performance is a serious consideration in much of your code, you&rsquo;re looking for predictability as much as speed, and data can be huge, my hope is we get a <code>Buffer</code> type (or <code>Data</code> or whatever) that acts as a bridge to <code>NSData</code>, supports <code>dispatch_data</code>, and plays nicely with stdlib. But until that comes, I think <code>NSData</code> is just fine.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Type-erasure in Stdlib]]></title>
    <link href="https://robnapier.net/type-erasure-in-stdlib"/>
    <updated>2015-10-06T19:05:13-04:00</updated>
    <id>https://robnapier.net/type-erasure-in-stdlib</id>
    <content type="html"><![CDATA[<p>When <a href="http://robnapier.net/erasure">last we talked about type erasure</a>, I described an easy way to build type erasures using closures. And I mentioned:</p>

<blockquote><p>(While this works exactly like AnySequence, this isn’t how AnySequence is implemented. In my next post I’ll discuss why and how to implement type erasers like stdlib does.)</p></blockquote>

<p>At the time I thought I&rsquo;d pretty well nailed it down, but every time I dug into it I found another little thing I&rsquo;d missed, and it never seemed to end. And with stdlib open sourcing soon, you&rsquo;ll all just be able to read this yourselves, so why embarrass myself getting it all wrong? Over time I kind of hoped you all had forgotten that comment and planned to move on to other things. But then I was <a href="https://twitter.com/My_kl/status/650796108789219328">busted by Michael Welch</a>, and so I had to finish the spelunking and here you go.</p>

<!-- more -->


<p>So, <a href="https://github.com/rnapier/MyAnySequence">here</a> is my annotated implementation of <code>AnyGenerator</code> and <code>AnySequence</code> that I believe pretty closely matches Apple&rsquo;s implementation in stdlib (minus some low-level optimizations in <code>AnySequence</code> that I&rsquo;ll call out when we get there). I&rsquo;ve named my versions of public symbols with a trailing underscore to differentiate from the Swift version. For private symbols (with leading underscore), I&rsquo;ve used the same name Swift does.</p>

<p>All type information was determined using <code>:type lookup</code> in the Swift REPL. In a few places I checked the implementation with Hopper, but in most cases, once you have the types, the implementation is obvious. (There&rsquo;s a deep lesson in there if you pay attention.)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RNCryptor V4]]></title>
    <link href="https://robnapier.net/rncryptor-v4"/>
    <updated>2015-10-04T12:38:36-04:00</updated>
    <id>https://robnapier.net/rncryptor-v4</id>
    <content type="html"><![CDATA[<p>After months of writing and rewriting, I am happy to finally announce <a href="https://github.com/RNCryptor/RNCryptor/releases/tag/RNCryptor-4.0.0-beta.1">RNCryptor 4 beta 1</a> in Swift.</p>

<p>RNCryptor 4 is a complete rewrite of RNCryptor for Swift 2 with full bridging support to Objective-C. It has a streamlined API, simpler installation, and improved internals. It continues to use the <a href="https://github.com/RNCryptor/RNCryptor-Spec/blob/master/RNCryptor-Spec-v3.md">v3 data format</a> and is fully interoperable with <a href="https://github.com/RNCryptor">other RNCryptor implementations</a>.</p>

<!-- more -->


<p>For users desiring a fully Objective-C solution, <a href="https://github.com/RNCryptor/RNCryptor/releases/tag/RNCryptor-3.0.1">v3</a> is still available. I don&rsquo;t currently plan to do significant new work on v3, but will consider it if there is strong interest. Going forward, I expect most OS X and iOS projects to be able to accept a mix of ObjC and Swift code. Objective-C continues to be a fully supported language in RNCryptor 4.</p>

<p>I plan to convert this to a final release in a week or so if no major issues are discovered.</p>

<p>I now move onto:</p>

<ul>
<li>Continuing to prepare for <a href="http://www.dotswift.io">dotSwift</a>.</li>
<li>Getting back to the blog.</li>
<li>RNCryptor v5, which will finally update the data format to improve performance, security, and robustness. Much of the v4 design was specifically to make v5 easier to write.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Little Respect for AnySequence]]></title>
    <link href="https://robnapier.net/erasure"/>
    <updated>2015-08-04T15:42:00-04:00</updated>
    <id>https://robnapier.net/erasure</id>
    <content type="html"><![CDATA[<p>Once upon a time, when Swift was young, there were a couple of types called <code>SequenceOf</code> and <code>GeneratorOf</code>, and they could type erase stuff. &ldquo;Type erase?&rdquo; you may ask. &ldquo;I thought we <em>loved</em> types.&rdquo; We do. Don&rsquo;t worry. Our types aren&rsquo;t going anywhere. But sometimes we want them to be a little less&hellip;precise.</p>

<p>In Swift 2, our little type erasers got a rename and some friends. Now they&rsquo;re all named &ldquo;Any&rdquo;-something. So <code>SequenceOf</code> became <code>AnySequence</code> and <code>GeneratorOf</code> became <code>AnyGenerator</code> and there are a gaggle of indexes and collections from <code>AnyForwardIndex</code> to <code>AnyRandomAccessCollection</code>.</p>

<p>So what are these type erasers? Let&rsquo;s start with how to use one and we&rsquo;ll work backwards to why.<!-- more --></p>

<pre><code>let seq = AnySequence([1,2,3])
</code></pre>

<p>This creates an <code>AnySequence&lt;Int&gt;</code>. It&rsquo;s just a sequence of Ints that we can iterate over. Isn&rsquo;t <code>[1,2,3]</code> also a sequence of Ints we can iterate over? Well, yeah. But it&rsquo;s also explicitly an Array. And sometimes you don&rsquo;t want to have to deal with that kind of implementation detail.</p>

<h2>Who Needs Types Like That?</h2>

<p> Let&rsquo;s consider a little more complicated case:</p>

<pre><code>let xs = [1,2,3]
let ys = ["A","B","C"]
let zs = zip(xs.reverse(), ys.reverse())
// Zip2Sequence&lt;ReverseRandomAccessCollection&lt;Array&lt;Int&gt;&gt;, ReverseRandomAccessCollection&lt;Array&lt;String&gt;&gt;&gt;
</code></pre>

<p>That&rsquo;s quite a type. Imagine it as the return type of a function:</p>

<pre><code>func reverseZip&lt;T,U&gt;(xs: [T], _ ys: [U]) -&gt; Zip2Sequence&lt;ReverseRandomAccessCollection&lt;[T]&gt;, ReverseRandomAccessCollection&lt;[U]&gt;&gt; {
  return zip(xs.reverse(), ys.reverse())
}
</code></pre>

<p>That&rsquo;s insane. Let&rsquo;s not do that. Not only is the type overwhelming, but it ties us to this particular implementation. We might want to refactor the code like this:</p>

<pre><code>  return zip(xs, ys).reverse()
</code></pre>

<p>Then the return type would change to <code>[(T,U)]</code> and all the callers would have to be updated. Clearly we&rsquo;re leaking too much information about our implementation. What&rsquo;s the point of <code>reverseZip</code>? Is it to return a <code>Zip2Sequence&lt;...&gt;</code>? No. It&rsquo;s to return a sequence of tuples. We want a type that means &ldquo;a sequence of tuples.&rdquo; Often we use <code>Array</code> for that, but there&rsquo;s an even less restrictive way that doesn&rsquo;t require making an extra copy: <code>AnySequence</code>.</p>

<pre><code>func reverseZip&lt;T,U&gt;(xs: [T], _ ys: [U]) -&gt; AnySequence&lt;(T,U)&gt; {
    return AnySequence(zip(xs, ys).reverse())
}
</code></pre>

<p>Now we can keep our implementation details private. If we have some internal sequence type, we don&rsquo;t have to share it with our callers. We just give them what they need and no more.</p>

<p>Notice that <code>AnySequence</code> is not a protocol. It&rsquo;s a generic <code>struct</code> that wraps another sequence. You can&rsquo;t use an <code>[Int]</code> in a place that expects an <code>AnySequence&lt;Int&gt;</code>. You still want to use <code>SequenceType</code> for parameters in most cases.</p>

<p>These &ldquo;Any&rdquo; type erasers also aren&rsquo;t like <code>Any</code> and <code>AnyObject</code>, which are protocols that just &ldquo;hide&rdquo; the type. You can still <code>as!</code> an <code>AnyObject</code> back to its original type. <code>AnySequence</code> and its kin completely encapsulate the underlying data. You can&rsquo;t get the original back. This creates a very strong abstraction layer and strengthens type safety by making <code>as!</code> casting impossible.</p>

<p><a href="http://www.openradar.me/radar?id=5528602095386624">The new names worry me a little</a> because they make it look like <code>AnyObject</code> and <code>AnySequence</code> are the same kind of thing when they&rsquo;re not. But the new naming convention is definitely more flexible. You couldn&rsquo;t have named the <code>AnyIndex</code> types using the old <code>...Of</code> convention. So, I&rsquo;m getting used to the new names.</p>

<h2>Chains of Association</h2>

<p>Hopefully by now you&rsquo;re sold on why you&rsquo;d want to use a type eraser. But would you ever want to build one? Let&rsquo;s look at an example that comes up pretty often around associated types in protocols.</p>

<pre><code>// An Animal can eat
protocol Animal {
    typealias Food
    func feed(food: Food)
}

// Kinds of Food
struct Grass {}
struct Worm {}

struct Cow: Animal {
    func feed(food: Grass) { print("moo") }
}

struct Goat: Animal {
    func feed(food: Grass) { print("bah") }
}

struct Bird: Animal {
    func feed(food: Worm) { print("chirp") }
}
</code></pre>

<p>So now let&rsquo;s say we have a bunch of grass available and we&rsquo;d like to feed it to some grass eaters. Seems easy:</p>

<pre><code>for animal in grassEaters {
    animal.feed(Grass())
}
</code></pre>

<p>Now we just have to create this array of grass eaters. Should be simple, right? Hmmm&hellip;</p>

<pre><code>let grassEaters = [Cow(), Goat()] // error: '_' is not convertible to 'Goat'
</code></pre>

<p>That&rsquo;s a weird error. We probably just need to be explicit about the the type.</p>

<pre><code>let grassEaters: [Animal] = [Cow(), Goat()]
// error: protocol 'Animal' can only be used as a generic constraint because it has Self or associated type requirements
</code></pre>

<p>We all know that error, don&rsquo;t we? OK, let&rsquo;s try generics.</p>

<pre><code>let grassEaters: [Animal&lt;Grass&gt;] = [Cow(), Goat()]
// error: protocol 'Animal' can only be used as a generic constraint because it has Self or associated type requirements
</code></pre>

<p>Still? Oh right. You can&rsquo;t specialize an associated type using generic syntax. That&rsquo;s fine, we&rsquo;ll just make the protocol generic.</p>

<pre><code>protocol Animal&lt;Food&gt; {
    func feed(food: Food)
}
// error: Statement cannot begin with a closure expression
</code></pre>

<p>Right, protocols can&rsquo;t be generic. Type-safety is for chumps. Let&rsquo;s go back to Objective-C.</p>

<p>&hellip;Or maybe type erasure is what we need. Let&rsquo;s build <code>AnyAnimal</code>. There are several ways to do this, but the easiest in my opinion is with closures.</p>

<pre><code>struct AnyAnimal&lt;Food&gt;: Animal {
    private let _feed: (Food) -&gt; Void
    init&lt;Base: Animal where Food == Base.Food&gt;(_ base: Base) {
        _feed = base.feed
    }
    func feed(food: Food) { _feed(food) }
}
</code></pre>

<p>(While this works exactly like <code>AnySequence</code>, this isn&rsquo;t how <code>AnySequence</code> is implemented. In my next post I&rsquo;ll discuss why and how to implement type erasers like stdlib does.)</p>

<p>Now we can make <code>grassEaters</code>:</p>

<pre><code>let grassEaters = [AnyAnimal(Cow()), AnyAnimal(Goat())] // Type is [AnyAnimal&lt;Grass&gt;]
</code></pre>

<p>But we still get type safety if we try to incorrectly mix our animals:</p>

<pre><code>let mixedEaters = [AnyAnimal(Cow()), AnyAnimal(Bird())]
// error: type of expression is ambiguous without more context
</code></pre>

<p>This kind of type eraser lets us convert a protocol with associated types into a generic type. That means we can put it in properties and return values and other places that we can&rsquo;t use protocols directly. As you use more protocols in your Swift (and <a href="https://developer.apple.com/videos/wwdc/2015/?id=408">you should be</a>), I think this will become an important tool in your toolbelt.</p>

<p>So get out there and erase some over-specific types. Focus on the protocol, hide the implementation.</p>

<p><a href="https://gist.github.com/rnapier/03674b399e3bc517b9cd">And here&rsquo;s the code for your amusement.</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Product or Process?]]></title>
    <link href="https://robnapier.net/product-or-process"/>
    <updated>2015-07-20T11:20:17-04:00</updated>
    <id>https://robnapier.net/product-or-process</id>
    <content type="html"><![CDATA[<p>Forgive a slight divergence. I&rsquo;ll bring it back to software development before the end.</p>

<p>A friend of mine is an arborist. He takes care of a large forest, trimming and culling trees. He&rsquo;s quite good at it and enjoys it, but he&rsquo;s worried about job security. He thinks cabinet making would be a good career move. He likes to work with wood, and high-end cabinets are very expensive so there&rsquo;s clearly a lot of money there. I&rsquo;m a hobbyist woodworker, so we were talking about it.<!-- more --></p>

<hr />

<p>Me: So, what saws are you looking at?</p>

<p>Him: I have a Husqvarna 3120. That should be all I need.</p>

<p>Me: Husqvarna? Isn&rsquo;t that a&hellip;chainsaw?</p>

<p>Him: It&rsquo;s the best! I use it every day. I plan to do everything with it.</p>

<p>Me: It&rsquo;s a good saw, sure, but&hellip; um&hellip; How are you going to join the pieces?</p>

<p>Him: Dovetail joints. I&rsquo;ve heard those are best and you just have to cut notches. My chainsaw will make quick work of that.</p>

<p>Me: Dovetails have really tight tolerances. I can barely get them to work with a dovetail saw. Maybe you should start with pocket screws? They&rsquo;re much easier and make great joints. A chainsaw&hellip;</p>

<p>Him: I&rsquo;ve worked it all out. I modded this router table to hold my chainsaw upright so that&rsquo;s just like a table saw. And I can make the other cuts freehand. I&rsquo;m really good with a chainsaw. See, I already have a proof-of-concept.</p>

<p>Me: Um&hellip; that&rsquo;s just a board with a notch in it.</p>

<p>Him: Yeah, but a cabinet is just a bunch of boards with notches. I&rsquo;ll make some more and they should snap together.</p>

<p>Me: Cabinet tolerances are really tight. I mean, it&rsquo;s not that hard to make a box, but making a full cabinet is difficult, even with proper tools. Why would you want to use some cobbled-together thing? That table looks terrifying.</p>

<p>Him: Look, I know chainsaws. I&rsquo;m not going to go learn a bunch of new tools just to build cabinets. Wood is wood. Saws are saws. I&rsquo;m using the saw I&rsquo;m comfortable with. If I use the tools I know, I&rsquo;m sure I can make really great cabinets.</p>

<p>Me: &hellip;</p>

<hr />

<p>In unrelated news, a lot of folks have asked if I&rsquo;m excited that Go 1.5 can build iOS apps.</p>

<p>My wife&rsquo;s background is art education. When you&rsquo;re teaching art, she tells me, it&rsquo;s important to remember whether you&rsquo;re doing process art or product art in order to judge its success. Is the end result the goal, or how you got there? Am I trying to make the most beautiful painting I can, or am I trying to make a painting using only recycled materials? Does the audience need to know the process in order to appreciate the art, or does the end result stand on its own?</p>

<p>A lot of great hacks are process art. Can you run VMS on Linux? <a href="http://www.wherry.com/gadgets/retrocomputing/vax-simh.html">Sure you can!</a> Is that awesome? It is absolutely awesome. Is there any commercial reason to develop new VMS apps to run on Linux? Of course not. That would be ridiculous.</p>

<p>Is it fun to get the Go runtime working on surprising platforms? Sure, and the process may improve Go. That&rsquo;s why process art is so common in art education. You put unnecessary restrictions on students so that they have to develop new skills that will be useful when they work on product art. &ldquo;Draw without looking at your work&rdquo; is an important exercise, but not usually how you create a masterpiece.</p>

<p>So let&rsquo;s get to the &ldquo;unnecessary restrictions&rdquo; I&rsquo;m talking about if you want to write excellent iOS apps in Go (or C# or JavaScript or&hellip;.) I don&rsquo;t want to spend too much time on the great memory management debate. Do modern concurrent garbage collection engines work well on dual-core, 1GB iPhones? I don&rsquo;t know. I&rsquo;m still hearing a lot of complaints about GC pauses on Lollipop with 2x the memory. It&rsquo;s hard to imagine that Go GC on iOS is going to be faster and more memory efficient than Java GC on Android. But let&rsquo;s put that question aside for the moment. Let&rsquo;s assume there is a large genre of apps for which Go performance and memory usage is adequate, even excellent, on iOS devices. (This might even be true.)</p>

<p>The real question is &ldquo;what&rsquo;s the hard part of iOS development?&rdquo;</p>

<p>If you think the answer is &ldquo;Objective-C&rdquo; then you don&rsquo;t understand iOS development at all. Learning Objective-C is the <em>easiest</em> part of iOS development, doubly-so for anyone who is comfortable in a wacky (and awesome) language like Go. And when it finally settles down a bit, Swift will likely be easier to learn than Objective-C for Java-esque developers.</p>

<p>The sort-of hard piece of iOS development is UIKit, CloudKit, HomeKit, SpriteKit, SceneKit, HealthKit, WebKit, MapKit, StoreKit, GameplayKit, and another new Kit every release. It&rsquo;s power management and backgrounding and handoff and watch integration and multitasking and adaptive fonts and auto layout and animations and app thinning. You can sometimes ignore those pieces, but they&rsquo;re what separate barely acceptable apps from great apps. If your only goal is something that kind of works, fine. Anything can do that. Web apps can do that. But if you want to make a really great app, integrating with the platform is a must. And the platform is designed for Cocoa. And Cocoa is designed for ObjC and Swift. This stuff is hard when you&rsquo;re using the tools Apple <em>intends</em> you to use. Working through translation layers is surgery with welding gloves.</p>

<p>And that brings us around to the <em>really</em> hard piece of iOS development. It changes. Constantly. Apple moves forward fast and they deprecate old APIs mercilessly. Clever work-arounds have short half-lives. You have to adapt every release, and find ways to be backward compatible while still compiling against the latest SDK. Once you&rsquo;ve lived through a few releases of iOS, you discover how hard this piece can be even in ObjC, even when you&rsquo;ve followed all the rules. I don&rsquo;t envy anyone trying to deal with it through an unsupported layer. By the time anyone knows what the next iOS version breaks, the clock is already ticking. Whoever supports your extra layer has to fix their piece, and then you have to fix your piece. And with open iOS betas, your customers are already yelling.</p>

<p>So I may celebrate your chainsaw router table as a glorious (and terrifying) hack. But I&rsquo;ll stick with my table saw for cabinets and my chainsaw for cutting up trees. A good crafter is capable with many tools, not just their favorite. And most iOS apps are about product, not process.</p>

<p><a href="http://www.elementscompiler.com/elements/silver/">Swift on Android?</a> I&rsquo;ll take Java, thanks.</p>

<p>Lee Whitney has <a href="http://www.whitneyland.com/2015/07/xamarin-review-2015.html">an interesting take on this subject</a> from the C# side.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Throw Money at It]]></title>
    <link href="https://robnapier.net/throw-money"/>
    <updated>2015-06-22T14:41:00-04:00</updated>
    <id>https://robnapier.net/throw-money</id>
    <content type="html"><![CDATA[<p>My dad has always been an engineer, but by the end of his career he had three-letter titles starting with &ldquo;C&rdquo;. And all my life he&rsquo;s taught me lessons, but the most important ones to me professionally were never about technical matters; they were always the talks about how large companies work. Watching some of the reactions from devs to the recent <a href="http://taylorswift.tumblr.com/post/122071902085/to-apple-love-taylor">Taylor Swift</a>/<a href="https://twitter.com/cue/status/612824775220555776">Apple</a> back-and-forth, I realized that one of my dad&rsquo;s lessons might be helpful to others.<!-- more --></p>

<p>&ldquo;Can we solve this by throwing money at it?&rdquo; Problems come in two major forms: money problems and not-money problems. Money problems are the easy ones. If you can write a check and the whole problem goes away, that&rsquo;s the kind of problem you want. Lots of problems aren&rsquo;t like that. Sometimes it&rsquo;s because the check would have to be too big, but many times it&rsquo;s because no amount of money would fix the problem alone. It&rsquo;s not a &ldquo;throwing money&rdquo; problem. In fact, <em>most</em> problems are not-money problems when you dig into them.</p>

<p>Big companies love money problems because they have money. No matter how much they&rsquo;re cutting budget, I assure you they have money. It&rsquo;s what big companies are made of. And no matter how much they say &ldquo;employees are our greatest asset,&rdquo; I assure you that <em>money</em> is their greatest asset. That&rsquo;s why when companies can&rsquo;t find anything to invest in, they horde money and lay off employees. If employees were their greatest asset, they&rsquo;d burn money to keep them.</p>

<p>And this brings us to music streaming and the App Store and why they&rsquo;re completely different problems and why Taylor Swift could turn Apple around in 24 hours when tens of thousands of developers have groused for years about the App Store with slow improvements at best. Yes, Taylor Swift is a big name and controls a lot of content that Apple would like access to. That&rsquo;s not why it all turned around so fast. And no, Taylor Swift demanding faster App Store reviews won&rsquo;t change anything, no matter how many albums she threatens to withhold.</p>

<p>The difference is that musicians had a money problem and devs have a not-money problem.</p>

<p>What was the musician problem? Apple wasn&rsquo;t going to pay musicians during free trials (but was paying them after that). What was the solution to the musician problem? Apple writes a bigger check. They were already writing a huge check. Musicians wanted it to be a little bigger and structured a little differently. Throw money and this whole problem goes away. Musicians are happy. Taylor Swift <a href="https://twitter.com/taylorswift13/status/612841136311390209">tweets Apple love</a>. That&rsquo;s a money problem. Money problems are easy and clean.</p>

<p>What is the dev problem? App Store approvals are slow and inconsistent. It is not always clear what is or isn&rsquo;t allowed, and some decisions seem arbitrary. Apple&rsquo;s 30% cut may be high. Apple policies make many valid business models difficult or impossible. Apple technology and policies make many useful kinds of apps impossible. Apple created a 99 cent culture that undermines sustainable app development. And the list goes on.</p>

<p>Only one problem on that list is a throw-money-at-it problem: &ldquo;Apple&rsquo;s 30% cut may be high.&rdquo; OK, so Apple switches to 25% cut. Is everyone happy now? We all tweet App Store love? No. We&rsquo;re a little happier, but we&rsquo;re still grumbling because most of the problems are about process and policy (and particularly inconsistency and opaqueness), not money. Apple drops it to 20%? 10%? 0%? At what point do we say &ldquo;yep, that was the problem, thanks Apple! The App Store is fixed now.&rdquo; There is no answer. This is a not-money problem.</p>

<p>Not-money problems are a pain. There&rsquo;s no check that Apple writes that fixes their App Store problems. It&rsquo;s not even obvious exactly what you&rsquo;d change so it&rsquo;d be right. You could hire more reviewers, but then it&rsquo;s harder to keep them consistent. You could hire fewer, more heavily trained reviewers, but then review times go up. You could make your rules fixed and automatic, but then bad actors will more easily to slip through. You can adapt to bad actors as you discover them, but then you&rsquo;re inconsistent over time. The App Store is an engineering problem, not a money problem. Engineering problems are hard and messy.</p>

<p>If you want a company to do something quickly, turn it into a simple money problem if at all possible. Create situations where &ldquo;Company wants X. If Company writes a check for Y, they get X and we&rsquo;re done.&rdquo; Many problems can&rsquo;t be solved that way, but when they can, you&rsquo;re going to have much smoother sailing.</p>

<p>And that&rsquo;s why one artist can move all of Apple. Yes, she&rsquo;s big and important, but she also brought a simple problem.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Re...throws?]]></title>
    <link href="https://robnapier.net/re-throws"/>
    <updated>2015-06-18T11:12:00-04:00</updated>
    <id>https://robnapier.net/re-throws</id>
    <content type="html"><![CDATA[<p><a href="https://robnapier.net/throw-what-dont-throw">Last time</a> we talked about how a function that can
throw errors is a different type in Swift than a function that cannot throw
errors. And then I briefly mentioned this other thing, &ldquo;rethrows.&rdquo; Let&rsquo;s talk
about that, and along the way explore closure types a little more and their
weird and woolly ways. <!-- more --></p>

<p>Like last time, we start with <code>map</code> (<code>mymap</code> so there&rsquo;s no confusion with the
built-in).</p>

<pre><code>extension Array {
    func mymap&lt;T&gt;(@noescape transform: (Generator.Element) -&gt; T) -&gt; [T] {
        var ts: [T] = []
        for x in self {
            ts.append(transform(x))
        }
        return ts
    }
}
</code></pre>

<p>So that&rsquo;s the simple <code>map</code>. As we discussed previously, we can&rsquo;t pass a throwing
closure to it because it would be the wrong type. Let&rsquo;s rewrite <code>mymap</code> so it
can throw:</p>

<pre><code>extension Array {
    func mymapThrows&lt;T&gt;(@noescape transform: (Generator.Element) throws -&gt; T) throws -&gt; [T] {
        var ts: [T] = []
        for x in self {
            ts.append(try transform(x))
        }
        return ts
    }
}
</code></pre>

<p>Now <code>transforms</code> can throw, and so it needs <code>try</code> when we call it. And since we
don&rsquo;t handle the error ourselves, the whole method has to be marked <code>throws</code>.</p>

<p>Let&rsquo;s create a couple of functions to check this out:</p>

<pre><code>func double(x: Int) -&gt; Int { return x*2 }

extension NSCalculationError: ErrorType {}

func reciprocal(x: Int) throws -&gt; Double {
    guard x != 0 else { throw NSCalculationError.DivideByZero }
    return 1.0 / Double(x)
}
</code></pre>

<p>The first function, <code>double</code>, always succeeds. The second function,
<code>reciprocal</code>, may throw.</p>

<pre><code>let xs = [1,2,3]
let ds = xs.mymap(double) // No problem
let rs = try xs.mymapThrows(reciprocal) // No problem
</code></pre>

<p>And if we pass them to the other methods?</p>

<pre><code>let ds = try xs.mymapThrows(double) // No problem
let rs = xs.mymap(reciprocal) 
// Invalid conversion from throwing function of type '(Int) throws -&gt; Double' to non-throwing function type '@noescape Int -&gt; `T'
</code></pre>

<p>So we can pass a non-throwing closure to the throwing <code>map</code>, but not vice versa.
Why? Let&rsquo;s take a step back and talk about subtypes.</p>

<p>A good way to think about types is as a set of promises. In the OOP world, we
create types like this:</p>

<pre><code>class Animal {
  func eat() {...}
}

class Cat : Animal {
  func purr() {...}
}
</code></pre>

<p>Every Animal promises it can eat. Every Cat promises it can purr. Since a Cat is
an Animal, it also promises it can eat. But not every Animal promises to purr
(other Animals <em>may</em> be able to purr, it&rsquo;s just not promised). You&rsquo;re used to
calling Cat a subclass of Animal, and that&rsquo;s true. But it&rsquo;s more generally a
<em>subtype</em>. This idea isn&rsquo;t restricted to classes. After all, the same thing is
true of protocols:</p>

<pre><code>protocol Animal {
  func eat()
}

protocol Cat : Animal {
  func purr()
}
</code></pre>

<p>No classes required. The important thing about the type/subtype relationship is
that a subtype can only <em>add</em> promises. It can never remove promises.
Understanding what promises are being made is very important to understanding
your types.</p>

<p><code>NSArray</code> doesn&rsquo;t promise to be immutable. That may surprise you, but you know
it&rsquo;s true because you copy them when they&rsquo;re passed as parameters. If <code>NSArray</code>
promised to be immutable (like <code>NSDate</code> does), you&rsquo;d never do that. If <code>NSArray</code>
promised to be immutable, then <code>NSMutableArray</code> couldn&rsquo;t be its subclass,
because it breaks that promise.</p>

<p><code>NSArray</code> only promises to be <em>readable</em>. That&rsquo;s a completely different thing.
<code>NSMutableArray</code> <em>also</em> promises to be readable. It keeps the promise <code>NSArray</code>
made. <code>NSMutableArray</code> also promises to be writable, and any subclass of
<code>NSMutableArray</code> would also have to keep that promise.</p>

<blockquote><p>A subtype can only add promises. It can never remove them.</p></blockquote>

<p>So, what promises does <code>(T) throws -&gt; U</code> make? It promises to accept a <code>T</code>. And
it promises that it will either return a <code>U</code> or it will throw an error.</p>

<p>What promises does <code>(T) -&gt; U</code> make? It promises to accept a <code>T</code>. And
it promises that it will return a <code>U</code>.</p>

<p>How are these types related? Which one makes the stronger promise? A good way to
figure this out is to think through some cases.</p>

<ul>
<li>Function returns <code>U</code>. Keeps both promises.</li>
<li>Function throws an error. Keeps one promise, breaks the other.</li>
</ul>


<p>The stronger promise is the one that we broke. It&rsquo;s the non-throwing function
that added a new, stricter promise. &ldquo;I will do X or Y, and furthermore I will
only do X.&rdquo; Doing X keeps that promise. Doing Y breaks it.</p>

<p>So that tells us that a non-throwing closure can be used anywhere a throwing
closure is requested, just like a Cat can be used anywhere an Animal is
requested. No conversions necessary. It&rsquo;s just types.</p>

<p>So great, we have <code>mymapThrows</code>, and it takes either kind, so we&rsquo;re done, right?
Well, we could be, but it&rsquo;d be really annoying. Consider if <code>map</code> were marked
<code>throws</code>. That would mean that <em>every</em> <code>map</code> would have to include a <code>try</code>, and
somewhere you&rsquo;d have to catch the error.</p>

<pre><code>let ds: [Int]
do {
    ds = try xs.map { $0 * 2 }
} catch {
    // Really, Swift? Really? Every time? Even when it can't possibly throw?
    // No, not really. Swift is smarter than that.
}
</code></pre>

<p>There are two ways out of this annoyance. The obvious way is overloading. We can
just have two methods with the same name but different types:</p>

<pre><code>map&lt;T&gt;(@noescape transform: (Generator.Element) throws -&gt; T) throws -&gt; [T]
map&lt;T&gt;(@noescape transform: (Generator.Element) -&gt; T) -&gt; [T]
</code></pre>

<p>Since overloading picks the most specific subtype available, this works fine for
the caller. But it&rsquo;s a serious pain for the dev who has to write <code>map</code>. There&rsquo;s
the obvious annoyance of needing two methods to do the job of one, but it gets
worse if you try to share code between the implementations. You&rsquo;d think you
could just call the throwing version from the non-throwing version like:</p>

<pre><code>func map&lt;T&gt;(@noescape transform: (Generator.Element) -&gt; T) -&gt; [T] {
    return try! self.map(transform as (Generator.Element) throws -&gt; T))
}
</code></pre>

<p>But that runs afoul of <code>@noescape</code>, which doesn&rsquo;t allow the conversion. And even
if that worked (might be a Swift bug), having to use <code>try!</code> all over the place
is crazy, on top of the madness of having two (or three) methods for everything.
My overload implementation looks like this:</p>

<pre><code>extension Array {
    func mymap&lt;T&gt;(@noescape transform: (Generator.Element) throws -&gt; T) throws -&gt; [T] {
        return try self._mymap(transform)
    }

    func mymap&lt;T&gt;(@noescape transform: (Generator.Element) -&gt; T) -&gt; [T] {
        return try! self._mymap(transform)
    }

    func _mymap&lt;T&gt;(@noescape transform: (Generator.Element) throws -&gt; T) throws -&gt; [T] {
        var ts: [T] = []
        for x in self {
            ts.append(try transform(x))
        }
        return ts
    }
}
</code></pre>

<p>If Swift had shipped this way, I suspect the stdlib folks would be having words
with the compiler folks by now. &ldquo;Please come over to my desk. I&rsquo;d like to
introduce you to another kind of throws.&rdquo;</p>

<p>Luckily, Swift is much smarter than that. It&rsquo;s nice that you can overload based
on throwing, but in many cases we have a better tool. We can mark the method
<code>rethrows</code> rather than <code>throws</code>.</p>

<pre><code>func map&lt;T&gt;(@noescape transform: (Generator.Element) throws -&gt; T) rethrows -&gt; [T]
</code></pre>

<p>So what promise does <code>rethrows</code> make? It promises that the only way it will
throw is if a closure it is passed throws. So if it&rsquo;s passed a closure that
can&rsquo;t throw, the compiler knows that the function can&rsquo;t throw either.</p>

<p>(Why isn&rsquo;t stdlib&rsquo;s <code>map</code> marked <code>rethrows</code> today? Because it&rsquo;s beta 1, and the
Swift team hasn&rsquo;t updated all of stdlib yet. They&rsquo;ve indicated that a lot of
stdlib will be fixed in future betas. Have patience.)</p>

<p>It&rsquo;s natural to think of <code>rethrows</code> as a subtype of <code>throws</code>, and non-throwing
closures as a subtype of <code>rethrows</code>, but that doesn&rsquo;t quite seem to be true.
Swift doesn&rsquo;t treat <code>rethrows</code> as a full type. For example, you can&rsquo;t write
overloads with both <code>throws</code> and <code>rethrows</code>, and closures can&rsquo;t include
<code>rethrows</code> in their type. Instead, <code>rethrows</code> acts more like a function
attribute (like <code>@noreturn</code>). It just modifies the rules around what contexts
can call the function. The real types are throwing and non-throwing, and
&ldquo;rethrowing&rdquo; can just morph between the two based on context.</p>

<p>A function that accepts a closure has three throwing options:</p>

<ul>
<li><p>It can throw. That means that the function may throw errors whether or not the
closure throws errors.</p></li>
<li><p>It can rethrow, like <code>map</code>. This means that the function cannot create any
errors of its own, but may propagate errors from the closure it was passed.</p></li>
<li><p>It can not throw. That means that it either handles the errors thrown by the
closure, or it does not evaluate the closure. For example, a setter on a closure
property doesn&rsquo;t throw just because the closure might throw. It just sets the
property and returns.</p></li>
</ul>


<p>Which one you use is completely dependent on your situation. There&rsquo;s no &ldquo;best&rdquo;
answer, though you should generally choose the most restrictive one you can. You
shouldn&rsquo;t just make all your functions <code>throws</code> for the same reasons you
shouldn&rsquo;t make all your variables <code>Any</code>. It&rsquo;s all about choosing the right type.</p>

<p>So when you use the new Swift error handling system, don&rsquo;t think &ldquo;exceptions.&rdquo;
Think types. Your function returns &ldquo;either X or an error.&rdquo; And sometimes, you
can promise it&rsquo;ll only return X.</p>

<p>Throw in peace.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Throw What Don't Throw]]></title>
    <link href="https://robnapier.net/throw-what-dont-throw"/>
    <updated>2015-06-16T20:58:00-04:00</updated>
    <id>https://robnapier.net/throw-what-dont-throw</id>
    <content type="html"><![CDATA[<p>So say you are trying out all this interesting new <code>throw</code> stuff in Swift 2. And
say you&rsquo;re running an early Beta in which many stdlib functions don&rsquo;t handle
throw closures yet. Or maybe you&rsquo;re in the future and dealing with some other
piece of code that you wish could handle a throw closure, but doesn&rsquo;t. What do
you do?</p>

<!-- more -->


<p>By now you may be asking &ldquo;what the heck is a throw closure? Talk sense, man!&rdquo;
Let&rsquo;s take a small step back and quickly introduce the new <code>throws</code> feature.
That&rsquo;s not the point of this article, though. You should go watch the WWDC
videos. But basically, it&rsquo;s like this. Say you have a function that might fail.
In Swift 2, you can write it this way:</p>

<pre><code>enum Error: ErrorType { case Negative }

let f: (Int) throws -&gt; String = {
    guard $0 &gt;= 0 else { throw Error.Negative }
    return "".join(Repeat(count: $0, repeatedValue: "X"))
}
</code></pre>

<p>First, the <code>throws</code> in the signature tells us that this function may throw.
Functions may not throw errors unless they explicitly indicate that they can.</p>

<p>You might think of &ldquo;throwing errors&rdquo; as equivalent to &ldquo;exceptions&rdquo; in languages
you&rsquo;re familiar with, but it&rsquo;s a little different. A throw is really just a
fancy return. A throwing function can return <em>either</em> a type or an <code>ErrorType</code>.
And &ldquo;throws&rdquo; is probably best thought of as somewhat opaque sugar around an
Either type.</p>

<p>That tells us something very important:</p>

<blockquote><p>A function that throws errors is a different <em>type</em> than one that doesn&rsquo;t.</p></blockquote>

<p>I don&rsquo;t mean that it&rsquo;s &ldquo;some other kind of thing.&rdquo; I mean like <code>Int</code> is a
different type than <code>String</code>, and <code>String</code> is a different type than <code>(Int) -&gt;
String</code>, <code>(Int) -&gt; String</code> is a different type than <code>(Int) throws -&gt; String</code>. In
fact, <code>(Int) -&gt; String</code> is a <em>subtype</em> of <code>(Int) throws -&gt; String</code>, which is
pretty awesome and a little subtle, but we&rsquo;ll get to that in another post.</p>

<p>So what does that mean? Let&rsquo;s think of a simple case of map today (Swift 2 Beta
1):</p>

<pre><code>print([1,2,3].map(f)) // Cannot invoke 'map' with an argument list of type '((Int) throws -&gt; String)'
</code></pre>

<p>What&rsquo;s going on here? Let&rsquo;s look at the type signature:</p>

<pre><code>func map&lt;T&gt;(@noescape transform: (Self.Generator.Element) -&gt; T) -&gt; [T]
</code></pre>

<p>So <code>transform</code> is of type <code>(Element) -&gt; T</code>. We&rsquo;re passing <code>(Element) throws -&gt;
T</code>. Remember I said that a non-throwing function is a subtype of a throwing
function. So <code>(Element) throws -&gt; T</code> is a <em>supertype</em> of what what this function
wants. That&rsquo;s like passing NSObject to something that wants UIView. You can&rsquo;t do
that.</p>

<p>So what do we do? Well for map, this is easy. We can just implement our own throwing version:</p>

<pre><code>extension Array {
    func map&lt;T&gt;(@noescape transform: (Generator.Element) throws -&gt; T) rethrows -&gt; [T] {
        var result: [T] = []
        for x in self {
            result.append(try transform(x))
        }
        return result
    }
}
</code></pre>

<p>And now we can use it:</p>

<pre><code>print(try [1,2,3].map(f))
</code></pre>

<p>Notice the use of <code>try</code>. This is pretty different than how <code>try</code> is used in
other langauges, and another way that Swift&rsquo;s error handling doesn&rsquo;t quite match
&ldquo;exceptions.&rdquo; Swift uses <code>try</code> to remind the programmer about functions that
may throw errors. The compiler doesn&rsquo;t need <code>try</code>. It doesn&rsquo;t create scope, or
mark control flow points, or anything like that. It&rsquo;s not a function or a
constructor. It&rsquo;s just a keyword that Swift forces you to include so that <em>you</em>
(and your coworkers) remember what&rsquo;s going on. When you see <code>try</code>, you should
think &ldquo;hey, control could suddenly jump somewhere else from this point.&rdquo; It
reduces surprise when that happens, and conversely tells you where control
<em>can&rsquo;t</em> suddenly jump (i.e. everywhere without <code>try</code>). I think that&rsquo;s pretty
nice.</p>

<p>You may also notice both <code>throws</code> and <code>rethrows</code> in the method signature. I&rsquo;ll
get to that in a later blog post. Just trust me for now. This code would also
work if you used <code>throws</code> in both places, but this is the better signature.</p>

<p>And one more &ldquo;also notice.&rdquo; Also notice that this is an <em>overload</em> of map. The
closures have different types, so the compiler can pick the right one. Nice.</p>

<p>OK, that was a lot of setup, and you could probably figure out on your own how
to rewrite map this way. And besides, by beta 2, I&rsquo;m sure there will be a
proper (re)throwing version of map. So why bother? For the next step.</p>

<p>I know how map is implemented. It&rsquo;s really simple. But what if I <em>didn&rsquo;t</em> know
how it was implemented? How about some function that I&rsquo;m not sure I could write
correctly? How about a more obscure function that may not get throwing love
quite so quickly? How about <code>Array.withUnsafeBufferPointer</code>? Ooohhh&hellip;.</p>

<p>So here&rsquo;s our signature:</p>

<pre><code>func withUnsafeBufferPointer&lt;R&gt;(@noescape body: (UnsafeBufferPointer&lt;T&gt;) -&gt; R) -&gt; R
</code></pre>

<p>We want to accept a <code>body</code> that can throw, but we want to pass it to the
existing method, which can&rsquo;t accept a throwing closure. So what do we do? We go
back to our old friend, Result. Here&rsquo;s a super-simple Result implementation that
can convert to and from throwing closures:</p>

<pre><code>enum Result&lt;T&gt; {
    case Success(T)
    case Failure(ErrorType)

    func value() throws -&gt; T {
        switch self {
        case .Success(let value): return value
        case .Failure(let err): throw err
        }
    }

    init(@noescape f: () throws -&gt; T) {
        do    { self = .Success(try f()) }
        catch { self = .Failure(error) }
    }
}
</code></pre>

<p>If you&rsquo;re familiar with Result or Either, this should be pretty self-evident,
but the key pieces are that <code>result.value()</code> will unwrap the result into either
a value or a thrown error. And <code>init</code> will take a throwing closure and convert
it into a Result. With that piece, here&rsquo;s how we build our method:</p>

<pre><code>extension Array {
    func withUnsafeBufferPointer&lt;R&gt;(@noescape body: (UnsafeBufferPointer&lt;T&gt;) throws -&gt; R) throws -&gt; R {
        return try self.withUnsafeBufferPointer { buf in
            return Result{ try body(buf) }
            }.value()
    }
}
</code></pre>

<p>The closure <code>body</code> is of type <code>(UnsafeBufferPointer&lt;T&gt;) throws -&gt; R</code>, which we
can&rsquo;t pass to <code>withUnsafeBufferPointer</code>. But <em>our</em> closure is of type
<code>(UnsafeBufferPointer&lt;T&gt;) -&gt; Result&lt;R&gt;</code>, which is just fine (no throws here,
move along).</p>

<p>Let&rsquo;s walk through the closure from the inside out.</p>

<ol>
<li><code>try body(buf)</code>. Execute our throwing closure using the <code>buf</code> provided to us by the default implementation.</li>
<li><code>Result{...}</code>. Capture it into a Result enum</li>
<li><code>return Result{...}</code>. Return the Result, not the underlying value.</li>
<li>The whole function nows looks like <code>return try result.value()</code></li>
<li>This either returns the computed value (type <code>R</code>), or throws</li>
</ol>


<p>This method is marked <code>throws</code> rather than <code>rethrows</code> because &hellip; reasons. (The
final throw doesn&rsquo;t come directly from <code>body</code>, but from <code>value()</code>. That&rsquo;ll
hopefully make more sense when I explain <code>rethrows</code>.)</p>

<p>And just for completeness (and because I needed it myself), we can do the same
thing to <code>withUnsafeMutableBufferPointer</code>, but we need to give the compiler more
type information because of the <code>inout</code> parameter:</p>

<pre><code>extension Array {
    mutating func withUnsafeMutableBufferPointer&lt;R&gt;(@noescape body: (inout UnsafeMutableBufferPointer&lt;T&gt;) throws -&gt; R) throws-&gt; R {
        return try self.withUnsafeMutableBufferPointer { (inout buf: UnsafeMutableBufferPointer&lt;T&gt;) in
            return Result{try body(&amp;buf)}}.value()
    }
}
</code></pre>

<p>These particular implementations probably won&rsquo;t be useful for long. I&rsquo;m sure the
stdlib team will quickly clean this up (and you probably shouldn&rsquo;t be using
<code>withUnsafeBufferPointer</code> very much anyway). But hopefully exploring how this
works can give some insight into Swift&rsquo;s new error handling system. Result isn&rsquo;t
dead; it still has interesting use cases like this one. But I expect those use
cases to shrink, and I highly recommend exploring the new error handling and
discover how to build great things with it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[I, for One, Welcome Our New Haskell Overlords]]></title>
    <link href="https://robnapier.net/haskell-overlords"/>
    <updated>2014-09-29T10:57:00-04:00</updated>
    <id>https://robnapier.net/haskell-overlords</id>
    <content type="html"><![CDATA[<p><a href="https://twitter.com/TacticalGrace/status/506079987565613056">Manuel Chakravarty</a> made a comment a few weeks ago:</p>

<blockquote><p>By not using standard FP terminology in emerging languages like Swift, we deny learners access to a lot of existing literature.</p></blockquote>

<p>I certainly agree. But there&rsquo;s a lot more to it, and I hope the functional programming community will get involved in new ways. We&rsquo;ll get there. First, a little history for the rest of us. FP folks, I&rsquo;ll get back to you in a couple of sections.</p>

<!-- more -->


<h2>Objective History</h2>

<p>I remember when OOP became a thing in the 90s. I&rsquo;d been a professional developer for about a decade at that point, shipping products in QuickBASIC, FoxPro, dBase, C, and SL-1 (a phone switching language so obscure it doesn&rsquo;t even have a Wikipedia page). I&rsquo;d done hobby work in Pascal, various kinds of assembler, and even Lisp. But the closest I came to OOP were some toy projects in Borland&rsquo;s Object Windows Library for Turbo Pascal.</p>

<p>This isn&rsquo;t to brag about my old-school hipsterness. If you know me, you know I don&rsquo;t have much of that. My point is that it wasn&rsquo;t so long ago that you could do a lot of professional work and never talk about objects, classes, properties, methods, or any other OOPishnesses.</p>

<p>Then suddenly, Java, and good grief, how could you possibly be a real programmer if you couldn&rsquo;t abstract factory your instance interface? Java didn&rsquo;t invent OOP. Far from it. But suddenly OOP seriously mattered.</p>

<blockquote><p>First they ignore you, then they laugh at you, then they fight you, then you win. &ndash; Mahatma Gandhi</p></blockquote>

<p>I remember vividly people laughing at OOP. It was too academic. Too abstract. Too bloated. Too slow. Too confusing. But here we are, maybe 15 years later, and OOP is just how most programming is done.</p>

<p>Don&rsquo;t get me wrong. Most developers do OOP terribly. Really, really terribly. They keep making horrible design mistakes that we&rsquo;ve known for decades are horrible design mistakes. But OOP is how you do things. It&rsquo;s the paradigm in which terrible choices are made today. And good choices too. It&rsquo;s just how things are done. It wasn&rsquo;t always that way.</p>

<h2>Rise of the Lambdas</h2>

<p><span class='pullquote-right' data-pullquote='A paradigm is sneaking in when you aren&#8217;t paying attention. Pay attention.'></p>

<p>When I look around at FP today, I see OOP in the 90s. FP keeps creeping into languages. Python, Ruby, JavaScript, C#, Java. They didn&rsquo;t start out intentionally functional, but they keep picking up functional features. New languages like Swift and Rust self-consciously flirt with functional programming, even if they won&rsquo;t quite commit to it. Microsoft is pushing F#. Twitter is working in Scala. FP is becoming part of the landscape. Words like <em>closure</em> and <em>comprehension</em> are invading the vocabulary of professional developers. This has all happened before. This will all happen again. A paradigm is sneaking in when you aren&rsquo;t paying attention. Pay attention. There&rsquo;s a chance here to influence development practice for decades, for good or ill.</p>

<p></span></p>

<h2>Please Don&rsquo;t Applicative Functor the Semi-Group</h2>

<p><strong>What&rsquo;s a biscuit joiner?</strong> It&rsquo;s a machine for generating half of a negative ovaloid prism.</p>

<p><strong>What&rsquo;s a monad?</strong> It&rsquo;s an endofunctor with two natural transformations satisfying associativity and identity.</p>

<p>Let&rsquo;s try that again&hellip;.</p>

<p><strong> What&rsquo;s a biscuit joiner?</strong> It&rsquo;s a tool for cutting slots in the edges of boards. You put a little piece of wood in there that sticks out as a tab (called a &ldquo;biscuit&rdquo;) so you can glue panels together, like for a tabletop or door.</p>

<p><strong>What&rsquo;s a monad?</strong> It&rsquo;s a result in a box. You can use them to chain together operations that might fail, or might happen in the future, or otherwise have some &ldquo;context&rdquo; around them that you want to pass along with the result itself. A Swift optional is one kind of monad, where the &ldquo;context&rdquo; is whether it actually has a value or not.</p>

<p>None of the definitions above are complete or fully correct. But the last two are <em>useful</em> for people likely to be asking. After reading the second definition of a biscuit joiner, I wouldn&rsquo;t expect you to be able to even recognize one, let alone use it safely, but you&rsquo;d at least know when you might want to find out more about it.</p>

<p><span class='pullquote-right' data-pullquote='We don&#8217;t need to be afraid of metaphor, even slightly strained metaphor.'></p>

<p>The same is true for how we introduce FP concepts. We don&rsquo;t need to be afraid of metaphor, even slightly strained metaphor. I&rsquo;m looking to people more expert than I am for better metaphors, better starting points. Maybe my monad intro could be improved. I&rsquo;m aware that it doesn&rsquo;t perfectly explain why lists are also monads. But starting the discussion with monoids and the monadic laws closes the conversation. It says this is something unrelated to shipping products. It shouldn&rsquo;t be in the first paragraph, let alone the first sentence. It&rsquo;s better to start a bit wrong and build on that, than to start more correct (but still a little wrong) and make an important tool seem irrelevant.</p>

<p></span></p>

<p>I&rsquo;m not saying we shouldn&rsquo;t use FP terms, even opaque terms of art from category theory. I agree with what Manuel was saying at the start of this. We should call a monad a monad. We should even probably call a functor a functor (though I have a fondness for &ldquo;mappable&rdquo;). I&rsquo;m just saying we should introduce them in ways that engage the goal, which is great shipping software, not proofs for their own sake.</p>

<p>There is so much we can use well without fully understanding. Carpenters do not have to learn plant biology, let alone the subatomic nature of matter, before they can learn to work with and against the grain. I&rsquo;d rather a great carpenter build my house than a great materials scientist. To ship great products, I want a programmer, not a mathematician.</p>

<p>I want more people turning FP concepts into JSON parsers tied to REST clients with local databases and UI animations built on popular frameworks. We need FP experts engaging with the existing platforms, not trying to replace them with Haskell. <a href="http://robots.thoughtbot.com/ship-you-a-haskell">Ship you a Haskell</a> is a great article, but most of us work on platforms for which shipping is assumed, not news. &ldquo;Employs total referential transparency&rdquo; isn&rsquo;t particularly useful for my AppStore blurb if the program is late and the animations are glitchy. FP is a means to an end for most projects, not the end itself.</p>

<p>To those of you who don&rsquo;t know Haskell, I&rsquo;m still telling you to go learn it. It&rsquo;s worth it. I just noticed that Apple&rsquo;s job descriptions for the Foundation team include &ldquo;Knowledge of Haskell, Rust, F#, or similar languages will be useful.&rdquo; But things that make sense in Haskell don&rsquo;t make sense everywhere. Haskell is just a language. Ubiquitous laziness and currying were choices of one language, not the one true functional way. They introduce tradeoffs.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> Languages that chose other tradeoffs need their own functional idioms. We shouldn&rsquo;t write JavaScript in Swift (seriously, stop it), or Haskell in Swift, or ML in Swift, or even Objective-C in Swift. We must find our way to write great Swift on its own terms. We should learn from our ancestors, not just relive their lives.</p>

<h2>Swift is a Special Flower</h2>

<p>Every so often there are special opportunities. Swift represents a real chance to advance the state of common practice in our industry. <a href="https://robnapier.net/swift-is-not-functional">Swift isn&rsquo;t functional</a>, but it has a lot of very interesting pieces available. And Swift will be extremely popular, by luck of birth as much as anything. I don&rsquo;t mean to disparage the Swift dev team. They&rsquo;ve done an admirable job. But if Swift weren&rsquo;t the language of iOS development, it would likely be a pretty minor thing. But since it&rsquo;s the favored language of an incredibly popular platform, and since it <em>does</em> have functional leanings, and frankly it&rsquo;s a pretty nice language to work in, it represents an incredible opportunity to positively impact a whole discipline.</p>

<p>To make the most of that opportunity takes live code in non-trivial apps, not just playing around with data structures and algorithms. Many of my code examples come out of a small <a href="https://github.com/rnapier/WikipediaSearcher">Wikipedia front-end</a> I play with to see how these things might work in practice. I try to solve problems in a real (if small) iOS app and see where it takes me.<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> This is the approach I recommend for any would-be FP evangelist. Build a real program with a real UI before forming too strong an opinion of what FP should look like in Swift. Engage with stdlib and Cocoa (and GCD, and Core Animation, and&hellip;), don&rsquo;t try to replace them. Don&rsquo;t assume stdlib is the way it is out of ignorance. Yes, it&rsquo;s backwards from Haskell. Yes, that makes certain kinds of composition really annoying. Maybe that just means those kinds of composition aren&rsquo;t going to be good Swift.</p>

<p><span class='pullquote-right' data-pullquote='good functional approaches may look different from language to language'></p>

<p>This doesn&rsquo;t stop Swift from enjoying great value from functional approaches. But it does mean that good functional approaches may look different from language to language, just like good OOP looks different from language to language. Haskell doesn&rsquo;t look like Lisp. Why should we expect Swift to look like Haskell?</p>

<p></span></p>

<p>Swift is like Scala. It consciously straddles two worlds. I think this should be celebrated. It means compromise, but I think it also means more users will get better software than if there were only &ldquo;good languages&rdquo; and &ldquo;shipping languages.&rdquo; We really can have languages that give the benefits of tomorrow without losing all the working components of today. I think Swift can be one of those languages.</p>

<h2>The ties that >>=</h2>

<p>I&rsquo;m looking for help. I&rsquo;m looking for FP veterans to bring what they&rsquo;ve learned elsewhere, mix it with the experience of long-time Cocoa devs, and build a great foundation for Swift, maybe even nudge Apple in the process.</p>

<p>Much of that, I believe, is education. I have an <a href="https://robnapier.net/categories/functional">ongoing series here</a>. I&rsquo;d love to learn to teach it more effectively.</p>

<p>It&rsquo;s also about good tools. The tools we use shape our thinking. I want it to be as easy as possible to write great code, and Swift has a few glaring omissions. To that end, I started a project called <a href="https://github.com/llamakit/llamakit">LlamaKit</a>, aimed at providing a small set of important tools that are easy to integrate into existing projects and should be nearly universally useful. There are much more full-lambda projects out there, particularly <a href="https://github.com/typelift">TypeLift</a>. LlamaKit isn&rsquo;t trying to fill that whole need, just provide the bare minimum to make functional programming approachable in Swift for common Cocoa problems, provide a foundation for more powerful frameworks, and help those frameworks interoperate more easily than they can today. I welcome input on the <a href="https://groups.google.com/forum/#!forum/llamakit">mailing list</a>. It&rsquo;s still early days for LlamaKit, but I think it will stabilize into something useful very soon.</p>

<h2>A slight nervousness around eagles</h2>

<p>Occasionally, in my more self-aggrandizing moments, I fear I am Prometheus, stealing referential transparency from the gods to bring back to poor mortals trapped in their mutating loops. And I remember what came of Prometheus.</p>

<p>Then I remember I&rsquo;m just a code monkey deep down, and it&rsquo;s all just code after all. I notice the paradigm is shifting. Seems a pretty nice time to light a fire.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Swift&rsquo;s initial attempt at making things lazy by default was a disaster IMO. I&rsquo;m glad they abandoned that. It just didn&rsquo;t work with the rest of Cocoa.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>I also apply some of these things to larger, more production apps, but I have to be more careful and don&rsquo;t have the time or risk tolerance to experiment as much. That&rsquo;s why I like having a non-trivial toy app.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go Is a Shop-built Jig]]></title>
    <link href="https://robnapier.net/go-is-a-shop-built-jig"/>
    <updated>2014-09-17T15:50:00-04:00</updated>
    <id>https://robnapier.net/go-is-a-shop-built-jig</id>
    <content type="html"><![CDATA[<p><a href="https://al3x.net/about.html">Alex Payne</a> wrote an excellent essay called <a href="https://al3x.net/2014/09/16/thoughts-on-five-years-of-emerging-languages.html">Thoughts on Five Years of Emerging Languages</a>. It called to mind something I wrote a while ago for a limited audience that I never got around to turning into a public form. Thanks to <a href="https://twitter.com/TacticalGrace">Manuel Chakravarty</a> for the link and the inspiration.</p>

<p>For those who read my blog for Cocoa (and recently Swift) discussion, you may be surprised that most of my professional work right now is in Go, C, and C++ (in that order). So I thought I might take a moment to discuss Go.</p>

<p>First, it&rsquo;s important to say that I really like Go. I didn&rsquo;t think I would. I&rsquo;m a language snob at heart. Before Swift, I&rsquo;d been spending a lot of time on the <a href="http://learnyouahaskell.com">functional</a> side of the <a href="http://www.scala-lang.org">street</a> with a brief dallience with <a href="http://akka.io">actors</a>. I was just about to do deeper <a href="http://clojure.org">into the parens</a>, when I wound up taking a side trip into Google-land and Go. I&rsquo;d dipped my toe into the water once before and been turned off by what seemed to be the sloppiness of the language. How variables are declared bugged me (turns out it <a href="http://gophercon.sourcegraph.com/post/83845316771/panel-discussion-with-go-team-members">bugs the lead language designer</a>, too). The multiple return types of <code>range</code> bugged me. <a href="http://blog.golang.org/strings">Strings switching between code points and bytes</a> bugged me. The fact that Go can&rsquo;t implement its own <code>append()</code> harkened back to funky Perl magic. Go just seemed sloppy and under-considered.</p>

<!-- more --> 


<p>But a coworker made a joke about rewriting an important service in Go, and after laughing about it, I thought I&rsquo;d at least take another look. It turned out to be a great fit. Go&rsquo;s bread-and-butter is concurrent network services, which is what we wanted to solve. So I dug a bit more.</p>

<ul>
<li>Very cross-platform out of the box.

<ul>
<li>Not &ldquo;sort-of cross-platform as long as it&rsquo;s unix&rdquo; like C/C++. Real-world Windows support is pretty good. No wchar/tchar/char madness.</li>
</ul>
</li>
<li>Built-in cross-platform networking support that integrates with the native stack.</li>
<li>Native binaries. No need to ship a separate interpreter, runtime, or VM.</li>
<li>Handles concurrency very well.</li>
<li>Pretty easy to pick up for C programmers</li>
</ul>


<p>It was a good fit. I went ahead and reworked the system in Go. I&rsquo;ve been very happy with the results so far.</p>

<p><span class='pullquote-right' data-pullquote='Go feels under-engineered because it only solves real problems.'></p>

<p>So what have I learned by actually building something? Go feels under-engineered because it only solves real problems. If you&rsquo;ve ever worked in a wood shop, you&rsquo;ve probably made a jig at some point. They&rsquo;re little pieces of wood that help you hold plywood while you cut it, or spacers that tell you where to put the guide bar for a specific tool, or hold-downs that keep a board in place while you&rsquo;re working on it. They&rsquo;re not always pretty. They often solve hyper-specific problems and work only with your specific tools. And when you look at ones that have been used a lot, they sometimes seem a little weird. There might be a random cutout in the middle. Or some little piece that sticks off at an angle. Or the corner might be missing a piece. And when you compare them to &ldquo;real&rdquo; tools, &ldquo;general&rdquo; tools like you&rsquo;d buy from a catalog, they&rsquo;re pretty homey or homely depending on how you&rsquo;re thinking about it.</p>

<p></span></p>

<p>But when you use one of them in your shop, you learn that the random cutout is because you store it against the wall and it would block the light switch otherwise. And if you put your hand on that little extra piece that sticks out, then the board won&rsquo;t fall at the end of the cut. And the corner… well the corner is where you messed up when you were first making it and it&rsquo;s kind of ugly, but it never actually matters when you use it. And that&rsquo;s Go. Not a single thing I mentioned in the first paragraph has actually come up as a problem. Its really good at solving the problems that it solves, which happen to be very common problems for people who need to ship software, especially networking software.</p>

<p>Probably the biggest complaint people have with Go is the lack of generics. And I did run into that in just the first couple of weeks of work on my project, and I wound up with a bunch of duplicated code to work around it. And then, when it was all working, I refactored out the duplicated code. And I refactored again. And in the end, the whole thing was simpler and shorter than what I would have done with generics. So again, in the end, Go turned out to be a language for solving real problems rather than a language filled with beautiful tools, and so you build real solutions rather than finding excuses to use your beautiful tools. Don&rsquo;t try to make Go what it isn&rsquo;t. If you&rsquo;re trying to solve abstract CS problems in their most generalized forms, then you may find it frustrating. But if you&rsquo;re trying to solve specific, practical problems in the forms professional developers typically encounter, Go is quite nice.</p>

<p>I recently wrote some Go code that looked basically like this:</p>

<pre><code>func (f *Frobulator) frobulate() error {
  if f.thingsToFrobulate &gt; 0 {
    var err error

    if err = logit(FrobulatingMessage); err != nil {
      return err
    }

    if err = f.cleanupOldest(); err != nil {
      return err
    }

    var youngest Frobable
    if youngest, err = f.processOld(); err != nil {
      return err
    }

    if err = f.doNewThing(youngest); err != nil {
      return err
    }
  }

  return f.cleanup()
}
</code></pre>

<p>There&rsquo;s a lot of boilerplate duplication there with some &ldquo;almost the same, but kinda different&rdquo; stuff in the middle that feels awkward.</p>

<p>If I were writing this in Swift with my <a href="https://github.com/LlamaKit/LlamaKit">LlamaKit</a> bells-and-functional-whistles, I might write it as:</p>

<pre><code>func frobulate() -&gt; Result&lt;Void&gt; {
  var result = success(())
  if self.thingsToFrobulate &gt; 0 {
    result = logit(FrobulatingMessage)
      &gt;&gt;== self.cleanupOldest
      &gt;&gt;== self.processOld
      &gt;&gt;== self.doNewThing
  }
  return result &gt;&gt;== self.cleanup
}
</code></pre>

<p>The Swift+LlamaKit version is half as long, and almost every line is focused on the task at hand. It feels much more elegant. There is far less duplication. But there&rsquo;s a pretty big story in how these two functions were written.</p>

<p>When writing the Swift function, I found myself spending a lot of time thinking about how to write it. Should I use <code>&gt;&gt;==</code> or <code>.flatMap()</code>? Should I use my custom <code>Result</code> here at all, or should I stick to standard Swift and return <code>NSError?</code>, or maybe <code>Bool</code> with an <code>NSErrorPtr</code>? This was my first time using <code>Result&lt;Void&gt;</code>, and I started asking myself if I should create a typealias for that and maybe a helper function for the slightly strange looking <code>success(())</code>. The <code>var</code> bothered me. It always feels like a hack in FP, like you&rsquo;re not smart enough to do it right. I wrote a different version that didn&rsquo;t have a <code>var</code>. That duplicated <code>self.cleanup</code> in two places. So I started working on a new function that would let me include the conditional in the functional composition. I made and re-made a lot of choices. <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p><span class='pullquote-right' data-pullquote='When writing the Go function, I started at the top and typed until I got to the bottom.'></p>

<p>When writing the Go function, I started at the top and typed until I got to the bottom. And that was it. There aren&rsquo;t very many ways to write this function in Go. I expect that most Go programmers, given the same set of helper functions, would have written it almost identically. Because of gofmt, I don&rsquo;t even make formatting decisions.</p>

<p></span></p>

<p>I could probably spend another hour polishing my dozen-line Swift function and building generic tools to make it easier in the future for people (at least those who use my toolkits) to write this kind of code beautifully.</p>

<p>Or I could write it in Go in about 2 minutes and move onto fixing the next bug in the backlog.</p>

<p>I admit, I would rather spend my time writing generic, elegant functions that help developers think deeply and correctly about their programs. Like Alex, falling back on for-loops and mutable state makes me feel like a bad programmer. But there is a certain tension between all that and shipping things today.</p>

<p>Did I mention Go compiles <em>really fast</em>?</p>

<p>But late at night, when it&rsquo;s my own time for my own projects, it&rsquo;s Swift I&rsquo;d rather work in.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>The underlying issue here isn&rsquo;t that I chose to use special operators out of LlamaKit. I could have written the Swift code in <a href="https://gist.github.com/rnapier/27ba98c827c9d7798879">the same style as the Go code</a> or in <a href="https://gist.github.com/rnapier/4a48b24024ff969f2e94">traditional ObjC style</a>. The point is that there are lots of ways you could do it, and lots of ways different Swift developers will <em>choose</em> to do it because the language is very flexible and there is no obvious &ldquo;Swift way.&rdquo;<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reduction in Force]]></title>
    <link href="https://robnapier.net/reduction-in-force"/>
    <updated>2014-09-14T20:14:00-04:00</updated>
    <id>https://robnapier.net/reduction-in-force</id>
    <content type="html"><![CDATA[<p>Our last <a href="https://robnapier.net/flatmap">talk about >>==</a> was full of twists and turns, some
philosophy, surprising connections, and a radical new operator. It was a lot to
absorb, and you may have to play with it some in your own code before you really
know what it&rsquo;s about. That&rsquo;s ok.</p>

<p>Let&rsquo;s take a little break and talk about a handy functional tool built into
Swift stdlib. I promise no big reveals, no new operators, no fancy types; just
hands-on, practical discussion of the Swiss Army knife of transform functions:
<code>reduce</code>.</p>

<!-- more -->


<p>Reducing is almost easier to show than to explain. Let&rsquo;s start with a trivial
example. You have an array of numbers and you want to know the sum. We might say
you want to &ldquo;reduce&rdquo; a <code>[Int]</code> to a single <code>Int</code>. <code>reduce</code> takes a sequence, an
intial value, and a &ldquo;combining&rdquo; function like this:</p>

<pre><code>let xs = [1,2,3,4,5]
let sum = reduce(xs, 0) { accumulator, value in accumulator + value }
// ==&gt; 15
</code></pre>

<p>The most interesting part is the combining function. It is passed a &ldquo;value so
far&rdquo; and a &ldquo;next value from the list&rdquo; and it needs to return the result of
combining them. Its signature looks like this:</p>

<pre><code>(U, T) -&gt; U
</code></pre>

<p>So it doesn&rsquo;t have to return the same kind of thing as is in the list, but it
often does. In our example, since we want the sum, we just add the two values.
We could just as easily reduce the list to its product:</p>

<pre><code>let product = reduce(xs, 1) { accumulator, value in accumulator * value }
// ==&gt; 120
</code></pre>

<p>I&rsquo;m spelling out parameters to make it clear exactly what is being passed to
the combining function, but we can of course use Swift shortcuts for this:</p>

<pre><code>let sum = reduce(xs, 0) { $0 + $1 }
</code></pre>

<p>Or we can go futher, and shorten it to:</p>

<pre><code>let sum = reduce(xs, 0, +)
</code></pre>

<p>What&rsquo;s up with that? <a href="https://robnapier.net/flatmap">I told you before</a>, <code>+</code> is just a function:</p>

<pre><code>func +(lhs: Float, rhs: Float) -&gt; Float
</code></pre>

<p>And it&rsquo;s in the form <code>(T, T) -&gt; T</code>, which is just a special case of <code>(U, T) -&gt;
U</code>. So that&rsquo;s fine, and we can pass it as the combining function.</p>

<p>There&rsquo;s also a method form that can be convenient:</p>

<pre><code>let sum = xs.reduce(0, combine: +)
</code></pre>

<p>We can think of that as &ldquo;take the list of x values, and add them, starting with
zero.&rdquo;</p>

<h3>A note on origami and names</h3>

<p>Another common name for this function is &ldquo;fold.&rdquo; Sometimes, in other languages,
you&rsquo;ll see &ldquo;fold left&rdquo; or &ldquo;fold right.&rdquo; Swift&rsquo;s &ldquo;reduce&rdquo; is the same as &ldquo;fold
left.&rdquo; <strike>(A right fold starts at the end of the list and goes
backwards.</strike><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>) You may also see it called &ldquo;aggregate&rdquo; or
&ldquo;accumulate&rdquo; or &ldquo;inject.&rdquo; They&rsquo;re all pretty much the same function.</p>

<h2>Finding a starting point</h2>

<p>OK, so we can add and multiply stuff. What else you got? We can get minimums and
maximums. Let&rsquo;s implement stdlib&rsquo;s <code>minElement</code> for arrays with
<code>reduce</code>.<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>

<p>Reducing requires an initial value. So, what should it be? For types that have a
known minimum (like <code>Int.min</code>), you might be tempted to use it. But that&rsquo;s not
very flexible, and some orderable types don&rsquo;t have an obvious minimum. For
example, what if we implemened a <code>BigNum</code> type that supported arbitrarily large
or small values?</p>

<p>A common solution is to treat the first element as the initial value, and then
reduce the rest:</p>

<pre><code>func minElement&lt;T: Comparable&gt;(xs: [T]) -&gt; T {
  return dropFirst(xs).reduce(xs[0], combine: min)
}
</code></pre>

<p>That&rsquo;s a reusable pattern, so we could, if we wanted to, extract it:</p>

<pre><code>extension Array {
  func reduce1(combine: (T, T) -&gt; T) -&gt; T {
    return dropFirst(self).reduce(self[0], combine: combine)
  }
}

func minElement&lt;T: Comparable&gt;(xs: [T]) -&gt; T {
  return xs.reduce1(min)
}
</code></pre>

<p>Notice that <code>reduce1</code> requires a combining function that takes and returns the
same type. It&rsquo;s worth taking a moment and thinking about why that has to be
true.</p>

<p>Of course, <code>reduce1</code> crashes if the array is empty. What if we wanted to get
back an <code>Int?</code> to guard against that? Here&rsquo;s one way we could do it:</p>

<pre><code>func safeMinElement&lt;T: Comparable&gt;(xs: [T]) -&gt; T? {
  return xs.reduce(nil) { m, x in min(m ?? x, x) }
}
</code></pre>

<p>So we start with <code>nil</code>, and for each element if the current minimum is <code>nil</code>, we
take whatever was passed in, and otherwise we take the minimum. Notice how we
rely on Swift&rsquo;s habit of promiting anything into an optional when required.
Let&rsquo;s us be pretty <strike>sloppy</strike> expressive.</p>

<h2>Beyond math</h2>

<p>The combining function <code>(U, T) -&gt; U</code> says nothing about numbers. We can reduce
anything we can imagine. We could join strings just as easily.</p>

<pre><code>func join(elements: [String]) -&gt; String {
  return elements.reduce("", +)
}
</code></pre>

<p>Or, <a href="https://robnapier.net/flatmap#fn:1">as promised</a>, here&rsquo;s <code>flatten</code>, which takes a nested array
and removes one level of structure:</p>

<pre><code>func flatten&lt;T&gt;(xs: [[T]]) -&gt; [T] {
  return xs.reduce([], +)
}
</code></pre>

<p>Told you it was simple. Notice how summing numbers, joining strings, and
flattening arrays all have the same implementation, differing only in their
initial value? That&rsquo;s another thing worth thinking about for a while, but it&rsquo;s
too much theory for this post. (If you want to research it, the magic search
term you want is <em>monoid</em>.)</p>

<p>Mapping an array is just a special case of reducing:<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p>

<pre><code>func map&lt;T, U&gt;(xs: [T], f: T -&gt; U) -&gt; [U] {
  return xs.reduce([]) { $0 + [f($1)] }
}
</code></pre>

<p>So is filtering:</p>

<pre><code>func filter&lt;T&gt;(xs: [T], includeElement: T -&gt; Bool) -&gt; [T] {
  return xs.reduce([]) { filtered, x in includeElement(x) ? filtered + [x] : filtered }
}
</code></pre>

<p>FlatMap:</p>

<pre><code>func flatMap&lt;T, U&gt;(xs: [T], f: T -&gt; [U]) -&gt; [U] {
  return xs.reduce([]) { $0 + f($1) }
}
</code></pre>

<p>Reverse:</p>

<pre><code>func reverse&lt;T&gt;(xs: [T]) -&gt; [T] {
  return reduce(xs, []) { [$1] + $0 }
}
</code></pre>

<p>Even counting!</p>

<pre><code>func countElements&lt;T&gt;(xs: [T]) -&gt; Int {
  return reduce(xs, 0) { c, _ in c + 1 }
}
</code></pre>

<p>You can do a lot of stuff this way. It&rsquo;s particularly useful when you find
yourself declaring a <code>var</code> just so you can initialize it with a loop. Any time
you find yourself using <code>var</code> inside a function, consider whether this is better
done with something else (<code>map</code>, <code>filter</code>, <code>reduce</code>, etc). Usually the answer is
yes.</p>

<h2>From whence would you return?</h2>

<p>How about <code>contains</code>?</p>

<pre><code>func contains&lt;T: Equatable&gt;(xs: [T], find: T) -&gt; Bool {
  return xs.reduce(false) { found, x in found || find == x }
}
</code></pre>

<p>Hmmm&hellip;. It works, but it&rsquo;s a poor choice in my opinion. <code>reduce</code> computes over
the full list, so this is wasting a lot of effort checking values that aren&rsquo;t
needed. A good way to think about it is how you would expect this function to
behave if the sequence were infinite. If you would never expect the function to
return (like for <code>sum</code>), then <code>reduce</code> is proably a good fit. If you might
expect it to return anyway (like for <code>contains</code>), then <code>reduce</code> is probably the
wrong tool.</p>

<p>Another good way to think about it is whether you would include a <code>return</code> or
<code>break</code> in your for-loop (or just use a while-loop). If so, your problem
probably doesn&rsquo;t match <code>reduce</code> well.</p>

<p>To make it more clear, let&rsquo;s see how <code>reduce</code> can be implemented:</p>

<pre><code>func reduce&lt;T, U&gt;(xs: [T], initial: U, combine: (U, T) -&gt; U) -&gt; U {
  var result = initial
  for x in xs {
    result = combine(result, x)
  }
  return result
}
</code></pre>

<p>If your problem can be &ldquo;reduced&rdquo; to this, then <code>reduce</code> may be a good choice. If
you need to stop the for-in loop, then you&rsquo;ll probably want another tool like
<code>find</code>.</p>

<h2>So doctor, should I reduce?</h2>

<p>I&rsquo;ve given a bunch of examples here to show how powerful and flexible <code>reduce</code>
is. I want to get your imagination going a little bit and give you some ideas on
how to use this function to solve a wide range of problem. But just because you
<em>can</em> write <code>map</code> in terms of <code>reduce</code> doesn&rsquo;t mean you <em>should</em>.</p>

<p>Most of the time if your result is an array, mapping and filtering are the right
tools. If you&rsquo;re taking an array and deriving a single value, then <code>reduce</code> (or
<code>find</code>) is often the best tool. But if you have a complex combination of mapping
and filtering, then a single <code>reduce</code> may simplify that and also speed it up.</p>

<p>Reducing is a quite popular operation in functional languages. In fact, a lot of
people (including your humble author) spend a lot of time trying to solve
complicated problems with a single, elegant reduce. When I started this blog
post, I got about half-way through implementing sorting that way when I realized
I needed to stop. Reduce is the kind of function that makes people try to be
clever, much like regular expressions. Resist the temptation, at least in your
production code. Use the tools that make your code clear, not the tools that
make you look smart.</p>

<p>But with that in mind, reduce your problems away!</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>UPDATE: After some <a href="https://twitter.com/cocoaphony/status/511339551915511808">helpful discussion</a> with @TacticalGrace and @pyrtsa, I&rsquo;ve decided this description of fold right is too misleading. I usually favor simple-but-slightly-wrong explanations over more-correct-but-requires-lots-of-background-to-understand-and-is-still-slightly-wrong, but in this case, &ldquo;goes backwards&rdquo; really confuses how foldr is commonly used. We don&rsquo;t have foldr in Swift, so I&rsquo;m not going to dig into it here in a footnote; I&rsquo;ll leave it to your <a href="https://en.wikipedia.org/wiki/Fold_%28higher-order_function%29">exploration</a>.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>In this post, and in many of my posts, I will focus on Array implementations rather than the more general Sequence. That&rsquo;s because Sequence (and Collection) can introduce a lot of complexity and obscure the key points being discussed. Some of their complexity is due to the nature of type constraints, and some is due to quirks about Swift that will likely improve. I&rsquo;ve chosen to dodge all of that and focus on the most common and simplest case: Arrays.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>If you&rsquo;re familiar with Haskell, you may know that <code>map</code> is usually implemented as a <code>foldr</code>, while this is a <code>foldl</code>. That&rsquo;s just for performance. In Haskell, list prepending (<code>:</code>) is much faster than appending (<code>++</code>). In Swift, array appending is the faster operation. So <code>foldr</code> is common in Haskell, but isn&rsquo;t even in Swift stdlib. Keep this in mind when translating Haskell algorithms to Swift. Haskell often walks lists backwards for performance reasons. It&rsquo;s more natural in Swift to walk them forward.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flattenin' Your Mappenin']]></title>
    <link href="https://robnapier.net/flatmap"/>
    <updated>2014-09-07T09:13:15-04:00</updated>
    <id>https://robnapier.net/flatmap</id>
    <content type="html"><![CDATA[<blockquote><p>In which our heroes create for themselves a convenience and discover a
surprising thing.</p></blockquote>

<p><a href="https://robnapier.net/maps">Last time</a> we looked at the incredible little <code>map</code> function, and saw
how it could be used to simplify a lot of tedious for-loops while making our
code more clear and less error-prone. This time, we&rsquo;re going to see if we can
solve a common problem that happens with mapping, nesting.</p>

<!-- more -->


<h2>When we left our heroes</h2>

<p>First, a very quick recap on mapping. We can use <code>map</code> to transform an array of
elements into an new array of different elements. For example, we can transform
an array of strings into an array of string lengths in a variety of syntaxes:</p>

<pre><code>let domains = ["apple.com", "google.com", "robnapier.net"]
let lengths = domains.map { countElements($0) }
let lengths = map(domains) { countElements($0) }
let lengths = domains.map(countElements)
let lengths = map(domains, countElements)
</code></pre>

<p>Or we could transform an array of strings into an array of URLs:</p>

<pre><code>let urls = domains.map { NSURL(scheme: "http", host: $0, path: "/") }
</code></pre>

<p>We learned that we can map optionals and our custom
<a href="https://gist.github.com/rnapier/42ef28d52ac92744730f">result</a> type.
In both cases, successful values (<code>Some</code>, <code>Success</code>) are transformed with the
function, while failing values (<code>None</code>, <code>nil</code>, <code>Failure</code>) are simply returned.
In this way, mapping is very similar to optional chaining (<code>?.</code>).</p>

<p>We discovered that the different <code>map</code> functions all have the same &ldquo;shape&rdquo;:</p>

<pre><code>map(Array&lt;T&gt;, T -&gt; U) -&gt; Array&lt;U&gt;
map(Optional&lt;T&gt;, T -&gt; U) -&gt; Optional&lt;U&gt;
map(Result&lt;T&gt;, T -&gt; U) -&gt; Result&lt;U&gt;
// or more generally:
map(F&lt;T&gt;, T -&gt; U) -&gt; F&lt;U&gt;
</code></pre>

<p>Learning to see these shapes helps us find patterns we can reuse and combine.</p>

<p>For more introduction, see
<a href="https://robnapier.net/functional-wish-fulfillment">Functional Wish Fulfillment</a> and
<a href="https://robnapier.net/maps">Maps&hellip;Wait, They Don&rsquo;t Love You Like I Love You</a>.</p>

<h2>Boxes in boxes</h2>

<p>Let&rsquo;s take a
<a href="https://gist.github.com/rnapier/e0d91580d613fb21a52b">simple example</a> to get
ourselves started on a new problem. We have customers with some properties:</p>

<pre><code>struct Customer {
  let name: String
  let emails: [String]
}

let customers = [
  Customer(name: "Alice", emails: ["alice@example.com"]),
  Customer(name: "Bob", emails: ["bob@example.org", "bobby@home.example"])
]
</code></pre>

<p>Now we&rsquo;d like a list of all our customer names for our upcoming report. Easy!</p>

<pre><code>let names = customers.map { $0.name }
// ["Alice", "Bob"]
</code></pre>

<p>Perfect. Just what we want. Now, we also have had a major security issue and
need to alert all of our users at all of their email addresses. Let&rsquo;s grab
those:</p>

<pre><code>let emails = customers.map { $0.emails }
// [["alice@example.com"], ["bob@example.org", "bobby@home.example"]]
</code></pre>

<p>Wait. That&rsquo;s not quite what we meant. We wanted a list of email addresses, not a
list-of-lists of email addresses. What are we going to do now? I wouldn&rsquo;t be
surprised if you&rsquo;ve encountered this before and fixed it with some kind of
&ldquo;flatten&rdquo; function that removes one layer of structure. It&rsquo;s slightly surprising
that Swift doesn&rsquo;t have one of these built in, but it&rsquo;s easy enough to
make.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<pre><code>func flatten&lt;T&gt;(array: [[T]]) -&gt; [T] {
  var result = [T]()
  for subarray in array {
    result.extend(subarray)
  }
  return result
}
</code></pre>

<p>With that, let&rsquo;s try again:</p>

<pre><code>let flatEmails = flatten(customers.map { $0.emails })
// ["alice@example.com", "bob@example.org", "bobby@home.example"]
</code></pre>

<p>Great. Well, pretty great. There are a few small annoyances. Throwing
<code>flatten()</code> on the start is kind of tedious, especially if this is part of a
chain of maps and filters. Consider if we wanted these to be URLs. We&rsquo;d want to
do this:</p>

<pre><code>let emails =
  customers.map { $0.emails }
  .flatten      // &lt;== this isn't possible
  .map { NSURL(string:"mailto:\($0)") }
</code></pre>

<p>But that&rsquo;s not really possible in Swift. You can&rsquo;t easily add an Array extension
for <code>flatten</code> because it only applies to arrays of arrays. Swift can&rsquo;t apply
extensions only to certain kinds of arrays. So we&rsquo;re forced to do this:</p>

<pre><code>let emails =
  flatten(customers.map { $0.emails })
  .map { NSURL(string:"mailto:\($0)") }
</code></pre>

<p>That&rsquo;s kind of ugly, and gets worse if the chain is long and has multiple points
where flattening is needed.</p>

<p>Like I said, this &ldquo;map plus flatten&rdquo; is pretty common, so maybe it&rsquo;s worth
making a little convenience method for it that we could stick on Array. Let&rsquo;s
call it <code>flatMap</code>:</p>

<pre><code>extension Array {
  func flatMap&lt;U&gt;(transform: T -&gt; [U]) -&gt; [U] {
    return flatten(self.map(transform))
  }
}
</code></pre>

<p>Just like it says on the tin. Apply the map. Flatten. Ta-da! And now we can
call:</p>

<pre><code>let flatMapEmails = customers.flatMap { $0.emails }
// ["alice@example.com", "bob@example.org", "bobby@home.example"]
</code></pre>

<p>Just like we wanted.</p>

<h2>Flat all the things</h2>

<p>Since we can map optionals and <code>Result</code>, can we flatten them too? Let&rsquo;s look at
the shape of <code>flatten</code> and how it might apply:</p>

<pre><code>flatten(Array&lt;Array&lt;T&gt;&gt;) -&gt; Array&lt;T&gt;
flatten(Optional&lt;Optional&lt;T&gt;&gt;) -&gt; Optional&lt;T&gt;
flatten(Result&lt;Result&lt;T&gt;&gt;) -&gt; Result&lt;T&gt;
</code></pre>

<p>So we could flatten a <code>T??</code> to <code>T?</code> or a <code>Result&lt;Result&lt;T&gt;&gt;</code> to <code>Result&lt;T&gt;</code>.
That makes sense and sounds useful.</p>

<pre><code>func flatten&lt;T&gt;(result: Result&lt;Result&lt;T&gt;&gt;) -&gt; Result&lt;T&gt; {
  switch result {
  case .Success(let box):
    switch box.unbox {
    case .Success(let nestedBox): return .Success(nestedBox)
    case .Failure(let err):       return .Failure(err)
    }
  case .Failure(let err): return .Failure(err)
  }
}
</code></pre>

<p>And if we can map and flatten, then of course we can write <code>flatMap</code>:</p>

<pre><code>extension Result {
  func flatMap&lt;U&gt;(transform: T -&gt; Result&lt;U&gt;) -&gt; Result&lt;U&gt; {
    return flatten(self.map(transform))
  }
}
</code></pre>

<h2>What <em>is</em> this flatMap?</h2>

<p>That was easy enough to do, but who cares? Why would you ever want to do that?</p>

<p>Let&rsquo;s go back to the shape of this function. It&rsquo;s a method, so we put the type
of <code>self</code> as the first parameter to get a function form. That makes it easier
to compare shapes:</p>

<pre><code>flatMap(Result&lt;T&gt;, T -&gt; Result&lt;U&gt;) -&gt; Result&lt;U&gt;
</code></pre>

<p>That looks very familiar. Back in
<a href="https://robnapier.net/functional-wish-fulfillment">Functional Wish Fulfillment</a> we developed a
function called <code>continueWith</code> that let us chain together functions so that we&rsquo;d
get a success if they all succeeded, and a failure if any of them failed. Here&rsquo;s
what it looked like:</p>

<pre><code>func continueWith&lt;T,U&gt;(x: Result&lt;T&gt;, f: T -&gt; Result&lt;U&gt;) -&gt; Result&lt;U&gt; {
  switch x {
  case .Success(let box): return f(box.unbox)
  case .Failure(let err): return .Failure(err)
  }
}
</code></pre>

<p>Using that, we were able to turn our big, complicated JSON parser, full of
conditional logic, into this:</p>

<pre><code>func pagesFromData(data: NSData) -&gt; Result&lt;[Page]&gt; {
  return continueWith(asJSON(data)) {     // data is NSData
    continueWith(asJSONArray($0)) {       // $0 is JSON (AnyObject)
      continueWith(secondElement($0)) {   // $0 is JSONArray ([AnyObject])
        continueWith(asStringList($0)) {  // $0 is JSON (AnyObject)
          asPages($0)                     // $0 is [String]
        } } } }                           // We return Result&lt;[Page]&gt;
}
</code></pre>

<p>Let&rsquo;s compare the shapes of these functions:</p>

<pre><code>     flatMap(Result&lt;T&gt;, T -&gt; Result&lt;U&gt;) -&gt; Result&lt;U&gt;
continueWith(Result&lt;T&gt;, T -&gt; Result&lt;U&gt;) -&gt; Result&lt;U&gt;
</code></pre>

<p>Look familiar?</p>

<p>In functional programming, when two generic functions have the same shape, you
should have a strong suspicion that they are at least related. There may be
some more basic function that they both derive from, or they may turn out to be
the same thing.</p>

<p>I&rsquo;m not going to bore you with the fairly trivial (if slightly tedious) proof
that <code>continueWith</code> and <code>flatMap</code> are in fact the same function. You can work it
out on your own if you&rsquo;re interested, or see
<a href="https://gist.github.com/rnapier/b383d2542c9fabe913c9">my version in this gist</a>.
But I will call out two facts: (1) they are the same function, and (2) it&rsquo;s
possible to <em>prove</em> it.</p>

<h2>Proving the program</h2>

<p>I am not going to wander into the &ldquo;programming is math&rdquo; debate. It&rsquo;s a silly
argument. What is important, and should be incontrovertible, is that functional
programming makes it easier to use well-established tools that are common among
mathematicians. One of those tools is the proof. We use proofs all the time, we
just don&rsquo;t call them that. Every correct automatic refactoring is based on a
proof that the code before the refactor is identical to the code after the
refactor.</p>

<p><span class='pullquote-right' data-pullquote='An optimizing compiler in a strongly typed language is essentially a giant
proof engine.'></p>

<p>An optimizing compiler in a strongly typed language is essentially a giant
proof engine. When you get errors like
<a href="http://stackoverflow.com/a/25645689/97337">&ldquo;C is not convertible to Self,&rdquo;</a>
it means you asserted something that the compiler couldn&rsquo;t prove. It may mean
that you asserted something that isn&rsquo;t true, or it may mean that the proof
engine isn&rsquo;t powerful enough to prove it, or it may even mean that the language
isn&rsquo;t powerful enough to express what you are trying to assert.</p>

<p></span></p>

<p>Functional programming makes it is easier to apply proofs. In other words, it
makes your code easier to refactor mechanically and easier to optimize
performance. A key reason is the lack of mutable state. The more mutable state
is tied up in something, the harder it is to prove that a dramatically different
implementation behaves identically.</p>

<p>Test cases are not the same thing as a proof. I can&rsquo;t create enough test cases
to be certain that every number divisible by 6 is also divisible by 2 and 3.
It&rsquo;d take an infinite number of test cases. But if I prove it, I don&rsquo;t need any
tests at all. The key to making that easy is ensuring that <code>isDivisibleBySix(n:
Int) -&gt; Bool</code> relies on nothing but <code>n</code>. If there is no mutable state, if there
are no side effects, if it&rsquo;s just a function that takes a value and returns a
value, then I can much more easily replace it with a different implementation
and be confident it will behave the same.</p>

<p>I don&rsquo;t want to wander down this road too far. I&rsquo;m not arguing that we don&rsquo;t
need tests, and I&rsquo;m not arguing for proof-of-correctness as a general practice.
I&rsquo;m saying that if you understand the difference between test and proof, and
write your code in a way to favors proofs, you will get better code, fewer
tests, simpler refactoring, and safer performance optimizations. And step one
of that is the elimination of mutable state.</p>

<h2>A method to our functional madness</h2>

<p>OK, back to more hands-on, practical concerns.</p>

<p>We implemented <code>continueWith</code> as a function, but we implemented <code>flatMap</code> as an
extension method on <code>Result</code>. Does that change anything? Here&rsquo;s our
function-based syntax:</p>

<pre><code>func pagesFromData(data: NSData) -&gt; Result&lt;[Page]&gt; {
  return continueWith(asJSON(data)) {     // data is NSData
    continueWith(asJSONArray($0)) {       // $0 is JSON (AnyObject)
      continueWith(secondElement($0)) {   // $0 is JSONArray ([AnyObject])
        continueWith(asStringList($0)) {  // $0 is JSON (AnyObject)
          asPages($0)                     // $0 is [String]
        } } } }                           // We return Result&lt;[Page]&gt;
}
</code></pre>

<p>Using a method approach, here&rsquo;s what we get:</p>

<pre><code>func pagesFromData(data: NSData) -&gt; Result&lt;[Page]&gt; {
  return asJSON(data)
    .flatMap(asJSONArray)
    .flatMap(secondElement)
    .flatMap(asStringList)
    .flatMap(asPages)
}
</code></pre>

<p>Yeah, that&rsquo;s definitely easier to read, understand, and modify. Swift syntax
tends to favor chaining methods over chaining functions. That&rsquo;s somewhat
unfortunate. Functions are easier to reason about (prove) because they don&rsquo;t
contain an implicit <code>self</code> that might hide state. Functions in Swift are also
much more flexible in how they can be made generic (type-parameterized). As we
saw before, it&rsquo;s not possible to write <code>flatten</code> as a method on a generic type.
Overuse of methods can get us into really frustrating situations if we want to
write really reusable code.</p>

<p>But the syntax favors methods&hellip; mostly.</p>

<p>Swift offers a very powerful way to chain together functions: operators.
Operators are just functions that allow some syntax benefits:</p>

<ul>
<li>They don&rsquo;t require parentheses</li>
<li>They can be prefix (<code>!x</code>), infix (<code>x + y</code>) or postfix (<code>x++</code>)</li>
</ul>


<p>So what if we defined an operator for <code>flatMap</code>? We&rsquo;ll call it <code>&gt;&gt;==</code> for
reasons I&rsquo;ll explain later.</p>

<pre><code>infix operator &gt;&gt;== {}
func &gt;&gt;== &lt;T,U&gt;(x: Result&lt;T&gt;, f:T -&gt; Result&lt;U&gt;) -&gt; Result&lt;U&gt; {
  return x.flatMap(f)
}
</code></pre>

<p>With that, here&rsquo;s
<a href="https://gist.github.com/rnapier/067156ac404cc42f17b6">our new parser</a>:</p>

<pre><code>func pagesFromData(data: NSData) -&gt; Result&lt;[Page]&gt; {
  return asJSON(data)
    &gt;&gt;== asJSONArray
    &gt;&gt;== secondElement
    &gt;&gt;== asStringList
    &gt;&gt;== asPages
}
</code></pre>

<p>I think this reads very nicely, even nicer than the method version (though we
can still improve it). Each line says &ldquo;as long as it hasn&rsquo;t failed, transform
with&hellip;.&rdquo;</p>

<p>Using operators like this can be dangerous. It&rsquo;s easy to wind up with obscure
symbol soup. The key is finding a small number of highly reusable operators that
are used consistently. There&rsquo;s a cost to forcing people to learn and memorize
your operator; make sure it&rsquo;s going to be used often enough to be worth it.</p>

<p>That said, we all use operators every day, and they&rsquo;re an important part of
programming. There is no difference between <code>+</code> and <code>&gt;&gt;==</code> other than you
learned one when you were a child. <code>+</code> is nothing more than an infix function:</p>

<pre><code>infix operator + { associativity left precedence 140 }
func +(lhs: Float, rhs: Float) -&gt; Float
func +(lhs: Int, rhs: Int) -&gt; Int
...
</code></pre>

<p>We could just as well use a function called <code>add()</code> to do the same thing, but
instead everyone memorizes this arbitrary symbol because it&rsquo;s easier to use.
That&rsquo;s important. There is nothing more <em>meaningful</em> about <code>+</code>, <code>-</code>, and <code>*</code>
versus <code>&gt;&gt;==</code>. They&rsquo;re just symbols you&rsquo;ve memorized. I&rsquo;m suggesting you should
memorize one more. Well, several. But you&rsquo;ll learn them over time just as you
learned <code>√</code>, <code>∫</code>, <code>∑</code>, and <code>∞</code> later than you learned <code>+</code> and <code>-</code>.</p>

<p>That doesn&rsquo;t mean you should go crazy with operators. In fact, I generally
suggest you avoid creating new ones until you&rsquo;ve thought quite a lot about it
and looked into how other languages solve similar problems. But as we go along,
I&rsquo;m going to introduce several general-purpose operators that will make your
code clearer and easier to write when used appropriately.</p>

<h2>A rose by any other name would be confusing</h2>

<p>You might ask now what this function should be called. We started by calling it
<code>continueWith</code>, but then it changed to <code>flatMap</code>, and then to <code>&gt;&gt;==</code>. I didn&rsquo;t
mention it here, but it&rsquo;s also called <code>Bind</code> and <code>&gt;&gt;=</code>. Other Swift developers
have called it
<a href="http://robots.thoughtbot.com/efficient-json-in-swift-with-functional-concepts-and-generics">>>></a>
and <a href="http://nomothetis.svbtle.com/the-culmination-i">>>=-</a>. Its math name is a
monadic bind. But what should we call it?</p>

<p>I believe Swift programmers should call the function <code>flatMap</code> (as in Scala) and
should use <code>&gt;&gt;==</code> as the operator (derived from Haskell). The operator should be
pronounced &ldquo;bind&rdquo; or colloquially &ldquo;and then.&rdquo; <code>bind()</code> and <code>&gt;&gt;=</code> are existing
functions in Swift, and it&rsquo;s dangerous to overload things with completely
different meanings (I&rsquo;m looking at you, C++ <code>&lt;&lt;</code>). I think the operator should
preserve as much of the &ldquo;shape&rdquo; as possible from Haskell&rsquo;s, and I think <code>&gt;&gt;==</code>
does that best.<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>

<p><span class='pullquote-right' data-pullquote='spend time looking at how other
languages and other Swift developers have approached the same problem.'></p>

<p>That&rsquo;s not really important, though. It&rsquo;s just my suggestion, and others might
reasonably disagree. The point is that before foisting a new operator on the
world (or even your team), you should spend time looking at how other
languages and other Swift developers have approached the same problem.
Otherwise you cut yourself off from a lot of insight and you make it hard for
others coming to your code. Maybe they won&rsquo;t know Haskell or F# or Scala, but
maybe they will. They definitely won&rsquo;t know the operator you made up over lunch.
Make sure it&rsquo;s valuable enough to be worth teaching them.</p>

<p></span></p>

<h2>Maps flat, maybe brains too</h2>

<p>If you&rsquo;ve gotten this far, you&rsquo;ve come a long way. It&rsquo;s a lot to take in. Let me
sum up where we are in our parser:</p>

<pre><code>func pagesFromData(data: NSData) -&gt; Result&lt;[Page]&gt; {
  return asJSON(data)
    &gt;&gt;== asJSONArray
    &gt;&gt;== secondElement
    &gt;&gt;== asStringList
    &gt;&gt;== asPages
}
</code></pre>

<blockquote><p>Given some data, convert it to JSON and then to a JSON array and then take the
second element and then convert that to a string list and then convert those to
a list of pages and return the result.</p></blockquote>

<p>I think that captures our algorithm about as clearly as we can. Compare it to
the <a href="https://gist.github.com/rnapier/9e8f92a1ce6be5c3d295">original version</a>. It
handles errors without littering our code with error handling or requiring
exceptions. It&rsquo;s compact, but not dense. It&rsquo;s easy to modify or extend. And each
of the individual functions is about as simple as it could be and easy to unit
test (or so simple that it literally can&rsquo;t be wrong). There&rsquo;s still more work to
make it generic. Things like <code>secondElement</code> obviously don&rsquo;t scale, and we&rsquo;ll
work on that in future posts. But the basic structure is quite nice I think.</p>

<p>Until then, here are some take-aways:</p>

<ul>
<li>Swift makes it easier to chain together methods than functions</li>
<li>&hellip;but methods are harder to reason about because of <code>self</code></li>
<li>Generic operators like <code>&gt;&gt;==</code> make it easy to chain together functions that peal away a small part of the problem while maintaining structure like error handling</li>
<li>&hellip;but new operators should be created with caution, founded in the lessons of history</li>
</ul>


<p>That&rsquo;s enough for this time. This was a major turning point, but there are still
a lot of things to cover. Until then, stop mutating. Evolve.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>In a later post we&rsquo;ll discuss how <code>flatten</code> is insanely simple to implement with <code>reduce</code>. The fact that its so simple is probably the reason they didn&rsquo;t bother to add <code>flatten</code> to stdlib. But I&rsquo;m guessing.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>I also have found it easy to type. I tried <code>&gt;&gt;=-</code> for a while and kept getting <code>&gt;&gt;=0-</code> when I was typing fast.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maps... Wait, They Don't Love You Like I Love You]]></title>
    <link href="https://robnapier.net/maps"/>
    <updated>2014-08-28T08:20:25-04:00</updated>
    <id>https://robnapier.net/maps</id>
    <content type="html"><![CDATA[<p>I had a bit of a throw-away line in
<a href="https://robnapier.net/functional-wish-fulfillment">Functional Wish Fulfillment</a>:</p>

<blockquote><p>Kind of like map, but kind of different.</p></blockquote>

<p>And I tossed a call to <code>map</code>, unexplained, in the middle of the parsing code. I
got a little ahead of myself there. Sorry about that. Cocoa has no <code>map</code>. Maybe
not everyone coming to Swift has a long history with this amazing little
function. In a field where monads get all the press, it&rsquo;s time to step back and
talk about the humble map.</p>

<!-- more -->


<p>After years of begging for a <code>map</code> function in Cocoa, here comes Swift with
three different versions built-in:</p>

<pre><code>/// Haskell's fmap for Optionals.
func map&lt;T, U&gt;(x: T?, f: (T) -&gt; U) -&gt; U?

/// Return an `Array` containing the results of mapping `transform` over `source`.
func map&lt;C : CollectionType, T&gt;(source: C, transform: (C.Generator.Element) -&gt; T) -&gt; [T]

/// Return an `Array` containing the results of mapping `transform` over `source`.
func map&lt;S : SequenceType, T&gt;(source: S, transform: (S.Generator.Element) -&gt; T) -&gt; [T]
</code></pre>

<p>Plus it has <code>map</code> methods on <code>Array</code>, <code>Dictionary</code>, <code>Optional</code>, <code>Range</code>,
<code>Slice</code>, and a bunch of other classes.</p>

<p>Now I know that the very first comment in the Swift header mentions both
&ldquo;Haskell&rdquo; and a non-word &ldquo;fmap,&rdquo; but trust me, most uses of <code>map</code> aren&rsquo;t complex
at all. Most of the time, it&rsquo;s just the world&rsquo;s simplest for-loop.</p>

<p>Let&rsquo;s take a really common pattern you&rsquo;ve probably written dozens of times (if
not in Swift, than in every language you&rsquo;ve ever worked in):</p>

<pre><code>let domains = ["apple.com", "google.com", "robnapier.net"]

var urls = [NSURL]()
for domain in domains {
  urls.append(NSURL(scheme: "http", host: domain, path: "/"))
}
// urls =&gt; [http://apple.com/, http://google.com/, http://robnapier.net/]
</code></pre>

<p>In a generic language like Swift, &ldquo;pattern&rdquo; means there&rsquo;s a probably a function
hiding in there, so let&rsquo;s pull out the part that doesn&rsquo;t change and call it
<code>map</code>:</p>

<pre><code>// Let's replace String with T and NSURL with U
// and let's pull out the NSURL(...) and call it transform()
func map&lt;T, U&gt;(source: [T], transform: T -&gt; U) -&gt; [U] {
  var result = [U]()
  for element in source {
    result.append(transform(element))
  }
  return result
}

// And here's our loop:
let urls = map(domains, { NSURL(scheme: "http", host: $0, path: "/") })

// Or we can use Array's method (implementation not shown)
let urls = domains.map{ NSURL(scheme: "http", host: $0, path: "/") }

// urls =&gt; [http://apple.com/, http://google.com/, http://robnapier.net/]
</code></pre>

<p>So <code>map</code> replaces the for-loop when you have data in one form and want it in
some other form.</p>

<h2>Keeping what you want</h2>

<p>Let&rsquo;s think about another really common for-loop. You have a bunch of items, but
you only want some of them. For example, maybe you want to filter out
<code>NSNotFound</code>.</p>

<pre><code>let values = [1, 1, 2, NSNotFound, 3]

var found = [Int]()
for value in values {
  if value != NSNotFound {
    found.append(value)
  }
}
// found =&gt; [1, 1, 2, 3]
</code></pre>

<p>Again, we wind up with this really generic for-loop. Let&rsquo;s factor out the common
part.</p>

<pre><code>// Replace Int with T, and instead of hard-coding the test, pass a function
// that takes an element and returns whether to include it.
func filter&lt;T&gt;(source: [T], includeElement: T -&gt; Bool) -&gt; [T] {
  var found = [T]()
  for value in source {
    if includeElement(value) {
      found.append(value)
    }
  }
  return found
}

// Filter it with a function
let found = filter(values, { $0 != NSNotFound })

// or with Array's method (implementation not shown)
let found = values.filter{ $0 != NSNotFound }

// found =&gt; [1, 1, 2, 3]
</code></pre>

<p>And again we replace our cut-and-paste for-loop with a reusable function that
captures the goal. We save some code, but it&rsquo;s more than that. We can compose
filters and maps to create more interesting things in highly readable ways.
For example, to extract simple http URLs from text:</p>

<pre><code>func embeddedURLs(text: String) -&gt; [NSURL] {
  return text
    .componentsSeparatedByString(" ")
    .filter{ $0.hasPrefix("http://") }
    .map{ NSURL(string: $0) }
}

embeddedURLs("This text contains a link to http://www.apple.com and other stuff.")
// =&gt; ["http://www.apple.com"]
</code></pre>

<p>Or see this <a href="http://stackoverflow.com/a/25486591/97337">downcasting example</a>
from StackOverflow.</p>

<p>The goal of using <code>map</code> and <code>filter</code> this way is to make your code easier to
read, understand, and debug. It gets the boilerplate out of the way and leaves
you with the key parts of what you&rsquo;re trying to do.</p>

<h2>Map is what for does</h2>

<p>Even though I&rsquo;ve discussed <code>map</code> in terms of <code>for</code>, they&rsquo;re quite different.
<code>map</code> <em>is</em>. <code>for</code> <em>does</em>. Remember the first example:</p>

<pre><code>var urls = [NSURL]()
for domain in domains {
  urls.append(NSURL(scheme: "http", host: domain, path: "/"))
}
</code></pre>

<p>In this code, <code>urls</code> is mutated by a series of <code>append</code> calls until it contains
the values we want. This code says how to construct <code>urls</code>. On the other hand:</p>

<pre><code>let urls = domains.map{ NSURL(scheme: "http", host: $0, path: "/") }
</code></pre>

<p>In this code, <code>urls</code> <em>is</em> the mapping of <code>domains</code> to <code>NSURL</code> constructors. This
code doesn&rsquo;t require any specific implementation of <code>map</code>. In principle, <code>urls</code>
could be constructed lazily the first time it&rsquo;s read, or each element could be
lazily constructed when requested. The mapping could be performed in parallel or
in reverse order. It could be performed once and cached, or recomputed every
time it&rsquo;s accessed. In principle, we don&rsquo;t care. As long as the mapping only
depends on its inputs, and as long as there are no side effects, we will always
get the same result. This is the heart of good functional programming. We
<em>define</em> <code>urls</code> and let the system worry about how to <em>compute</em> it.</p>

<p>In practice, life is seldom quite that simple, and the implementation does
matter for performance. Still, a functional approach makes it much easier to
change our mind about the implementation. For example, in Swift today, we can
switch from immediate mapping to lazy mapping by just adding <code>lazy()</code> like this:</p>

<pre><code>let urls = lazy(domains).map{ NSURL(scheme: "http", host: $0, path: "/") })
</code></pre>

<p>Compare that to the changes you&rsquo;d have to make to your <code>for</code> code to make this a
lazy computation. One can easily imagine the implementation of a <code>parallel()</code>
modifier. By focusing our code on what things are, rather than how we construct
them, swapping out one implementation for another is much simpler.</p>

<h2>It&rsquo;s all about the types</h2>

<p>In Wish Driven Development, our wish generally takes the form of a function
signature. So it&rsquo;s very important that you learn to read and think about
function signatures, especially signatures that include functions as parameters.
Let&rsquo;s look at <code>map</code> again:</p>

<pre><code>func map&lt;T, U&gt;(source: [T], transform: T -&gt; U) -&gt; [U]
</code></pre>

<p>Let&rsquo;s strip away some syntax noise to get to the heart of what&rsquo;s going on:</p>

<pre><code>map([T], T -&gt; U) -&gt; [U]
</code></pre>

<p>Or maybe you&rsquo;d rather read it this way:</p>

<pre><code>map([From], From -&gt; To) -&gt; [To]
</code></pre>

<p>This takes an array of &ldquo;something,&rdquo; and a function that can convert one
&ldquo;something&rdquo; into a &ldquo;something else,&rdquo; and returns an array of &ldquo;something else.&rdquo;
So you should use this function when you have an array of some type, and you
want an equal-sized array of some other type, and you know how to convert a
single element of the first type into the second type.</p>

<p>Let&rsquo;s look at <code>filter</code> in the same way:</p>

<pre><code>filter([T], T -&gt; Bool) -&gt; [T]
</code></pre>

<p>So this takes an array of something, and a function that returns true or false
based on one of them, and returns an array of the same kind of things.</p>

<p>Even if I took away the names <code>map</code> and <code>filter</code>, you should have some guess
what these functions do, just based on what they take and what they return.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p>Let&rsquo;s go back to the Swift header for moment. By this time, the  <code>map&lt;C:
CollectionType, T&gt;</code> function and the <code>map&lt;S: SequenceType, T&gt;</code> function should
make some sense. They&rsquo;re just more generic versions of our array-only <code>map</code>. But
there&rsquo;s one more version that seems different than the others:</p>

<pre><code>func map&lt;T, U&gt;(x: T?, f: (T) -&gt; U) -&gt; U?
</code></pre>

<p>What does that mean? It takes an optional of something, and a function that can
convert &ldquo;something&rdquo; into &ldquo;something else&rdquo; and returns an optional of &ldquo;something
else.&rdquo; That sounds a lot like our array version of map, if you just replace the
word &ldquo;array&rdquo; with &ldquo;optional.&rdquo; Can we do that? Does that even make sense?</p>

<p>Let&rsquo;s strip away some extra syntax and sugar so we can get a clearer view of
these signatures:</p>

<pre><code>map(Array&lt;T&gt;,    T -&gt; U) -&gt; Array&lt;U&gt;
map(Optional&lt;T&gt;, T -&gt; U) -&gt; Optional&lt;U&gt;
</code></pre>

<p>That&rsquo;s really, really interesting (at least to me), but if we go any deeper down
this rabbit hole, I&rsquo;m going to have to start using mathy words.<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> You
came here to learn practical applications. So let&rsquo;s crawl back up a step.</p>

<p>So what does it mean to &ldquo;map&rdquo; over an optional? Well, mapping over an array
meant generating one element for every element in the array. Why not the same
for optionals? If there&rsquo;s something inside (<code>Some</code>), map it, if not, return
<code>None</code>. Let&rsquo;s write that:</p>

<pre><code>func map&lt;T, U&gt;(x: T?, f: T -&gt; U) -&gt; U? {
  switch x {
  case .Some(let value): return .Some(f(value))
  case .None: return .None
  }
}
</code></pre>

<p>If that sounds a little like optional-chaining (<code>?.</code>), then you&rsquo;re getting it.
Optional-chaining is just a more method-friendly version of <code>map</code>.</p>

<p>So if we can map over an array, and we can map over an optional, can we map over
anything else? How about the <code>Result</code> type we built in
<a href="https://robnapier.net/functional-wish-fulfillment">Functional Wish Fulfillment</a>?<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p>

<pre><code>func map&lt;T, U&gt;(x: Result&lt;T&gt;, f: T -&gt; U) -&gt; Result&lt;U&gt; {
  switch x {
  case .Success(let box): return .Success(Box(f(box.unbox)))
  case .Failure(let err): return .Failure(err)
  }
}
</code></pre>

<p>Again, focus on learning to read the types:</p>

<pre><code>map(Result&lt;T&gt;, T -&gt; U) -&gt; Result&lt;U&gt;
</code></pre>

<p>Given a <code>Result</code> of one type (<code>T</code>), and function that can convert that type into
another type (<code>U</code>), I can get a <code>Result</code> of that second type.</p>

<p>Given an <code>F&lt;&gt;</code> that contains <code>T</code> and a function that maps a <code>T</code> to a <code>U</code>, I can
use <code>map</code> to convert <code>F&lt;T&gt;</code> into <code>F&lt;U&gt;</code>.</p>

<p>That&rsquo;s starting to sound like math, so maybe we&rsquo;ll leave it there before we go
too far.</p>

<h2>Thoughts till next time</h2>

<p>We dug pretty deep in <code>map</code> here, breezed through <code>filter</code>, and started to think
about the power of functions to separate intent from implementation. We touched
on the importance of types in understanding functions. And then we stumbled
across some interesting similarities in <code>Array</code> and <code>Optional</code> and <code>Result</code> that
expanded our mappable world.</p>

<p>If you&rsquo;re like I was the first time I walked down this road, your head is
spinning just a little bit right now, but maybe a few things are starting to
make sense. It&rsquo;s worth playing with these things in a playground. Look in your
code for some for-loops and see if you could convert them to <code>map</code> or <code>filter</code>
instead. Don&rsquo;t force it. The goal isn&rsquo;t to use fancy library functions, and the
goal isn&rsquo;t to make your code short. The goal is to make your code clear. Play
with formatting and see what makes your point most obvious. Try creating helper
functions. Refactor. Try again.</p>

<p>Soon we&rsquo;ll explore some more of these transforming functions and see what they
can do for us. Until then, stop mutating. Evolve.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>In Haskell, which has a pretty consistent syntax, you can actually search the documentation for functions that transform the types you want. That turns out to be harder in Swift because of parameter names and syntactic sugar, but the idea of reading types is just as important.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>That word is &ldquo;functor&rdquo; if you&rsquo;re curious. A <a href="https://en.wikibooks.org/wiki/Haskell/The_Functor_class">functor</a> is a structure you can map over. It&rsquo;d probably be clearer if we called it &ldquo;mappable.&rdquo;<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>Remember that &ldquo;box&rdquo; and &ldquo;unbox&rdquo; are just because of a compiler limitation in Beta6.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Functional Wish Fulfillment]]></title>
    <link href="https://robnapier.net/functional-wish-fulfillment"/>
    <updated>2014-08-18T22:00:00-04:00</updated>
    <id>https://robnapier.net/functional-wish-fulfillment</id>
    <content type="html"><![CDATA[<p>Yes, this is another of those &ldquo;how to parse JSON in Swift&rdquo; blog posts that seem
to be required of every Swift blogger. And yes, several of the techniques we&rsquo;ll
work through come from the functional programming world. And, <em>yes</em>,
Swift+Functional+JSON is itself a well-worn trail. But still, I hope you find
this exploration helpful. Don&rsquo;t think of it as functional programming. Think of
it as the path of &ldquo;I wish there were a function that&hellip;.&rdquo;</p>

<!-- more -->


<p>Let&rsquo;s start with the setup. We want to build a nice Wikipedia front end, so step
one is to allow the user to type in some search term, and return a list of
pages. Our input is a piece of JSON like this from the Wikipedia API (after
searching for &ldquo;a&rdquo;):</p>

<pre><code>["a",["Animal","Association football","Arthropod","Australia","AllMusic",...]]
</code></pre>

<p>Our output should be a list of pages or an error. &ldquo;A list of pages or an error.&rdquo;
That&rsquo;s kind of a funny thing. What type would that be? If you&rsquo;re an old ObjC dev
like me, then you&rsquo;d probably think (in Swift):</p>

<pre><code>struct Page { let title: String }
func pagesFromData(data: NSData, error: NSErrorPointer) -&gt; [Page]?
</code></pre>

<p>But that&rsquo;s kind of a pain to use. We have to create an <code>NSError</code> variable and
pass it with <code>&amp;error</code> and then check whether there was a result. Bleh. Gotta be
a better way in this new Swift world.</p>

<p>Let&rsquo;s say it again. &ldquo;A list of pages or an error.&rdquo; That means it&rsquo;s something
that could be one of a couple of types. That&rsquo;s just an enum. Let&rsquo;s make it:</p>

<pre><code>enum PageListResult {
  case Success([Page])
  case Failure(NSError)
}
</code></pre>

<p><em>I&rsquo;m going to assume that you&rsquo;ve already seen enums with associated values and
you understand the above type. If you don&rsquo;t, stop here and go read the
&ldquo;Associated Values&rdquo; section of &ldquo;Enumerations&rdquo; from
<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html">The Swift Programming Language</a>.
This is a really important concept in Swift. Seriously, go read it. It&rsquo;s like
two pages long and we&rsquo;re going to use it a lot. Don&rsquo;t worry. We&rsquo;ll wait for
you.</em></p>

<p>So that gives us a much better function signature:</p>

<pre><code>func pagesFromData(data: NSData) -&gt; PageListResult
</code></pre>

<p>I&rsquo;m amazed how often just figuring out the type I want and the function
signature really simplifies everything else. You may be familiar with this
approach from TDD, but to me, it&rsquo;s WDD: Wish Driven Development. &ldquo;I wish there
were a function that would take data and return me a list of pages or an error.&rdquo;</p>

<p>A very interesting thing happened when we phrased the wish this way. The &ldquo;happy
path&rdquo; and the &ldquo;error path&rdquo; are now the same path. For every possible input,
there is a result. It might be an error, but an error is just a kind of result.
That seems kind of nice.</p>

<p>Anyway, back to our wish fulfillment. We wished that there were this function,
so let&rsquo;s get to work writing it. (In software, we are our own genies.) To parse
this data, we need to do several things, any of which could fail:</p>

<ol>
<li>Parse the <code>NSData</code> into a JSON object</li>
<li>Make sure the JSON object is an array</li>
<li>Get the second element</li>
<li>Make sure the second element is a list of strings</li>
<li>Convert those strings into pages</li>
</ol>


<p>If we write this in a straightforward style, we get the following
(<a href="https://gist.github.com/rnapier/9e8f92a1ce6be5c3d295">complete gist</a>):</p>

<pre><code>typealias JSON = AnyObject
typealias JSONArray = [JSON]
struct Page { let title: String }

func pagesFromData(data: NSData) -&gt; PageListResult {

  // 1. Parse the NSData into a JSON object
  var error: NSError?
  let json: JSON? = NSJSONSerialization.JSONObjectWithData(data,
                      options: NSJSONReadingOptions(0), error: &amp;error)

  if let json: JSON = json {

    // 2. Make sure the JSON object is an array
    if let array = json as? JSONArray {

      // 3. Get the second element
      if array.count &lt; 2 {
        // Failure leg for 3
        return .Failure(NSError(localizedDescription: "Could not get second element. Got: \(array.count)"))
      }
      let element: JSON = array[1]

      // 4. Make sure the second element is a list of strings
      if let titles = element as? [String] {

        // 5. Convert those strings into pages
        return .Success(titles.map { Page(title: $0) })
      }
      else {
        // Failure leg for 4
        return .Failure(NSError(localizedDescription: "Expected string list. Got: \(array[1])"))
      }
    }
    else {
      // Failure leg for 2
      return .Failure(NSError(localizedDescription: "Expected array. Got: \(json)"))
    }
  }
  else if let error = error {
    // Failure leg for 1
    return .Failure(error)
  }
  else {
    fatalError("Received neither JSON nor an error")
    return .Failure(NSError())
  }
}
</code></pre>

<p>That&rsquo;s a lot of code, and frankly, it&rsquo;s hard to tell what&rsquo;s going on in there,
even with the comments. Some of it is because of how <code>if let</code> works, so the
errors wind up being in distant <code>else</code> clauses. But even if you rearranged it, I
think most approaches would look something like this. Lots of if&rsquo;s and returns
to deal with all the possible error conditions. (Or maybe you just skip the
error legs because they&rsquo;re too hard, but then you pay for it later when you&rsquo;re
trying to debug crazy problems in the field. You know I&rsquo;m talking to you. Don&rsquo;t
deny it.)</p>

<p>I&rsquo;m going to skip way ahead now and show you where we&rsquo;re going. You&rsquo;re not meant
to understand this code quite yet, but I just want you to compare readability.
This function does <em>exactly</em> the same thing as the above function. It has the
same error checks, same success and failure results, passes the same unit tests,
returns the same <code>NSError</code> values. Even with no idea what <code>&gt;==</code> means, even if
you just call it &ldquo;the thing you put at the beginning of each step,&rdquo; I&rsquo;d say this
function is a lot easier to understand and maintain.</p>

<pre><code>func pagesFromData(data: NSData) -&gt; Result&lt;[Page]&gt; {
  return data
    &gt;== asJSON
    &gt;== asJSONArray
    &gt;== atIndex(1)
    &gt;== asStringList
    &gt;== asPages
}
</code></pre>

<p>This isn&rsquo;t about fancy operators or clever tricks. We&rsquo;re not going to discuss
category theory, monads, functors, or combinators (at least not for a
while). We&rsquo;re just going to follow a sequence of &ldquo;as a real-world developer who
needs to get code out the door, I wish there were a function that&hellip;&rdquo; and see
where it takes us. This is about making code easier to read, understand, write,
and debug. And there are several stops along the way where you can jump off and
still have better code for your trouble.</p>

<p>So, what&rsquo;s the first thing we wish for? Well, a lot of our confusing code is
tied up in different ways of managing success versus failure. It would be nice
if each step dealt with success or failure in the same way. For example, I wish
there were a function that took an <code>NSData</code> and returned parsed JSON or an
error. Then it&rsquo;d look just like the <code>pagesFromData</code> function. How about:</p>

<pre><code>enum JSONResult {
  case Success(JSON)
  case Failure(NSError)
}
func asJSON(data: NSData) -&gt; JSONResult
</code></pre>

<p>That&rsquo;s OK, but now we have this <code>PageListResult</code> and <code>JSONResult</code> that are
almost identical, and obviously that&rsquo;s going to keep repeating. This feels like
a generic problem that we should solve in a generic way:</p>

<pre><code>enum Result&lt;A&gt; {
  case Success(A)
  case Failure(NSError)
}
</code></pre>

<p>And that would be great, except that Beta6 can&rsquo;t quite handle it (known bug,
will hopefully be fixed soon). So in the meantime, to get this we need a <code>Box</code>
for our <code>Success</code> case:</p>

<pre><code>enum Result&lt;A&gt; {
  case Success(Box&lt;A&gt;)
  case Failure(NSError)
}

final class Box&lt;T&gt; {
  let unbox: T
  init(_ value: T) { self.unbox = value }
}
</code></pre>

<p>So back to our wished-for function, using our awesome new <code>Result</code>:</p>

<pre><code>func asJSON(data: NSData) -&gt; Result&lt;JSON&gt; {
  var error: NSError?
  let json: AnyObject? = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(0), error: &amp;error)

  switch (json, error) {
  case (_, .Some(let error)): return .Failure(error)
  case (.Some(let json), _):  return .Success(Box(json))
  default:
    fatalError("Received neither JSON nor an error")
    return .Failure(NSError())
  }
}
</code></pre>

<p>(If the <code>.Some</code> cases are unfamiliar to you, read
<a href="http://natashatherobot.com/swift-unwrap-multiple-optionals/">Unwrapping Multiple Optionals</a>
from Natasha the Robot.)</p>

<p>Let&rsquo;s see what happens if we do that for all our functions (you can find all the
helper functions in
<a href="https://gist.github.com/rnapier/2c2bccc40b24fb9d54fc">this gist</a>):</p>

<pre><code>func pagesFromData(data: NSData) -&gt; Result&lt;[Page]&gt; {

  // 1. Parse the NSData into a JSON object
  switch asJSON(data) {
  case .Success(let boxJson):

    // 2. Make sure the JSON object is an array
    switch asJSONArray(boxJson.unbox) {
    case .Success(let boxArray):

      // 3. Get the second element
      switch secondElement(boxArray.unbox) {
      case .Success(let elementBox):

        // 4. Make sure the second element is a list of strings
        switch asStringList(elementBox.unbox) {
        case .Success(let titlesBox):

          // 5. Convert those strings into pages
          return asPages(titlesBox.unbox)

        case .Failure(let error):
          return .Failure(error)
        }
      case .Failure(let error):
        return .Failure(error)
      }
    case .Failure(let error):
      return .Failure(error)
    }
  case .Failure(let error):
    return .Failure(error)
  }
}
</code></pre>

<p>We haven&rsquo;t saved any code here. This function, plus the helper functions, is
actually a bit longer than the original. But short code wasn&rsquo;t the goal. Don&rsquo;t
focus on typing. Focus on consistency and clarity. Conciseness will often follow
on its own.</p>

<p>Our function is now incredibly consistent. At each step down the tree we call
a function that takes <code>something</code> and returns a <code>Result&lt;something-else&gt;</code>. And
if any of those results are <code>.Failure</code>, we return the error. I wish&hellip;</p>

<p>Hmmm&hellip;. what do I wish? There&rsquo;s clearly a pattern here, and where there are
patterns there are opportunities for functions. Let&rsquo;s think harder about this
pattern.</p>

<pre><code>  switch asJSON(data) {
  case .Success(let boxJson):
    switch asJSONArray(boxJson.unbox) {
    case .Success(let boxArray):
      switch secondElement(boxArray.unbox) {
    ...
              return asPages(titlesBox.unbox)
    ...
    case .Failure(let error):
      return .Failure(error)
    }
  case .Failure(let error):
    return .Failure(error)
  }
</code></pre>

<p>Let&rsquo;s write it a bit more generally:</p>

<pre><code>  switch f1(x0) {                // Pass x0 to some function
  case .Success(let x1box):      // If successful,  
    switch f2(x1box.unbox) {        // continue to another function   
    case .Success(let x2box):    // If successful,
      switch f3(x2box.unbox) {      // continue to another function
    ...
              return fn(xn.unbox)     // Return the result of the last function
    ...
    case .Failure(let error):   // If anyone fails, return failure
      return .Failure(error)
    }
  case .Failure(let error):
    return .Failure(error)
  }
</code></pre>

<p>So I wish I had a function that took &ldquo;the <code>Result</code> so far&rdquo; and &ldquo;the next step&rdquo;
and returned a <code>Result</code>. If passed a <code>.Success</code>, then it should pass the
contents to the next step. If passed a <code>.Failure</code>, then it should stop and
return that. Let&rsquo;s call it <code>continueWith</code> for the time being.</p>

<pre><code>func continueWith&lt;T,U&gt;(a: Result&lt;T&gt;, f: T -&gt; Result&lt;U&gt;) -&gt; Result&lt;U&gt;
</code></pre>

<p>Stop. I know you just skimmed over that signature. Go read it again. Make sure
you know what it says. Say it out loud. It takes a result, and a function that
takes something and returns a result, and returns a result. That probably still
didn&rsquo;t make any sense. Go back and think about it until it does. This function
is important. Think about where it says <code>A</code> and where it says <code>B</code>. It should
start to click in your head pretty quickly once you stop and think about it for
a second and stop speed-reading.</p>

<p>&hellip;</p>

<p>Really, don&rsquo;t go on until it makes 90% sense to you. You might be thinking
something like &ldquo;hey, this kind of converts A into B, but inside a Result.&rdquo; Yeah,
that kind of makes sense. Kind of like <code>map</code>, but kind of different. Hold onto
that thought, or whatever thought made it make sense to you (we&rsquo;re all
different). Maybe what you&rsquo;re thinking will be useful later.</p>

<p>&hellip;</p>

<p>OK, now that we&rsquo;re on the same page, if we had a function like that, we could
write:</p>

<pre><code>func pagesFromData(data: NSData) -&gt; Result&lt;[Page]&gt; {
  return continueWith(asJSON(data)) {     // data is NSData
    continueWith(asJSONArray($0)) {       // $0 is JSON (AnyObject)
      continueWith(secondElement($0)) {   // $0 is JSONArray ([AnyObject])
        continueWith(asStringList($0)) {  // $0 is JSON (AnyObject)
          asPages($0)                     // $0 is [String]
        } } } }                           // We return Result&lt;[Page]&gt;
}
</code></pre>

<p>That&rsquo;s starting to look kind of nice. I like this <code>continueWith</code> function. I
wonder how we&rsquo;d write it. Well, if it&rsquo;s passed a <code>.Success</code>, it unboxes it and
calls the next function.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> If it&rsquo;s passed a <code>.Failure</code>, it returns a
<code>.Failure</code>. That doesn&rsquo;t seem too hard:</p>

<pre><code>func continueWith&lt;T,U&gt;(x: Result&lt;T&gt;, f: T -&gt; Result&lt;U&gt;) -&gt; Result&lt;U&gt; {
  switch x {
  case .Success(let box): return f(box.unbox)
  case .Failure(let err): return .Failure(err)
  }
}
</code></pre>

<p>That was actually pretty simple. Don&rsquo;t get too used to the name <code>continueWith</code>.
We&rsquo;ll be discussing other names for this function later. It&rsquo;s more powerful than
it looks.</p>

<p>You can look at the <a href="https://gist.github.com/rnapier/0f5611d0bf89a9645713">full gist</a> if you like.</p>

<p>Go back and ponder that last version of <code>pagesFromData</code> for a moment. What do
you like about it? What still bothers you?</p>

<hr />

<p>I told you there were several jumping off points in this discussion, and we&rsquo;ve
reached one of them. The nested version of this function using <code>continueWith</code> is
already a lot easier to reason about than the original version. The techniques
are pretty vanilla for Swift: an enum with associated data, and a function that
takes function. All you need to do is structure your code so each failable step
takes a value and returns a <code>Result</code>. You can continue this pattern
indefinitely, keeping the code easy to understand, while still getting good
error messages.</p>

<p>So let&rsquo;s leave it there for this post. Soon we&rsquo;ll push this further, make it
easier to read and more generic. We might even talk more about this interesting
<code>continueWith</code> function.</p>

<p>In the meantime, you may be interested in some other explorations of these
topics. They all have spoilers of where we&rsquo;re going, but there&rsquo;s no harm in
that. We each learn in our own way, so maybe one of these approaches will click
best with you.</p>

<ul>
<li>Alexandros Salazar&rsquo;s
<a href="http://nomothetis.svbtle.com/error-handling-in-swift">Error Handling in Swift</a>.
A must-read series in my opinion. My use of the <code>Result</code> type is based directly
on his.</li>
<li>Tony DiPasquale&rsquo;s
<a href="http://robots.thoughtbot.com/efficient-json-in-swift-with-functional-concepts-and-generics">Efficient JSON in Swift with Functional Concepts and Generics</a>, which is a
direct influence on this work, but may be a bit fast-paced for many readers.</li>
<li>Chris Eidhof&rsquo;s
<a href="http://chris.eidhof.nl/posts/json-parsing-in-swift.html">Parsing JSON in Swift</a>
which is quite nice if you already understand where this is going, but jumps
into the deep end very quickly.</li>
</ul>


<p>If Tony or Chris&rsquo;s posts make perfect sense to you, maybe you don&rsquo;t need my
series. If you leave them a little befuddled, then this series will get to the
same place, just a bit more gently.</p>

<p>Until then, stop mutating. Evolve.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Remember that the &ldquo;unbox&rdquo; step is just because of a Beta6 compiler limitation.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
