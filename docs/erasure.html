
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>A Little Respect for AnySequence - Cocoaphony</title>
  <meta name="author" content="">

  
  <meta name="description" content="Once upon a time, when Swift was young, there were a couple of types called SequenceOf and GeneratorOf, and they could type erase stuff. &ldquo;Type &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="https://robnapier.net/erasure">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="" rel="alternate" title="Cocoaphony" type="application/atom+xml">
  <link href="https://micro.blog/cocoaphony" rel="me" />
  <link href="https://twitter.com/cocoaphony" rel="me" />
  <link href="https://github.com/robnapier" rel="me" />
  <!-- <script src="/javascripts/modernizr-2.0.js"></script> -->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <!-- <script src="/javascripts/octopress.js" type="text/javascript"></script> -->
  <script src='/javascripts/footnotes.js' type="text/javascript"></script>

</head>

<body    class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">Cocoaphony</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>

<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">A Little Respect for AnySequence</h1>
    
    
      <p class="meta">
        









<time datetime="2015-08-04T15:42:00-04:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


<div class="entry-content"><p>Once upon a time, when Swift was young, there were a couple of types called <code>SequenceOf</code> and <code>GeneratorOf</code>, and they could type erase stuff. &ldquo;Type erase?&rdquo; you may ask. &ldquo;I thought we <em>loved</em> types.&rdquo; We do. Don&rsquo;t worry. Our types aren&rsquo;t going anywhere. But sometimes we want them to be a little less&hellip;precise.</p>

<p>In Swift 2, our little type erasers got a rename and some friends. Now they&rsquo;re all named &ldquo;Any&rdquo;-something. So <code>SequenceOf</code> became <code>AnySequence</code> and <code>GeneratorOf</code> became <code>AnyGenerator</code> and there are a gaggle of indexes and collections from <code>AnyForwardIndex</code> to <code>AnyRandomAccessCollection</code>.</p>

<p>So what are these type erasers? Let&rsquo;s start with how to use one and we&rsquo;ll work backwards to why.<!-- more --></p>

<pre><code>let seq = AnySequence([1,2,3])
</code></pre>

<p>This creates an <code>AnySequence&lt;Int&gt;</code>. It&rsquo;s just a sequence of Ints that we can iterate over. Isn&rsquo;t <code>[1,2,3]</code> also a sequence of Ints we can iterate over? Well, yeah. But it&rsquo;s also explicitly an Array. And sometimes you don&rsquo;t want to have to deal with that kind of implementation detail.</p>

<h2>Who Needs Types Like That?</h2>

<p> Let&rsquo;s consider a little more complicated case:</p>

<pre><code>let xs = [1,2,3]
let ys = ["A","B","C"]
let zs = zip(xs.reverse(), ys.reverse())
// Zip2Sequence&lt;ReverseRandomAccessCollection&lt;Array&lt;Int&gt;&gt;, ReverseRandomAccessCollection&lt;Array&lt;String&gt;&gt;&gt;
</code></pre>

<p>That&rsquo;s quite a type. Imagine it as the return type of a function:</p>

<pre><code>func reverseZip&lt;T,U&gt;(xs: [T], _ ys: [U]) -&gt; Zip2Sequence&lt;ReverseRandomAccessCollection&lt;[T]&gt;, ReverseRandomAccessCollection&lt;[U]&gt;&gt; {
  return zip(xs.reverse(), ys.reverse())
}
</code></pre>

<p>That&rsquo;s insane. Let&rsquo;s not do that. Not only is the type overwhelming, but it ties us to this particular implementation. We might want to refactor the code like this:</p>

<pre><code>  return zip(xs, ys).reverse()
</code></pre>

<p>Then the return type would change to <code>[(T,U)]</code> and all the callers would have to be updated. Clearly we&rsquo;re leaking too much information about our implementation. What&rsquo;s the point of <code>reverseZip</code>? Is it to return a <code>Zip2Sequence&lt;...&gt;</code>? No. It&rsquo;s to return a sequence of tuples. We want a type that means &ldquo;a sequence of tuples.&rdquo; Often we use <code>Array</code> for that, but there&rsquo;s an even less restrictive way that doesn&rsquo;t require making an extra copy: <code>AnySequence</code>.</p>

<pre><code>func reverseZip&lt;T,U&gt;(xs: [T], _ ys: [U]) -&gt; AnySequence&lt;(T,U)&gt; {
    return AnySequence(zip(xs, ys).reverse())
}
</code></pre>

<p>Now we can keep our implementation details private. If we have some internal sequence type, we don&rsquo;t have to share it with our callers. We just give them what they need and no more.</p>

<p>Notice that <code>AnySequence</code> is not a protocol. It&rsquo;s a generic <code>struct</code> that wraps another sequence. You can&rsquo;t use an <code>[Int]</code> in a place that expects an <code>AnySequence&lt;Int&gt;</code>. You still want to use <code>SequenceType</code> for parameters in most cases.</p>

<p>These &ldquo;Any&rdquo; type erasers also aren&rsquo;t like <code>Any</code> and <code>AnyObject</code>, which are protocols that just &ldquo;hide&rdquo; the type. You can still <code>as!</code> an <code>AnyObject</code> back to its original type. <code>AnySequence</code> and its kin completely encapsulate the underlying data. You can&rsquo;t get the original back. This creates a very strong abstraction layer and strengthens type safety by making <code>as!</code> casting impossible.</p>

<p><a href="http://www.openradar.me/radar?id=5528602095386624">The new names worry me a little</a> because they make it look like <code>AnyObject</code> and <code>AnySequence</code> are the same kind of thing when they&rsquo;re not. But the new naming convention is definitely more flexible. You couldn&rsquo;t have named the <code>AnyIndex</code> types using the old <code>...Of</code> convention. So, I&rsquo;m getting used to the new names.</p>

<h2>Chains of Association</h2>

<p>Hopefully by now you&rsquo;re sold on why you&rsquo;d want to use a type eraser. But would you ever want to build one? Let&rsquo;s look at an example that comes up pretty often around associated types in protocols.</p>

<pre><code>// An Animal can eat
protocol Animal {
    typealias Food
    func feed(food: Food)
}

// Kinds of Food
struct Grass {}
struct Worm {}

struct Cow: Animal {
    func feed(food: Grass) { print("moo") }
}

struct Goat: Animal {
    func feed(food: Grass) { print("bah") }
}

struct Bird: Animal {
    func feed(food: Worm) { print("chirp") }
}
</code></pre>

<p>So now let&rsquo;s say we have a bunch of grass available and we&rsquo;d like to feed it to some grass eaters. Seems easy:</p>

<pre><code>for animal in grassEaters {
    animal.feed(Grass())
}
</code></pre>

<p>Now we just have to create this array of grass eaters. Should be simple, right? Hmmm&hellip;</p>

<pre><code>let grassEaters = [Cow(), Goat()] // error: '_' is not convertible to 'Goat'
</code></pre>

<p>That&rsquo;s a weird error. We probably just need to be explicit about the the type.</p>

<pre><code>let grassEaters: [Animal] = [Cow(), Goat()]
// error: protocol 'Animal' can only be used as a generic constraint because it has Self or associated type requirements
</code></pre>

<p>We all know that error, don&rsquo;t we? OK, let&rsquo;s try generics.</p>

<pre><code>let grassEaters: [Animal&lt;Grass&gt;] = [Cow(), Goat()]
// error: protocol 'Animal' can only be used as a generic constraint because it has Self or associated type requirements
</code></pre>

<p>Still? Oh right. You can&rsquo;t specialize an associated type using generic syntax. That&rsquo;s fine, we&rsquo;ll just make the protocol generic.</p>

<pre><code>protocol Animal&lt;Food&gt; {
    func feed(food: Food)
}
// error: Statement cannot begin with a closure expression
</code></pre>

<p>Right, protocols can&rsquo;t be generic. Type-safety is for chumps. Let&rsquo;s go back to Objective-C.</p>

<p>&hellip;Or maybe type erasure is what we need. Let&rsquo;s build <code>AnyAnimal</code>. There are several ways to do this, but the easiest in my opinion is with closures.</p>

<pre><code>struct AnyAnimal&lt;Food&gt;: Animal {
    private let _feed: (Food) -&gt; Void
    init&lt;Base: Animal where Food == Base.Food&gt;(_ base: Base) {
        _feed = base.feed
    }
    func feed(food: Food) { _feed(food) }
}
</code></pre>

<p>(While this works exactly like <code>AnySequence</code>, this isn&rsquo;t how <code>AnySequence</code> is implemented. In my next post I&rsquo;ll discuss why and how to implement type erasers like stdlib does.)</p>

<p>Now we can make <code>grassEaters</code>:</p>

<pre><code>let grassEaters = [AnyAnimal(Cow()), AnyAnimal(Goat())] // Type is [AnyAnimal&lt;Grass&gt;]
</code></pre>

<p>But we still get type safety if we try to incorrectly mix our animals:</p>

<pre><code>let mixedEaters = [AnyAnimal(Cow()), AnyAnimal(Bird())]
// error: type of expression is ambiguous without more context
</code></pre>

<p>This kind of type eraser lets us convert a protocol with associated types into a generic type. That means we can put it in properties and return values and other places that we can&rsquo;t use protocols directly. As you use more protocols in your Swift (and <a href="https://developer.apple.com/videos/wwdc/2015/?id=408">you should be</a>), I think this will become an important tool in your toolbelt.</p>

<p>So get out there and erase some over-specific types. Focus on the protocol, hide the implementation.</p>

<p><a href="https://gist.github.com/rnapier/03674b399e3bc517b9cd">And here&rsquo;s the code for your amusement.</a></p>
</div>


  <footer>
    <p class="meta">
      


      









<time datetime="2015-08-04T15:42:00-04:00" pubdate data-updated="true"></time>
      


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/product-or-process" title="Previous Post: Product or Process?">&laquo; Product or Process?</a>
      
      
        <a class="basic-alignment right" href="/rncryptor-v4" title="Next Post: RNCryptor v4">RNCryptor v4 &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    
  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2019 - <a href="mailto:rob@neverwood.org"></a> - <a href="https://twitter.com/">@</a> - 
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
