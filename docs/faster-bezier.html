
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Even Faster Bezier - Cocoaphony</title>
  <meta name="author" content="Rob Napier">

  
  <meta name="description" content="When last we looked at Bézier curve calculations, we were able to calculate five million points in about 0.6s (~8.3Mp/s or megapoints-per-second). &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="https://robnapier.net/faster-bezier">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Cocoaphony" type="application/atom+xml">
  <link href="https://micro.blog/cocoaphony" rel="me" />
  <link href="https://twitter.com/cocoaphony" rel="me" />
  <link href="https://github.com/robnapier" rel="me" />
  <!-- <script src="/javascripts/modernizr-2.0.js"></script> -->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <!-- <script src="/javascripts/octopress.js" type="text/javascript"></script> -->
  <script src='/javascripts/footnotes.js' type="text/javascript"></script>

</head>

<body    class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">Cocoaphony</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>

<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Even Faster Bezier</h1>
    
    
      <p class="meta">
        









<time datetime="2012-03-06T12:53:40-05:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


<div class="entry-content"><p>When <a href="/fast-bezier-intro">last we looked at Bézier curve calculations</a>, we were able to calculate five million points in about 0.6s (~8.3Mp/s or megapoints-per-second). That&rsquo;s 1000 points per curve, 100 curves, at 50fps. That was 5x faster than the original <code>-Os</code> optimized function. But we&rsquo;re just getting warmed up. We haven&rsquo;t yet gotten half of the performance available.</p>

<!-- more -->


<p>In this installment, we&rsquo;ll look at improving our algorithm. The code is available on <a href="https://github.com/rnapier/cocoaphony/tree/master/BezierPerf">github</a>.</p>

<p>We tried the Accelerate framework, but it didn&rsquo;t help us. The cost of the function calls obliterated our gains. What can we do? First, let&rsquo;s look at the code again, and see if we&rsquo;re doing anything foolish.</p>

<pre><code class="objc">static inline CGFloat BezierNoPow(CGFloat t, CGFloat P0, CGFloat P1, 
                                  CGFloat P2, CGFloat P3) {
  return
    (1-t)*(1-t)*(1-t) * P0
    + 3 * (1-t)*(1-t) * t * P1
    + 3 * (1-t) * t*t * P2
    + t*t*t * P3;
}

unsigned int copyBezierNoPow(CGPoint P0, CGPoint P1, CGPoint P2, CGPoint P3,
                             CGPoint **results) {
  *results = calloc(kSteps + 1, sizeof(struct CGPoint));

  for (unsigned step = 0; step &lt;= kSteps; ++step) {
    CGFloat x = BezierNoPow((CGFloat)step/(CGFloat)kSteps,
                            P0.x, P1.x, P2.x, P3.x);
    CGFloat y = BezierNoPow((CGFloat)step/(CGFloat)kSteps,
                            P0.y, P1.y, P2.y, P3.y);
    (*results)[step] = CGPointMake(x, y);
  }
  return kSteps + 1;
}
</code></pre>

<p>Notice how we&rsquo;re recalculating a lot of things. For example, we calculate <code>(1-t)*(1-t)*(1-t)</code> twice with the same <code>t</code>. That can&rsquo;t be good. What if we factor out the part that doesn&rsquo;t change between <em>x</em> and <em>y</em>?</p>

<pre><code class="objc">unsigned int copyBezierXY(CGPoint P0, CGPoint P1, CGPoint P2, CGPoint P3,
                          CGPoint **results) {
  *results = malloc((kSteps + 1) * sizeof(struct CGPoint));

  for (unsigned step = 0; step &lt;= kSteps; ++step) {
    CGFloat t = (CGFloat)step/(CGFloat)kSteps;

    CGFloat C0 = (1-t)*(1-t)*(1-t); // * P0
    CGFloat C1 = 3 * (1-t)*(1-t) * t; // * P1
    CGFloat C2 = 3 * (1-t) * t*t; // * P2
    CGFloat C3 = t*t*t; // * P3;

    CGPoint point = {
      C0*P0.x + C1*P1.x + C2*P2.x + C3*P3.x,
      C0*P0.y + C1*P1.y + C2*P2.y + C3*P3.y
    };

    (*results)[step] = point;
  }
  return kSteps + 1;
}
</code></pre>

<p>Hey, that gets us from 0.6s to 0.5s (10Mp/s). A 17% improvement&rsquo;s pretty good. But let&rsquo;s think about this some more. The values <code>t</code> can take are exactly dependent on <code>kSteps</code>, which is a constant for the program. And since the <code>C</code> variables depend only on <code>t</code>, that means they&rsquo;re a fixed set as well. We should only have to calculate them once for the whole program. That seems a lot of work we don&rsquo;t need to do. Let&rsquo;s see how it turns out.</p>

<pre><code class="objc">unsigned int copyBezierTable(CGPoint P0, CGPoint P1, CGPoint P2, CGPoint P3,
                             CGPoint **results) {
  *results = malloc((kSteps + 1) * sizeof(struct CGPoint));

  static CGFloat C0[kSteps] = {0};
  static CGFloat C1[kSteps] = {0};
  static CGFloat C2[kSteps] = {0};
  static CGFloat C3[kSteps] = {0};
  static int sInitialized = 0;
  if (!sInitialized) {
    for (unsigned step = 0; step &lt;= kSteps; ++step) {
      CGFloat t = (CGFloat)step/(CGFloat)kSteps;
      C0[step] = (1-t)*(1-t)*(1-t); // * P0
      C1[step] = 3 * (1-t)*(1-t) * t; // * P1
      C2[step] = 3 * (1-t) * t*t; // * P2
      C3[step] = t*t*t; // * P3;
    }
    sInitialized = 1;
  }

  for (unsigned step = 0; step &lt;= kSteps; ++step) {
    CGPoint point = {
      C0[step]*P0.x + C1[step]*P1.x + C2[step]*P2.x + C3[step]*P3.x,
      C0[step]*P0.y + C1[step]*P1.y + C2[step]*P2.y + C3[step]*P3.y
    };
    (*results)[step] = point;
  }
  return kSteps + 1;
}
</code></pre>

<p>0.16s. 31Mp/s. That&rsquo;s over 3x faster by just calculating the piece that changes.</p>

<p><strong>Lesson 2: In most cases, your biggest improvements will come from changing your algorithm. Whenever possible, get expensive things out of loops. Don&rsquo;t make a calculation fast if you can get rid of the calculation entirely. Remember that if you&rsquo;re called many times, that&rsquo;s the same as a loop.</strong></p>

<p>The cost of this is 4 floats (16 bytes) per step to store the constants. So for a 1000 step curve, that&rsquo;s less than 16kB. Not a bad investment on iOS. This cost is for as many curves as you want, as long as they all use the same step size. Of course, if you want different numbers of steps, you could just pass a scale variable to calculate every other point, every fourth point, etc. But by the time we&rsquo;re done optimizing this (and there&rsquo;s still plenty of performance left to unlock), you may find that it&rsquo;s faster and easier just to calculate the same number of points for all curves.</p>

<p>There is another common way to speed up Bézier calculation. Hannu Kankaanpää wrote an excellent article explaining <a href="http://www.niksula.hut.fi/~hkankaan/Homepages/bezierfast.html">forward differencing using a Taylor series</a>. His approach is fast. About 50-60% faster than <code>copyBezierXY()</code>. But <code>copyBezierTable()</code> is about twice as fast as forward differencing if you calculate a lot of curves with the same step size. Forward differencing is fast if you have one incredibly expensive curve to calculate (say a large Bézier surface). But it loses when you need to calculate a lot of curves. Factoring out everything but the points themselves into a pre-calcuated table lets you skip almost all the work. And that&rsquo;s the goal.</p>

<p>We <em>still</em> haven&rsquo;t pulled out Instruments, and we&rsquo;re still writing in portable C. I wonder what we might get if we go off-road and write directly for the NEON coprocessor. Yes, that means we&rsquo;re moving onto ARM assembler in the next post. Think you can&rsquo;t beat the compiler? Think it&rsquo;s not worth it to try? Think again.</p>
</div>


  <footer>
    <p class="meta">
      
<span class="byline author vcard">Posted by <span class="fn">Rob Napier</span></span>

      









<time datetime="2012-03-06T12:53:40-05:00" pubdate data-updated="true"></time>
      

<span class="categories">
  
    cocoaiphoneperformance
  
</span>


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/fast-bezier-intro" title="Previous Post: Introduction to Fast Bezier (and trying the Accelerate.framework)">&laquo; Introduction to Fast Bezier (and trying the Accelerate.framework)</a>
      
      
        <a class="basic-alignment right" href="/triangle-cocoaheads-march" title="Next Post: Triangle CocoaHeads (and Building a (Core) Foundation)">Triangle CocoaHeads (and Building a (Core) Foundation) &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    
  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2019 - <a href="mailto:rob@neverwood.org">Rob Napier</a> - <a href="https://twitter.com/cocoaphony">@cocoaphony</a> - 
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
