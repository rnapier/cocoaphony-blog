<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="https://robnapier.net/feed.xml" rel="self" type="application/atom+xml" /><link href="https://robnapier.net/" rel="alternate" type="text/html" /><updated>2019-11-02T17:36:50-04:00</updated><id>https://robnapier.net/feed.xml</id><title type="html">Cocoaphony</title><subtitle>Mac and iOS development with a focus on Swift and functional programming</subtitle><author><name>Rob Napier</name></author><entry><title type="html">The littlest Type</title><link href="https://robnapier.net/never" rel="alternate" type="text/html" title="The littlest Type" /><published>2019-10-28T13:02:00-04:00</published><updated>2019-10-28T13:02:00-04:00</updated><id>https://robnapier.net/never</id><content type="html" xml:base="https://robnapier.net/never">&lt;p&gt;Sometimes there‚Äôs code so commonplace that we forget how strange it actually is. I mean, Swift is a strongly typed language right? Types types types! We say what things are, and the compiler enforces it for us. But then you see some piece of code like this:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addOne&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;fatalError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Haha! No Int for you!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;That‚Äôs legal Swift. I don‚Äôt think many would find that surprising. Of course that‚Äôs legal, right? But it &lt;em&gt;is&lt;/em&gt; surprising. &lt;code class=&quot;highlighter-rouge&quot;&gt;addOne&lt;/code&gt; claims to be a function that accepts an Int and returns an Int. It does accept an Int, but‚Ä¶&lt;em&gt;it doesn‚Äôt return an Int&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;‚ÄúDon‚Äôt be silly, Rob. It crashes. It can‚Äôt return an Int if it crashes.‚Äù&lt;/p&gt;

&lt;p&gt;Well, yeah. But it promised to return an Int. It didn‚Äôt promise to ‚Äúreturn an Int or crash,‚Äù did it? The whole point of strong types was that the compiler would enforce our promises, and the compiler doesn‚Äôt bat an eye at this code.&lt;/p&gt;

&lt;p&gt;‚ÄúThe compiler can‚Äôt possibly know everything that might crash.‚Äù&lt;/p&gt;

&lt;p&gt;I‚Äôm not ready to concede that, but even so, the compiler clearly can see that this function doesn‚Äôt return an Int. There‚Äôs no &lt;code class=&quot;highlighter-rouge&quot;&gt;return intValue&lt;/code&gt; anywhere. This should prick our ears a bit. Something is strange here. Is it just compiler magic, or is there something deeper?&lt;/p&gt;

&lt;p&gt;Hint: There‚Äôs something deeper.
&lt;!-- more --&gt;&lt;/p&gt;

&lt;h3 id=&quot;staring-into-the-void&quot;&gt;Staring into the Void&lt;/h3&gt;

&lt;p&gt;Let‚Äôs take a step back and think about another thing that should surprise us.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;printSquid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ü¶ë&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So, &lt;code class=&quot;highlighter-rouge&quot;&gt;printSquid&lt;/code&gt; is a closure that takes no parameters and returns‚Ä¶what?&lt;/p&gt;

&lt;p&gt;You might be tempted to say ‚Äúnothing.‚Äù But that‚Äôs not what the code says. It says it returns Void. What‚Äôs Void?&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;typealias&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Void is a real thing. It‚Äôs the type of the empty tuple. It‚Äôs not ‚Äúnothing.‚Äù In Swift, the type &lt;code class=&quot;highlighter-rouge&quot;&gt;()&lt;/code&gt; and the value &lt;code class=&quot;highlighter-rouge&quot;&gt;()&lt;/code&gt; happen to have the same spelling. When we mean &lt;code class=&quot;highlighter-rouge&quot;&gt;()&lt;/code&gt; as a return type, we traditionally write it using the typealias Void. But &lt;code class=&quot;highlighter-rouge&quot;&gt;() -&amp;gt; ()&lt;/code&gt; is exactly the same thing as &lt;code class=&quot;highlighter-rouge&quot;&gt;() -&amp;gt; Void&lt;/code&gt;. Why ‚ÄúVoid?‚Äù Because Swift has ObjC roots, and ObjC is C-like, and in C there are &lt;code class=&quot;highlighter-rouge&quot;&gt;void&lt;/code&gt; functions that literally return nothing.&lt;/p&gt;

&lt;p&gt;In Swift, every function returns something. There are functions that return &lt;code class=&quot;highlighter-rouge&quot;&gt;()&lt;/code&gt;, and there‚Äôs some syntactic sugar that inserts &lt;code class=&quot;highlighter-rouge&quot;&gt;-&amp;gt; Void&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;return ()&lt;/code&gt; for you in some cases. But you‚Äôre free to include them if you like (it‚Äôs not particularly idiomatic Swift, but it‚Äôs legal).&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And functions like &lt;code class=&quot;highlighter-rouge&quot;&gt;print&lt;/code&gt; that seem to have no return value, really do return Void:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;printResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ü¶ë&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ü¶ë&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;printResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;                  &lt;span class=&quot;c1&quot;&gt;// ()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If we don‚Äôt add the &lt;code class=&quot;highlighter-rouge&quot;&gt;: Void&lt;/code&gt; here, the compiler will emit a warning because you usually don‚Äôt want Void values, but they‚Äôre totally legal.&lt;/p&gt;

&lt;h3 id=&quot;the-measure-of-a-type&quot;&gt;The measure of a type&lt;/h3&gt;

&lt;p&gt;Each type has a set of values that are part of that type. Some types have an enormous number of values. Int has around 18 quintillion values. String has even more. And some types have very few values. Most enums have just a handful of possible values. Bool has just 2. A lot of the power of strong types is that we can create &lt;em&gt;small&lt;/em&gt; types; types that can only hold exactly the values that are legal for our program. That‚Äôs why we prefer enums to String and Int unless we mean ‚Äúarbitrary text‚Äù or ‚Äúan arbitrary number,‚Äù and we prefer structs to Dictionary unless we mean ‚Äúan arbitrary mapping of keys to values.‚Äù Smaller, more constrained types help the compiler help us.&lt;/p&gt;

&lt;p&gt;So how small can a type get?&lt;/p&gt;

&lt;p&gt;Void has just one value. So that‚Äôs pretty small. In most languages that have this type, it‚Äôs called Unit. The one-value type.&lt;/p&gt;

&lt;p&gt;Can they get smaller?&lt;/p&gt;

&lt;h3 id=&quot;not-a-value-in-sight&quot;&gt;Not a value in sight&lt;/h3&gt;

&lt;p&gt;It‚Äôs time to get back to the original example:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addOne&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;fatalError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Haha! No Int for you!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Looking at &lt;code class=&quot;highlighter-rouge&quot;&gt;fatalError&lt;/code&gt;, it feels a lot like &lt;code class=&quot;highlighter-rouge&quot;&gt;print&lt;/code&gt;. The syntax is similar. But we can‚Äôt just throw &lt;code class=&quot;highlighter-rouge&quot;&gt;print&lt;/code&gt; into places &lt;code class=&quot;highlighter-rouge&quot;&gt;fatalError&lt;/code&gt; goes:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addOne&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Haha! No Int for you!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Cannot convert return expression of type '()' to return type 'Int'&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;^^^^^&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;How does the compiler know we‚Äôre allowed to use &lt;code class=&quot;highlighter-rouge&quot;&gt;fatalError&lt;/code&gt; here, but not &lt;code class=&quot;highlighter-rouge&quot;&gt;print&lt;/code&gt;? Maybe the compiler just knows that &lt;code class=&quot;highlighter-rouge&quot;&gt;fatalError&lt;/code&gt; is special. That‚Äôs what was done prior to Swift 3:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;@noreturn&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fatalError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;^^^^^^^^^&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;@noreturn&lt;/code&gt; attribute told the compiler that this function doesn‚Äôt return, and then the compiler had logic to handle that case and let us skip returning the Int we promised. But‚Ä¶bleh. I hate that solution. It opens up weird corner cases. For example, what happens if we add &lt;code class=&quot;highlighter-rouge&quot;&gt;@noreturn&lt;/code&gt; to a function that we claim does return something, or something that throws:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;@noreturn&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addOne&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;@noreturn&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;runForever&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The first one is probably an error, and maybe the compiler should forbid it. But what about the second one? Is throwing a ‚Äúreturn?‚Äù At the implementation level, it actually is. But should this attribute allow it? There‚Äôs not a really obvious answer. Is it possible for a function to require a &lt;code class=&quot;highlighter-rouge&quot;&gt;@noreturn&lt;/code&gt; parameter? How does this impact function overloading?&lt;/p&gt;

&lt;p&gt;In Swift 3 they got rid of the attribute hack, and solved the problem with a type: &lt;a href=&quot;https://github.com/apple/swift-evolution/blob/master/proposals/0102-noreturn-bottom-type.md&quot;&gt;Never&lt;/a&gt;. The signature of &lt;code class=&quot;highlighter-rouge&quot;&gt;fatalError&lt;/code&gt; is now:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fatalError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Never&lt;/span&gt;
                               &lt;span class=&quot;o&quot;&gt;^^^^^&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So what‚Äôs Never? Is it some new compiler trick? Nope. It‚Äôs just a type, an enum with no cases:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Never&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;How many Never values are there? Well, none. You can‚Äôt construct one. That has all kinds of interesting implications.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Never&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// f never returns&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Never&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// g can never be called&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;                  &lt;span class=&quot;c1&quot;&gt;// S can never be constructed&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;nope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Never&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 

&lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// E.ok can be constructed&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;nope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Never&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// E.nope can never be constructed&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// But also interesting:&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;G&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;G&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Never&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// This is fine. Never can be a phantom type.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Another interesting implication is that &lt;code class=&quot;highlighter-rouge&quot;&gt;[Never]&lt;/code&gt; is &lt;a href=&quot;https://twitter.com/cocoaphony/status/1184470123899478017&quot;&gt;an empty array&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Never is the smallest possible type. We call it an ‚Äúuninhabited type.‚Äù There‚Äôs nothing special about the name ‚ÄúNever.‚Äù You can create your own no-case enum, and it‚Äôll work the same.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Our own custom uninhabited type&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NeverReturn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;neverReturn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NeverReturn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// We could call fatalError() here, since generating any uninhabited type&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// is sufficient to create any other. But we can also use an infinite loop.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// The compiler can prove this will never return. Never isn't just for crashing!&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addOne&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;neverReturn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// It's fine not to return Int, because the compiler knows this doesn't return&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// While Never can be used to create a NeverReturn, they're not the same type&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;never&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Never&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;neverReturn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;           &lt;span class=&quot;c1&quot;&gt;// Cannot convert value of type 'NeverReturn' to specified type 'Never'&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;neverEver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NeverReturn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fatalError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Cannot convert value of type 'Never' to specified type 'NeverReturn'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;While it‚Äôs possible to create your own uninhabited types, I don‚Äôt really recommend it. The Swift team considered having different types for things like ‚Äúexit‚Äù vs ‚Äúabort‚Äù and intentionally chose not to. One uninhabited type is probably plenty. But it‚Äôs nice that it‚Äôs not some magical name.&lt;/p&gt;

&lt;h3 id=&quot;you-never-hit-bottom&quot;&gt;You never hit bottom&lt;/h3&gt;

&lt;p&gt;In type theory, an uninhabited type is often called a bottom type, and written as ‚ä•. A bottom type is a subtype of every other type. So Never would be an Int and a String and a UIViewController and every other type. The opposite is the top type (‚ä§), the supertype of every other type. In Swift, that‚Äôs Any.&lt;/p&gt;

&lt;p&gt;But in Swift, Never isn‚Äôt actually a bottom type. If it were, you could write this, and you can‚Äôt:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fatalError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// Cannot convert value of type 'Never' to specified type 'Int'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It‚Äôs easy to fix this with a little extra syntax if you need it:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fatalError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}()&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So Never acts like a bottom type when it‚Äôs being returned from a function, but not when it‚Äôs being passed to a function or assigned to a variable. It would be more consistent for Never to be a true bottom type, and for it to conform to every non-static protocol (i.e. protocols without static or init requirements). Whether that‚Äôs worth the weird corner cases it might create, I‚Äôm not sure. But maybe.&lt;/p&gt;

&lt;h3 id=&quot;some-things-just-dont-happen&quot;&gt;Some things just don‚Äôt happen&lt;/h3&gt;

&lt;p&gt;Never is my favorite type in stdlib. It‚Äôs been my favorite type since it was introduced in Swift 3, and the Combine framework has completely justified my love of it by applying it to generics.&lt;/p&gt;

&lt;p&gt;Publishers generate a series of values or a typed failure:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Publisher&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;associatedtype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Output&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;associatedtype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Failure&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;receive&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;subscriber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Subscriber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Failure&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Output&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Input&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;But what should Failure be if the Publisher &lt;em&gt;never&lt;/em&gt; generates errors? Never, of course. No magic needed. It just works. What if it &lt;em&gt;only&lt;/em&gt; can generate a Failure? Well, then Output is Never (see &lt;a href=&quot;https://developer.apple.com/documentation/combine/publishers/ignoreoutput&quot;&gt;IgnoreOutput&lt;/a&gt;). When there‚Äôs a proper type, the special cases disappear, and it just works.&lt;/p&gt;

&lt;p&gt;So Never has gone from a little-known type solving a little-known problem around &lt;code class=&quot;highlighter-rouge&quot;&gt;fatalError&lt;/code&gt; to something Swift developers will probably use every day without even thinking about it. And that makes me very happy.&lt;/p&gt;</content><author><name>Rob Napier</name></author><summary type="html">Sometimes there‚Äôs code so commonplace that we forget how strange it actually is. I mean, Swift is a strongly typed language right? Types types types! We say what things are, and the compiler enforces it for us. But then you see some piece of code like this: func addOne(_ x: Int) -&amp;gt; Int { fatalError(&quot;Haha! No Int for you!&quot;) } That‚Äôs legal Swift. I don‚Äôt think many would find that surprising. Of course that‚Äôs legal, right? But it is surprising. addOne claims to be a function that accepts an Int and returns an Int. It does accept an Int, but‚Ä¶it doesn‚Äôt return an Int. ‚ÄúDon‚Äôt be silly, Rob. It crashes. It can‚Äôt return an Int if it crashes.‚Äù Well, yeah. But it promised to return an Int. It didn‚Äôt promise to ‚Äúreturn an Int or crash,‚Äù did it? The whole point of strong types was that the compiler would enforce our promises, and the compiler doesn‚Äôt bat an eye at this code. ‚ÄúThe compiler can‚Äôt possibly know everything that might crash.‚Äù I‚Äôm not ready to concede that, but even so, the compiler clearly can see that this function doesn‚Äôt return an Int. There‚Äôs no return intValue anywhere. This should prick our ears a bit. Something is strange here. Is it just compiler magic, or is there something deeper? Hint: There‚Äôs something deeper. Staring into the Void Let‚Äôs take a step back and think about another thing that should surprise us. let printSquid: () -&amp;gt; Void = { print(&quot;ü¶ë&quot;) } So, printSquid is a closure that takes no parameters and returns‚Ä¶what? You might be tempted to say ‚Äúnothing.‚Äù But that‚Äôs not what the code says. It says it returns Void. What‚Äôs Void? public typealias Void = () Void is a real thing. It‚Äôs the type of the empty tuple. It‚Äôs not ‚Äúnothing.‚Äù In Swift, the type () and the value () happen to have the same spelling. When we mean () as a return type, we traditionally write it using the typealias Void. But () -&amp;gt; () is exactly the same thing as () -&amp;gt; Void. Why ‚ÄúVoid?‚Äù Because Swift has ObjC roots, and ObjC is C-like, and in C there are void functions that literally return nothing. In Swift, every function returns something. There are functions that return (), and there‚Äôs some syntactic sugar that inserts -&amp;gt; Void and return () for you in some cases. But you‚Äôre free to include them if you like (it‚Äôs not particularly idiomatic Swift, but it‚Äôs legal). func f() -&amp;gt; Void {} func g() { return () } And functions like print that seem to have no return value, really do return Void: let printResult: Void = print(&quot;ü¶ë&quot;) // ü¶ë print(printResult) // () If we don‚Äôt add the : Void here, the compiler will emit a warning because you usually don‚Äôt want Void values, but they‚Äôre totally legal. The measure of a type Each type has a set of values that are part of that type. Some types have an enormous number of values. Int has around 18 quintillion values. String has even more. And some types have very few values. Most enums have just a handful of possible values. Bool has just 2. A lot of the power of strong types is that we can create small types; types that can only hold exactly the values that are legal for our program. That‚Äôs why we prefer enums to String and Int unless we mean ‚Äúarbitrary text‚Äù or ‚Äúan arbitrary number,‚Äù and we prefer structs to Dictionary unless we mean ‚Äúan arbitrary mapping of keys to values.‚Äù Smaller, more constrained types help the compiler help us. So how small can a type get? Void has just one value. So that‚Äôs pretty small. In most languages that have this type, it‚Äôs called Unit. The one-value type. Can they get smaller? Not a value in sight It‚Äôs time to get back to the original example: func addOne(_ x: Int) -&amp;gt; Int { fatalError(&quot;Haha! No Int for you!&quot;) } Looking at fatalError, it feels a lot like print. The syntax is similar. But we can‚Äôt just throw print into places fatalError goes: func addOne(_ x: Int) -&amp;gt; Int { print(&quot;Haha! No Int for you!&quot;) // Cannot convert return expression of type '()' to return type 'Int' ^^^^^ } How does the compiler know we‚Äôre allowed to use fatalError here, but not print? Maybe the compiler just knows that fatalError is special. That‚Äôs what was done prior to Swift 3: @noreturn public func fatalError(...) ^^^^^^^^^ The @noreturn attribute told the compiler that this function doesn‚Äôt return, and then the compiler had logic to handle that case and let us skip returning the Int we promised. But‚Ä¶bleh. I hate that solution. It opens up weird corner cases. For example, what happens if we add @noreturn to a function that we claim does return something, or something that throws: @noreturn func addOne(_ x: Int) -&amp;gt; Int { ... } @noreturn func runForever() throws { ... } The first one is probably an error, and maybe the compiler should forbid it. But what about the second one? Is throwing a ‚Äúreturn?‚Äù At the implementation level, it actually is. But should this attribute allow it? There‚Äôs not a really obvious answer. Is it possible for a function to require a @noreturn parameter? How does this impact function overloading? In Swift 3 they got rid of the attribute hack, and solved the problem with a type: Never. The signature of fatalError is now: public func fatalError(...) -&amp;gt; Never ^^^^^ So what‚Äôs Never? Is it some new compiler trick? Nope. It‚Äôs just a type, an enum with no cases: public enum Never {} How many Never values are there? Well, none. You can‚Äôt construct one. That has all kinds of interesting implications. func f() -&amp;gt; Never { ... } // f never returns func g(_: Never) { ... } // g can never be called struct S { // S can never be constructed let nope: Never ... } enum E { case ok(Int) // E.ok can be constructed case nope(Never) // E.nope can never be constructed } // But also interesting: struct G&amp;lt;Element&amp;gt; {} let ok = G&amp;lt;Never&amp;gt;() // This is fine. Never can be a phantom type. Another interesting implication is that [Never] is an empty array. Never is the smallest possible type. We call it an ‚Äúuninhabited type.‚Äù There‚Äôs nothing special about the name ‚ÄúNever.‚Äù You can create your own no-case enum, and it‚Äôll work the same. // Our own custom uninhabited type enum NeverReturn {} func neverReturn() -&amp;gt; NeverReturn { // We could call fatalError() here, since generating any uninhabited type // is sufficient to create any other. But we can also use an infinite loop. // The compiler can prove this will never return. Never isn't just for crashing! while true {} } func addOne(_ x: Int) -&amp;gt; Int { neverReturn() // It's fine not to return Int, because the compiler knows this doesn't return } // While Never can be used to create a NeverReturn, they're not the same type let never: Never = neverReturn() // Cannot convert value of type 'NeverReturn' to specified type 'Never' let neverEver: NeverReturn = fatalError() // Cannot convert value of type 'Never' to specified type 'NeverReturn' While it‚Äôs possible to create your own uninhabited types, I don‚Äôt really recommend it. The Swift team considered having different types for things like ‚Äúexit‚Äù vs ‚Äúabort‚Äù and intentionally chose not to. One uninhabited type is probably plenty. But it‚Äôs nice that it‚Äôs not some magical name. You never hit bottom In type theory, an uninhabited type is often called a bottom type, and written as ‚ä•. A bottom type is a subtype of every other type. So Never would be an Int and a String and a UIViewController and every other type. The opposite is the top type (‚ä§), the supertype of every other type. In Swift, that‚Äôs Any. But in Swift, Never isn‚Äôt actually a bottom type. If it were, you could write this, and you can‚Äôt: let x: Int = fatalError() // Cannot convert value of type 'Never' to specified type 'Int' It‚Äôs easy to fix this with a little extra syntax if you need it: let x: Int = { fatalError() }() So Never acts like a bottom type when it‚Äôs being returned from a function, but not when it‚Äôs being passed to a function or assigned to a variable. It would be more consistent for Never to be a true bottom type, and for it to conform to every non-static protocol (i.e. protocols without static or init requirements). Whether that‚Äôs worth the weird corner cases it might create, I‚Äôm not sure. But maybe. Some things just don‚Äôt happen Never is my favorite type in stdlib. It‚Äôs been my favorite type since it was introduced in Swift 3, and the Combine framework has completely justified my love of it by applying it to generics. Publishers generate a series of values or a typed failure: public protocol Publisher { associatedtype Output associatedtype Failure : Error func receive&amp;lt;S&amp;gt;(subscriber: S) where S : Subscriber, Self.Failure == S.Failure, Self.Output == S.Input } But what should Failure be if the Publisher never generates errors? Never, of course. No magic needed. It just works. What if it only can generate a Failure? Well, then Output is Never (see IgnoreOutput). When there‚Äôs a proper type, the special cases disappear, and it just works. So Never has gone from a little-known type solving a little-known problem around fatalError to something Swift developers will probably use every day without even thinking about it. And that makes me very happy.</summary></entry><entry><title type="html">Protocols V: At Your Request</title><link href="https://robnapier.net/at-your-request" rel="alternate" type="text/html" title="Protocols V: At Your Request" /><published>2019-10-26T17:04:00-04:00</published><updated>2019-10-26T17:04:00-04:00</updated><id>https://robnapier.net/at-your-request</id><content type="html" xml:base="https://robnapier.net/at-your-request">&lt;p&gt;So, back to our &lt;a href=&quot;/start-with-a-protocol&quot;&gt;APIClient&lt;/a&gt;. When last &lt;a href=&quot;/thats-not-a-number&quot;&gt;I left off&lt;/a&gt;, I had the following client code:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;APIClient&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;shared&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;APIClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;baseURL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;https://www.example.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;transport&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Transport&lt;/span&gt;

    &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;transport&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Transport&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URLSession&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transport&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transport&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Fetch any Fetchable type given an ID, and return it asynchronously&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Fetchable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                 &lt;span class=&quot;nv&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;@escaping&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Construct the URLRequest&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;baseURL&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;appendingPathComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;apiBase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;appendingPathComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;urlRequest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URLRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Send it to the transport&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;transport&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;urlRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;JSONDecoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; method is great for getting a model by ID, but I have other things I want to do. For example, I‚Äôd like to periodically POST to /keepalive and return if there‚Äôs an error. That‚Äôs really similar, but kind of different.
&lt;!-- more --&gt;&lt;/p&gt;

&lt;pre style=&quot;float: left; width: 45%; min-width: 450px&quot;&gt;
// GET /&amp;lt;model&amp;gt;/&amp;lt;id&amp;gt; -&amp;gt; Model
func fetch&amp;lt;Model: Fetchable&amp;gt;(
    _ id: Model.ID,
    completion: @escaping (Result&amp;lt;Model, Error&amp;gt;) -&amp;gt; Void)
{&lt;span style=&quot;color: yellow;&quot;&gt;
    let urlRequest = URLRequest(url: baseURL
        .appendingPathComponent(Model.apiBase)
        .appendingPathComponent(&amp;quot;\(id)&amp;quot;)
    )&lt;/span&gt;

    transport.fetch(request: urlRequest) {&lt;span style=&quot;color: cyan&quot;&gt;
        data in
        completion(Result {
            let decoder = JSONDecoder()
            return try decoder.decode(
                Model.self,
                from: data.get())
        })&lt;/span&gt;
    }
}
&lt;/pre&gt;

&lt;pre style=&quot;width: 45%;&quot;&gt;
// POST /keepalive -&amp;gt; Error?
func keepAlive(
    completion: @escaping (Error?) -&amp;gt; Void)
{&lt;span style=&quot;color: yellow;&quot;&gt;
    var urlRequest = URLRequest(url: baseURL
        .appendingPathComponent(&quot;keepalive&quot;)
    )
    urlRequest.httpMethod = &quot;POST&quot;&lt;/span&gt;

    transport.send(request: urlRequest) {&lt;span style=&quot;color: cyan&quot;&gt;
        switch $0 {
        case .success: completion(nil)
        case .failure(let error): 
             completion(error)
        }&lt;/span&gt;
    }
}
&lt;/pre&gt;

&lt;div style=&quot;clear: both;&quot;&gt;&lt;/div&gt;

&lt;p&gt;Both basically follow this pattern of build an URL request, pass it to transport, and then deal with the result. I know it‚Äôs just one line that exactly duplicates, but the structure is still really similar, and it feels we could pull this apart. The problem is that &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; is doing too much.&lt;/p&gt;

&lt;p&gt;So maybe we pull out the part that changes and call it Request. But what should Request be? So often, I see people jump to a PAT (protocol with associated type) like this:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// This is a bad idea&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Request&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;urlRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URLRequest&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;associatedtype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Response&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So what‚Äôs the question we ask whenever we make a PAT? Would I ever want an array of these? I think we would definitely want an array of requests. A list of pending requests. Chaining requests together. Requests that should be retried. We definitely want an array of requests. This is a great example where someone might come along as say, if only we had &lt;a href=&quot;/existential-spelling&quot;&gt;generalized existentials&lt;/a&gt; then everything would be wonderful. No. That wouldn‚Äôt fix anything. The problem is this treats a PAT like a generic, which isn‚Äôt the right way to think about it.&lt;/p&gt;

&lt;h3 id=&quot;pats-are-not-generic-protocols-or-at-least-not-in-the-way-youre-thinking&quot;&gt;PATs are not ‚Äúgeneric protocols‚Äù (or at least not in the way you‚Äôre thinking)&lt;/h3&gt;

&lt;p&gt;Generics and PATs are very different things that solve very different problems. Generics are type-parameterization. That means that the types are being passed as parameters to the function. They‚Äôre passed at compile time, but they‚Äôre still passed by the caller. When you say &lt;code class=&quot;highlighter-rouge&quot;&gt;Array&amp;lt;Int&amp;gt;&lt;/code&gt;, you, the caller, get to decide what kinds of elements Array holds. In &lt;code class=&quot;highlighter-rouge&quot;&gt;Array&amp;lt;Int&amp;gt;(repeating: 0, count: 10)
&lt;/code&gt;, Int is just as much a parameter as 0 and 10. It‚Äôs just a different kind of parameter.&lt;/p&gt;

&lt;p&gt;PATs aren‚Äôt like that. Their associated types are not parameters passed by the caller. They‚Äôre hooks provided by the implementor of the conforming type (or whoever wrote the conforming extension). When you conform a type to a PAT, you have to provide a mapping of stuff that algorithms need to stuff this type has. Collection requires an Index type in order to implement subscripts (among other things). Set says ‚Äúhere‚Äôs my Set.Index type that Collection algorithms should use when you need an Index type.‚Äù Array says ‚Äúplease use Int as my Index for those algorithms.‚Äù As the consumer of Set or Array, you can‚Äôt change those choices. You can‚Äôt say ‚ÄúI want an Array indexed by Character.‚Äù That‚Äôs not up to you. It‚Äôs not a type parameter.&lt;/p&gt;

&lt;p&gt;The point of a PAT is to allow algorithms to use the type. If you‚Äôre thinking about storage (like putting things in an Array) rather than algorithms, you probably do not want a PAT.&lt;/p&gt;

&lt;h3 id=&quot;first-use-it-then-build-it&quot;&gt;First use it, then build it&lt;/h3&gt;

&lt;p&gt;Rather than focusing first on how to construct a Request, let‚Äôs focus on how we‚Äôd like to &lt;em&gt;use&lt;/em&gt; one. I wish something would just know all the stuff I needed to send to the transport‚Ä¶.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;APIClient&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;transport&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;urlRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                       &lt;span class=&quot;nv&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is a kind of &lt;a href=&quot;/functional-wish-fulfillment&quot;&gt;‚Äúwish driven development.‚Äù&lt;/a&gt; We ‚Äúwish‚Äù there were some type that could handle the URLRequest and completion handler for us, we pretend it exists, write the code that uses it, and then make it a reality. And the reality couldn‚Äôt be simpler:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Request&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;urlRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URLRequest&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;OK, that‚Äôs simple, but that‚Äôs still not quite what we want. There‚Äôs no model information in there. I want to create Requests that know about model types, like this:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;fetching&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So I want to put User.ID into a system and get User back out in the completion handler, but the system (Request) only understands Data. That means we‚Äôre making a type eraser. We‚Äôre hiding a type (User) inside Request. How? With one of the simplest type erasers you can have: a generic function or closure. Basically, we just take &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; and wrap it into a closure. Here‚Äôs &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;APIClient&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Fetchable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                 &lt;span class=&quot;nv&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;@escaping&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Construct the URLRequest&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;baseURL&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;appendingPathComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;apiBase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;appendingPathComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;urlRequest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URLRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Send it to the transport&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;transport&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;urlRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;JSONDecoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And here‚Äôs &lt;code class=&quot;highlighter-rouge&quot;&gt;fetching&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Request&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;baseURL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URL&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;https://www.example.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// GET /&amp;lt;model&amp;gt;/&amp;lt;id&amp;gt; -&amp;gt; Model&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fetching&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Fetchable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                           &lt;span class=&quot;nv&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;@escaping&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Request&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Construct the URLRequest&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;baseURL&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;appendingPathComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;apiBase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;appendingPathComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;urlRequest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URLRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;urlRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;urlRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Here's the closure that hides (erases) Model&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;decoder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;JSONDecoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;decoder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fetching&lt;/code&gt; is a generic method, but it returns a non-generic Request struct. This kind of generic-&amp;gt;non-generic conversion is an incredibly powerful way to simplify your system and keep generics from spiraling out of control.&lt;/p&gt;

&lt;p&gt;You may ask ‚Äúwhy a static &lt;code class=&quot;highlighter-rouge&quot;&gt;fetching&lt;/code&gt; method rather than creating an &lt;code class=&quot;highlighter-rouge&quot;&gt;init(fetching:completion)&lt;/code&gt; extension‚Äù For this one, &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; would probably be fine, but as you think about other kinds of Requests, especially ones with no parameters, it would get messy. For example, it‚Äôs hard to build a nice &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; for /keepalive. (This isn‚Äôt a deep design point; it‚Äôs just a stylistic choice. You might prefer &lt;code class=&quot;highlighter-rouge&quot;&gt;init(keepAliveWithCompletion:)&lt;/code&gt;, and that‚Äôs up to you.)&lt;/p&gt;

&lt;p&gt;In any case, this is how I‚Äôd build the /keepalive handler:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Request&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// POST /keepalive -&amp;gt; Error?&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;keepAlive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;@escaping&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Request&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;urlRequest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URLRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;baseURL&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;appendingPathComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;keepalive&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;urlRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;httpMethod&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;POST&quot;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;urlRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;urlRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;wrapping-up-the-network-stack&quot;&gt;Wrapping up the network stack&lt;/h2&gt;

&lt;p&gt;This is the end of my discussion of this little network stack (though not the end of my discussion of generics). It‚Äôs not designed to be a ‚Äúreal‚Äù network stack. I don‚Äôt expect anyone to use this directly as described. I build stacks based on these principles all the time, but I‚Äôve never had one look exactly like this. They‚Äôre each quite specialized to their particular API, and the particular needs of the app. The goal here wasn‚Äôt to create a general purpose library to solve all networking problems. The goal was to show how you would extract generic code tailored to a problem. Your API is probably different, and you‚Äôll probably build your solution in a different way. Don‚Äôt feel you have to use a Transport and an APIClient and a Request. (Though maybe you should use Transport‚Ä¶ :D)&lt;/p&gt;

&lt;p&gt;If you want to build a general purpose library around this, I suggest you first build small, custom libraries around several APIs that are very different from each other. Then look for the abstractions. Abstracting too soon, before you really understand the problem, is the most common cause of generic headaches.&lt;/p&gt;

&lt;p&gt;There is no such thing as ‚Äúas generic as possible.‚Äù Generic code is abstraction, and abstraction is choices. Choosing to make things flexible in one direction often makes it harder to be flexible in another. I have a long list of code bases where we needed more flexibility, and the first step was to rip out all the ‚Äúflexible‚Äù code that made the wrong assumptions about what kind of flexibility would be needed and was never actually used.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Write concrete code first. Then work out the generics.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If you stick to that, it‚Äôll probably work out ok.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/protocols/StartWithAProtocol.zip&quot;&gt;Swift Playground&lt;/a&gt;&lt;/p&gt;</content><author><name>Rob Napier</name></author><summary type="html">So, back to our APIClient. When last I left off, I had the following client code: final class APIClient { static let shared = APIClient() let baseURL = URL(string: &quot;https://www.example.com&quot;)! let transport: Transport init(transport: Transport = URLSession.shared) { self.transport = transport } // Fetch any Fetchable type given an ID, and return it asynchronously func fetch&amp;lt;Model: Fetchable&amp;gt;(_ id: Model.ID, completion: @escaping (Result&amp;lt;Model, Error&amp;gt;) -&amp;gt; Void) { // Construct the URLRequest let url = baseURL .appendingPathComponent(Model.apiBase) .appendingPathComponent(&quot;\(id)&quot;) let urlRequest = URLRequest(url: url) // Send it to the transport transport.send(request: urlRequest) { data in let result = Result { try JSONDecoder().decode(Model.self, from: data.get()) } completion(result) } } } This fetch method is great for getting a model by ID, but I have other things I want to do. For example, I‚Äôd like to periodically POST to /keepalive and return if there‚Äôs an error. That‚Äôs really similar, but kind of different. // GET /&amp;lt;model&amp;gt;/&amp;lt;id&amp;gt; -&amp;gt; Model func fetch&amp;lt;Model: Fetchable&amp;gt;( _ id: Model.ID, completion: @escaping (Result&amp;lt;Model, Error&amp;gt;) -&amp;gt; Void) { let urlRequest = URLRequest(url: baseURL .appendingPathComponent(Model.apiBase) .appendingPathComponent(&amp;quot;\(id)&amp;quot;) ) transport.fetch(request: urlRequest) { data in completion(Result { let decoder = JSONDecoder() return try decoder.decode( Model.self, from: data.get()) }) } } // POST /keepalive -&amp;gt; Error? func keepAlive( completion: @escaping (Error?) -&amp;gt; Void) { var urlRequest = URLRequest(url: baseURL .appendingPathComponent(&quot;keepalive&quot;) ) urlRequest.httpMethod = &quot;POST&quot; transport.send(request: urlRequest) { switch $0 { case .success: completion(nil) case .failure(let error): completion(error) } } } Both basically follow this pattern of build an URL request, pass it to transport, and then deal with the result. I know it‚Äôs just one line that exactly duplicates, but the structure is still really similar, and it feels we could pull this apart. The problem is that fetch is doing too much. So maybe we pull out the part that changes and call it Request. But what should Request be? So often, I see people jump to a PAT (protocol with associated type) like this: // This is a bad idea protocol Request { var urlRequest: URLRequest { get } associatedtype Response var completion: (Result&amp;lt;Response, Error&amp;gt;) -&amp;gt; Void { get } } So what‚Äôs the question we ask whenever we make a PAT? Would I ever want an array of these? I think we would definitely want an array of requests. A list of pending requests. Chaining requests together. Requests that should be retried. We definitely want an array of requests. This is a great example where someone might come along as say, if only we had generalized existentials then everything would be wonderful. No. That wouldn‚Äôt fix anything. The problem is this treats a PAT like a generic, which isn‚Äôt the right way to think about it. PATs are not ‚Äúgeneric protocols‚Äù (or at least not in the way you‚Äôre thinking) Generics and PATs are very different things that solve very different problems. Generics are type-parameterization. That means that the types are being passed as parameters to the function. They‚Äôre passed at compile time, but they‚Äôre still passed by the caller. When you say Array&amp;lt;Int&amp;gt;, you, the caller, get to decide what kinds of elements Array holds. In Array&amp;lt;Int&amp;gt;(repeating: 0, count: 10) , Int is just as much a parameter as 0 and 10. It‚Äôs just a different kind of parameter. PATs aren‚Äôt like that. Their associated types are not parameters passed by the caller. They‚Äôre hooks provided by the implementor of the conforming type (or whoever wrote the conforming extension). When you conform a type to a PAT, you have to provide a mapping of stuff that algorithms need to stuff this type has. Collection requires an Index type in order to implement subscripts (among other things). Set says ‚Äúhere‚Äôs my Set.Index type that Collection algorithms should use when you need an Index type.‚Äù Array says ‚Äúplease use Int as my Index for those algorithms.‚Äù As the consumer of Set or Array, you can‚Äôt change those choices. You can‚Äôt say ‚ÄúI want an Array indexed by Character.‚Äù That‚Äôs not up to you. It‚Äôs not a type parameter. The point of a PAT is to allow algorithms to use the type. If you‚Äôre thinking about storage (like putting things in an Array) rather than algorithms, you probably do not want a PAT. First use it, then build it Rather than focusing first on how to construct a Request, let‚Äôs focus on how we‚Äôd like to use one. I wish something would just know all the stuff I needed to send to the transport‚Ä¶. class APIClient { func send(_ request: Request) { transport.send(request: request.urlRequest, completion: request.completion) } } This is a kind of ‚Äúwish driven development.‚Äù We ‚Äúwish‚Äù there were some type that could handle the URLRequest and completion handler for us, we pretend it exists, write the code that uses it, and then make it a reality. And the reality couldn‚Äôt be simpler: struct Request { let urlRequest: URLRequest let completion: (Result&amp;lt;Data, Error&amp;gt;) -&amp;gt; Void } OK, that‚Äôs simple, but that‚Äôs still not quite what we want. There‚Äôs no model information in there. I want to create Requests that know about model types, like this: client.send(Request.fetching(id: User.ID(1), completion: { print($0)} )) So I want to put User.ID into a system and get User back out in the completion handler, but the system (Request) only understands Data. That means we‚Äôre making a type eraser. We‚Äôre hiding a type (User) inside Request. How? With one of the simplest type erasers you can have: a generic function or closure. Basically, we just take fetch and wrap it into a closure. Here‚Äôs fetch: class APIClient { func fetch&amp;lt;Model: Fetchable&amp;gt;(_ id: Model.ID, completion: @escaping (Result&amp;lt;Model, Error&amp;gt;) -&amp;gt; Void) { // Construct the URLRequest let url = baseURL .appendingPathComponent(Model.apiBase) .appendingPathComponent(&quot;\(id)&quot;) let urlRequest = URLRequest(url: url) // Send it to the transport transport.send(request: urlRequest) { data in let result = Result { try JSONDecoder().decode(Model.self, from: data.get()) } completion(result) } } } And here‚Äôs fetching: extension Request { static var baseURL: URL { URL(string: &quot;https://www.example.com&quot;)! } // GET /&amp;lt;model&amp;gt;/&amp;lt;id&amp;gt; -&amp;gt; Model static func fetching&amp;lt;Model: Fetchable&amp;gt;(id: Model.ID, completion: @escaping (Result&amp;lt;Model, Error&amp;gt;) -&amp;gt; Void) -&amp;gt; Request { // Construct the URLRequest let url = baseURL .appendingPathComponent(Model.apiBase) .appendingPathComponent(&quot;\(id)&quot;) let urlRequest = URLRequest(url: url) return self.init(urlRequest: urlRequest) { // Here's the closure that hides (erases) Model data in completion(Result { let decoder = JSONDecoder() return try decoder.decode(Model.self, from: data.get()) }) } } } fetching is a generic method, but it returns a non-generic Request struct. This kind of generic-&amp;gt;non-generic conversion is an incredibly powerful way to simplify your system and keep generics from spiraling out of control. You may ask ‚Äúwhy a static fetching method rather than creating an init(fetching:completion) extension‚Äù For this one, init would probably be fine, but as you think about other kinds of Requests, especially ones with no parameters, it would get messy. For example, it‚Äôs hard to build a nice init for /keepalive. (This isn‚Äôt a deep design point; it‚Äôs just a stylistic choice. You might prefer init(keepAliveWithCompletion:), and that‚Äôs up to you.) In any case, this is how I‚Äôd build the /keepalive handler: extension Request { // POST /keepalive -&amp;gt; Error? static func keepAlive(completion: @escaping (Error?) -&amp;gt; Void) -&amp;gt; Request { var urlRequest = URLRequest(url: baseURL .appendingPathComponent(&quot;keepalive&quot;) ) urlRequest.httpMethod = &quot;POST&quot; return self.init(urlRequest: urlRequest) { switch $0 { case .success: completion(nil) case .failure(let error): completion(error) } } } } Wrapping up the network stack This is the end of my discussion of this little network stack (though not the end of my discussion of generics). It‚Äôs not designed to be a ‚Äúreal‚Äù network stack. I don‚Äôt expect anyone to use this directly as described. I build stacks based on these principles all the time, but I‚Äôve never had one look exactly like this. They‚Äôre each quite specialized to their particular API, and the particular needs of the app. The goal here wasn‚Äôt to create a general purpose library to solve all networking problems. The goal was to show how you would extract generic code tailored to a problem. Your API is probably different, and you‚Äôll probably build your solution in a different way. Don‚Äôt feel you have to use a Transport and an APIClient and a Request. (Though maybe you should use Transport‚Ä¶ :D) If you want to build a general purpose library around this, I suggest you first build small, custom libraries around several APIs that are very different from each other. Then look for the abstractions. Abstracting too soon, before you really understand the problem, is the most common cause of generic headaches. There is no such thing as ‚Äúas generic as possible.‚Äù Generic code is abstraction, and abstraction is choices. Choosing to make things flexible in one direction often makes it harder to be flexible in another. I have a long list of code bases where we needed more flexibility, and the first step was to rip out all the ‚Äúflexible‚Äù code that made the wrong assumptions about what kind of flexibility would be needed and was never actually used. Write concrete code first. Then work out the generics. If you stick to that, it‚Äôll probably work out ok. Swift Playground</summary></entry><entry><title type="html">Protocols IV: That‚Äôs not a number</title><link href="https://robnapier.net/thats-not-a-number" rel="alternate" type="text/html" title="Protocols IV: That's not a number" /><published>2019-05-27T00:00:00-04:00</published><updated>2019-05-27T00:00:00-04:00</updated><id>https://robnapier.net/thats-not-a-number</id><content type="html" xml:base="https://robnapier.net/thats-not-a-number">&lt;p&gt;So far in this series, I‚Äôve &lt;a href=&quot;/start-with-a-protocol&quot;&gt;created a simple APIClient&lt;/a&gt; that can fetch any Fetchable type and decode it from a specific API, and then &lt;a href=&quot;/a-mockery-of-protocols&quot;&gt;extracted a Transport protocol&lt;/a&gt; to abstract away the network layer. In this part, I‚Äôll reconsider the top of the stack, the models, and see if I can make those more flexible.
&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;The current models are User and Document:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Codable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Hashable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Codable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Hashable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;But now the server API is changing. Document IDs will be Strings, not Ints. (True story.) But really, IDs never really &lt;em&gt;were&lt;/em&gt; Ints. I mean, IDs aren‚Äôt &lt;em&gt;numbers&lt;/em&gt;. What would it mean to add two IDs together? Or divide them? How can I pretend that an ID is a kind of number if most number-like operations would be nonsense? The current design allows me to pass document IDs when I mean user IDs. It even lets me pass random integers when I mean an ID. That can‚Äôt be right. IDs are their own thing. They want a type.&lt;/p&gt;

&lt;p&gt;As usual, I‚Äôll start very concretely with User and see if anything generic develops. The first step is to lift the ID into its own type.&lt;/p&gt;

&lt;style&gt;
    .chl { color: yellow; } /* code highlight */
&lt;/style&gt;

&lt;pre&gt;
struct User: Codable, Hashable {
    &lt;span class=&quot;chl&quot;&gt;struct ID: Codable, Hashable { 
        let value: Int 
    }
    let id: ID&lt;/span&gt;
    let name: String
}
&lt;/pre&gt;

&lt;p&gt;So now creating a User looks like this:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Alice&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;That‚Äôs ok, but I don‚Äôt like the &lt;code class=&quot;highlighter-rouge&quot;&gt;value:&lt;/code&gt; label. It violates one of the principles of the &lt;a href=&quot;https://swift.org/documentation/api-design-guidelines/#argument-labels&quot;&gt;API Design Guidelines&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In initializers that perform value preserving type conversions, omit the first argument label, e.g. &lt;code class=&quot;highlighter-rouge&quot;&gt;Int64(someUInt32)&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To comply, I should I add another initializer.&lt;/p&gt;

&lt;pre&gt;
struct User: Codable, Hashable {
    struct ID: Codable, Hashable { 
        let value: Int 
        &lt;span class=&quot;chl&quot;&gt;init(_ value: Int) { self.value = value }&lt;/span&gt;
    }
    let id: ID
    let name: String
}

let user = User(id: &lt;span class=&quot;chl&quot;&gt;User.ID(1)&lt;/span&gt;, name: &quot;Alice&quot;)
&lt;/pre&gt;

&lt;p&gt;Much better. Document will be almost exactly the same.&lt;/p&gt;

&lt;pre&gt;
struct Document: Codable, Hashable {
    struct ID: Codable, Hashable {
        let value: &lt;span class=&quot;chl&quot;&gt;String&lt;/span&gt;
        init(_ value: &lt;span class=&quot;chl&quot;&gt;String&lt;/span&gt;) { self.value = value }
    }
    let id: ID
    let title: String
}
&lt;/pre&gt;

&lt;p&gt;It‚Äôs not a lot of code, but anytime I‚Äôm tempted to cut and paste, it‚Äôs time to wonder if there‚Äôs generic code hiding in there. After all, most of the model types in this system will probably have an ID.&lt;/p&gt;

&lt;h2 id=&quot;maybe-a-protocol&quot;&gt;Maybe a protocol?&lt;/h2&gt;

&lt;p&gt;When I see code duplication, I often reach first for a protocol so I can extract a generic algorithm. That‚Äôs something protocols are very good at. In the case of ID, there are two duplicated concepts: identifiers conform to Codable and Hashable, and identifiers have a ‚Äúno label‚Äù initializer.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;pullquote-right&quot; data-pullquote=&quot;It&amp;#8217;s important to focus on the duplication of concepts, not keystrokes.&quot;&gt;
It‚Äôs important to focus on the duplication of concepts, not keystrokes. &lt;a href=&quot;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&quot;&gt;DRY&lt;/a&gt; doesn‚Äôt mean ‚Äúnever type the same letters twice.‚Äù The point is to extract things that will &lt;em&gt;vary together&lt;/em&gt;. I don‚Äôt want to capture ‚Äútypes that include the characters &lt;code class=&quot;highlighter-rouge&quot;&gt;: Codable, Hashable&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;init(_...&lt;/code&gt;.‚Äù I want to capture ‚Äúthings that behave as identifiers.‚Äù So I‚Äôm going to capture that concept as Identifier:
&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Identifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Codable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Hashable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;associatedtype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Codable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Hashable&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Identifier&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With that, User.ID is simplified to:&lt;/p&gt;

&lt;pre&gt;
struct User: Codable, Hashable {
    &lt;span class=&quot;chl&quot;&gt;struct ID: Identifier { let value: Int }&lt;/span&gt;
    let id: ID
    let name: String
}
&lt;/pre&gt;

&lt;p&gt;To use it, &lt;code class=&quot;highlighter-rouge&quot;&gt;APIClient.fetch&lt;/code&gt; needs to accept an ID type rather than an Int:&lt;/p&gt;

&lt;pre&gt;
func fetch&amp;lt;Model: Fetchable&amp;gt;(_ model: Model.Type, &lt;span class=&quot;chl&quot;&gt;id: Model.ID&lt;/span&gt;,
                             completion: @escaping (Result&amp;lt;Model, Error&amp;gt;) -&amp;gt; Void)
&lt;/pre&gt;

&lt;p&gt;And of course Fetchable needs to add an ID type:&lt;/p&gt;

&lt;pre&gt;
protocol Fetchable: Decodable {
    &lt;span class=&quot;chl&quot;&gt;associatedtype ID: Identifier&lt;/span&gt;
    static var apiBase: String { get }  // The part of the URL for this fetchable type
}
&lt;/pre&gt;

&lt;p&gt;Wait a minute‚Ä¶ There‚Äôs nothing ‚Äúof course‚Äù about that last change. Fetchable used to be a simple protocol. Now it‚Äôs a PAT (protocol with associated type). That‚Äôs a big change in Swift. Whenever you find yourself typing &lt;code class=&quot;highlighter-rouge&quot;&gt;associatedtype&lt;/code&gt;, you need to stop for a moment and think ‚Äúwould I ever want to put this in an Array?‚Äù Once you put an associated type on a protocol in Swift today, it‚Äôs no longer a ‚Äúthing.‚Äù It‚Äôs only a constraint that can be used for extensions and generic functions. It can‚Äôt put put in a variable, or be passed to a function, or in any other way be treated as a value.&lt;/p&gt;

&lt;p&gt;Yes, someday &lt;a href=&quot;/existential-spelling&quot;&gt;generalized existentials&lt;/a&gt; will improve this in some cases. But before you pine for those days, or reach for a &lt;a href=&quot;/erasure&quot;&gt;type-eraser&lt;/a&gt;, it‚Äôs time to think harder about the protocol.&lt;/p&gt;

&lt;h2 id=&quot;whats-the-next-line-of-code&quot;&gt;What‚Äôs the next line of code?&lt;/h2&gt;

&lt;p&gt;I want to roll back to the Identifier protocol and ask that question, ‚Äúwould I ever want to put an Identifier in an Array?‚Äù I‚Äôve used this protocol in production projects for a long time now, and the answer so far has been no. It just hasn‚Äôt come up. As I wrote this article, I tried to invent use cases that needed an Array of Identifiers, and each time the example kind of fell apart. I was always forcing it. But it‚Äôs worth walking through the thought process anyway.&lt;/p&gt;

&lt;p&gt;If I try to create an Array of Identifiers today, it spits out that infamous error:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ids&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Identifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Document&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;password&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Protocol 'Identifier' can only be used as a generic constraint because it has Self or associated type requirements&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And this it the point where you cry out ‚Äúgeneralized existential!‚Äù But that wouldn‚Äôt actually change anything. Let‚Äôs just imagine that we have a generalized existential or I‚Äôve written an AnyIdentifier type-eraser. Eventually I‚Äôm going to wind up with some loop over &lt;code class=&quot;highlighter-rouge&quot;&gt;ids&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ids&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ??? the only property is .value, which is an unknown type ???&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I call this the ‚Äúwhat now?‚Äù problem. The only thing I can do with &lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt; is get its value, because that‚Äôs the only thing in the protocol. But each ID can have a different value type. So what can I do with it? Even with the fabled generalized existential, the type of &lt;code class=&quot;highlighter-rouge&quot;&gt;.value&lt;/code&gt; would have to be Any. What else could it be? I can‚Äôt call &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; with that. I don‚Äôt even know the Model type.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;pullquote-right&quot; data-pullquote=&quot;If a type is solving your problems, it&amp;#8217;s not wrong.&quot;&gt;
‚ÄúI don‚Äôt even know the Model type.‚Äù As I said, I‚Äôve used this protocol in several projects and I‚Äôve never needed a list of Identifiers, but as soon as I started writing this article, I realized how weird it is that an Identifier doesn‚Äôt know what type it identifies. Originally I was going to just rewrite this article to ignore it, but these kinds of‚Ä¶mistakes?‚Ä¶are important to explore. I hesitate to call it a mistake, because it‚Äôs never mattered in any shipping software I‚Äôve worked on. If a type is solving your problems, it‚Äôs not wrong. But maybe it could be better.
&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;when-you-think-about-it-everythings-a-function&quot;&gt;When you think about it, everything‚Äôs a function.&lt;/h2&gt;

&lt;p&gt;Before I make it better, I want to show how to solve a ‚Äúwhat now?‚Äù problem &lt;em&gt;without&lt;/em&gt; changing Identifier. I know that sounds a little strange, but sometimes you inherit types that you can‚Äôt easily change, and it‚Äôs good to have lots of tools in your belt that don‚Äôt require rewriting half your project every time something is less than ideal. So let me walk through an example where you think you want to use an Array of Identifiers, but don‚Äôt.&lt;/p&gt;

&lt;p&gt;Let‚Äôs say that once an hour I want to refresh all the model objects by re-fetching them. So I build a list of Identifiers to refresh, and get the ‚Äúcan only be used as a generic constraint‚Äù error, and now have to decide what to do. The answer is to look again at what I really want. I don‚Äôt want a list of &lt;em&gt;Identifiers&lt;/em&gt;. I want a list of &lt;em&gt;refresh requests&lt;/em&gt;. A refresh request is a future action, and a future action is closure. I typically like to wrap that closure into a type. Maybe something specialized to this problem like:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;RefreshRequest&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// The delayed action to perform.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;perform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Fetchable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                           &lt;span class=&quot;n&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;APIClient&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;APIClient&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                           &lt;span class=&quot;nv&quot;&gt;updateHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;@escaping&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// On success&lt;/span&gt;
                           &lt;span class=&quot;nv&quot;&gt;errorHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;@escaping&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;logError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// On failure, with a default&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Smash together updateHandler and errorHandler into a single () -&amp;gt; Void.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;perform&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;updateHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;errorHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Just a helper so errorHandler can have a default value&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;logError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Identifier&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Failure fetching &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;: &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;requests&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;RefreshRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;updateHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}),&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;RefreshRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;documentID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;updateHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;documents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}),&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class=&quot;pullquote-right&quot; data-pullquote=&quot;You don&amp;#8217;t need to keep track of parameters (and their types) if all you need is the function itself.&quot;&gt;
The point of all of this isn‚Äôt this specific data structure. It‚Äôs that &lt;code class=&quot;highlighter-rouge&quot;&gt;() -&amp;gt; Void&lt;/code&gt; is an incredibly powerful and flexible type, and you can construct it from all kinds of other functions. It‚Äôs another case of ‚Äúcommon currency.‚Äù If you want a delayed action, that‚Äôs just a function. A lot of complicated generic code comes from trying to keep track of all the parameters to a generic function you intend to call later. You don‚Äôt need to keep track of parameters (and their types) if all you need is the function itself. This is the heart of &lt;em&gt;type-erasure&lt;/em&gt; rather than focusing on &lt;em&gt;type-erasers&lt;/em&gt;. It‚Äôs hiding types I don‚Äôt care about any more, like Model. Note in this example how two generic closures that rely on Model (&lt;code class=&quot;highlighter-rouge&quot;&gt;updateHandler&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;errorHandler&lt;/code&gt;) are combined into a single &lt;code class=&quot;highlighter-rouge&quot;&gt;() -&amp;gt; Void&lt;/code&gt;, non-generic closure that relies on nothing. This is very common technique, and it‚Äôll come up again in this series.
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;There are more improvements I could make here. The basic closure &lt;code class=&quot;highlighter-rouge&quot;&gt;{ someModel[$0.id] = $0 }&lt;/code&gt; is going to be duplicated a lot and I could fix that. But I‚Äôm going to leave it for now and focus on a better identifier.&lt;/p&gt;

&lt;h2 id=&quot;a-real-identifier&quot;&gt;A Real Identifier&lt;/h2&gt;

&lt;p&gt;What I really want is the model type to know its ID type, and the ID type to know its model type. If you remember the &lt;code class=&quot;highlighter-rouge&quot;&gt;APIClient.fetch&lt;/code&gt; method, it takes both a type and an identifier:&lt;/p&gt;

&lt;pre&gt;
func fetch&amp;lt;Model: Fetchable&amp;gt;(_ model: &lt;span class=&quot;chl&quot;&gt;Model.Type&lt;/span&gt;, id: &lt;span class=&quot;chl&quot;&gt;Model.ID&lt;/span&gt;,
                             completion: @escaping (Result&amp;lt;Model, Error&amp;gt;) -&amp;gt; Void)
&lt;/pre&gt;

&lt;p&gt;This creates awkward repetition in the API:&lt;/p&gt;

&lt;pre&gt;
client.fetch(&lt;span class=&quot;chl&quot;&gt;User&lt;/span&gt;.self, id: &lt;span class=&quot;chl&quot;&gt;User&lt;/span&gt;.ID(1), completion: { print($0)} )
&lt;/pre&gt;

&lt;p&gt;I could add an extra ‚ÄúModel‚Äù associated type to the Identifier protocol, but it gets a bit messy. Some of it is just Swift syntax (&lt;code class=&quot;highlighter-rouge&quot;&gt;where&lt;/code&gt; clauses and the like), but it really comes down to Identifier not being a very good protocol. Look at the implementations:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Identifier&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Document&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Identifier&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class=&quot;pullquote-right&quot; data-pullquote=&quot;If every instance of a protocol conforms in exactly the same way, it should probably be a generic struct.&quot;&gt;
If you think about any other implementations, they‚Äôre going to be almost identical: a struct with a single property called &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;. It‚Äôs hard to imagine any other way you‚Äôd want to implement this protocol. If every instance of a protocol conforms in exactly the same way, it should probably be a generic struct.
&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// An identifier (of some Value type) that applies to a specific Model type&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Identifier&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Codable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Hashable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Value&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Identifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Codable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Hashable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;decoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Decoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;decoder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;singleValueContainer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;encoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Encoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;container&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;singleValueContainer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Identifier has two type parameters. The Model is the type this identifier applies to. The Value is the kind of identifier it requires (Int, UInt64, String, etc). The Model isn‚Äôt actually used anywhere, but it means that &lt;code class=&quot;highlighter-rouge&quot;&gt;Identifier&amp;lt;User, Int&amp;gt;&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Identifier&amp;lt;Document, Int&amp;gt;&lt;/code&gt; are completely different types and can‚Äôt be mixed up.&lt;/p&gt;

&lt;p&gt;So User becomes:&lt;/p&gt;

&lt;pre&gt;
struct User: Codable, Hashable {
    &lt;span class=&quot;chl&quot;&gt;let id: Identifier&amp;lt;User, Int&amp;gt;&lt;/span&gt;
    let name: String
}
&lt;/pre&gt;

&lt;p&gt;That‚Äôs ok, but it‚Äôd be nicer to typealias it so I can refer to User.ID as a type:&lt;/p&gt;

&lt;pre&gt;
struct User: Codable, Hashable {
    &lt;span class=&quot;chl&quot;&gt;typealias ID = Identifier&amp;lt;User, Int&amp;gt;
    let id: ID&lt;/span&gt;
    let name: String
}
&lt;/pre&gt;

&lt;p&gt;And it can be even a little nicer if I extract a protocol, and apply it to Fetchable:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Something identified with an Identifier&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Identified&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Codable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;associatedtype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IDType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Codable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Hashable&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;typealias&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Identifier&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IDType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ID&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Something that can be fetched from the API by ID&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Fetchable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Identified&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;apiBase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// The part of the URL for this fetchable type&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// User model object&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Identified&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;typealias&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IDType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ID&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Fetchable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;apiBase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;user&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And finally, &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; doesn‚Äôt need any type parameters. The only thing that could be fetched with a User.ID is a User:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Fetchable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                             &lt;span class=&quot;nv&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;@escaping&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;trials-and-witnesses&quot;&gt;Trials and Witnesses&lt;/h2&gt;

&lt;p&gt;There are a lot of people who are a lot better than I am at this, and I‚Äôm sure they would have built this (or something better!) all at once on the first try. But I‚Äôm not bad at this stuff, and this is how it usually works for me. I want to stress that I‚Äôve shipped the protocol version of Identifier successfully in several products, and have never run into a case where I actually wanted a more powerful Identifier that knew its Model. It‚Äôs just that by playing around (and thinking a lot about &lt;a href=&quot;https://twitter.com/mbrandonw&quot;&gt;Brandon Williams‚Äô&lt;/a&gt; excellent &lt;a href=&quot;https://www.youtube.com/watch?v=3BVkbWXcFS4&quot;&gt;Protocol Witnesses&lt;/a&gt; talk) I discovered another approach.&lt;/p&gt;

&lt;p&gt;Of course I‚Äôve never actually shipped this Identified protocol. Maybe I‚Äôm wrong. Maybe it has quirks when you try to use it in real code. Maybe it turns out to awkward or limited for some reason. I won‚Äôt know until I ship it in a production project.&lt;/p&gt;

&lt;p&gt;I‚Äôll now remind you that stdlib‚Äôs Collection protocol required &lt;a href=&quot;https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md&quot;&gt;a pretty major overhaul&lt;/a&gt; in Swift 3, and tweaks in &lt;a href=&quot;https://github.com/apple/swift-evolution/blob/master/proposals/0191-eliminate-indexdistance.md&quot;&gt;Swift 4.1&lt;/a&gt; and &lt;a href=&quot;https://github.com/apple/swift-evolution/blob/master/proposals/0232-remove-customization-points.md&quot;&gt;Swift 5&lt;/a&gt;. The stdlib team is &lt;em&gt;definitely&lt;/em&gt; better at this than I am, and Collection is probably the most foundational and carefully considered protocol in Swift. And still, it‚Äôs hard to get it right on the first try. (For another major example, see the four iterations of &lt;a href=&quot;https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md&quot;&gt;Protocol-oriented integers&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;Generic code is hard. There are trade-offs. Some things are hard because Swift is still evolving. And some things are hard because generic code is just hard. Build simply and concretely, and extract solutions as you discover problems. Don‚Äôt invent problems for yourself. ‚ÄúIt isn‚Äôt generic enough‚Äù is not a problem. Make sure your generic code is solving a problem you really have, and put it off as long as you can get away with. You‚Äôll probably have to redesign it anyway.&lt;/p&gt;

&lt;p&gt;Next time I‚Äôll move beyond fetching models. There are so many other things an API can do. What would that look like?&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/protocols/StartWithAProtocol.zip&quot;&gt;Swift Playground&lt;/a&gt;&lt;/p&gt;</content><author><name>Rob Napier</name></author><summary type="html">So far in this series, I‚Äôve created a simple APIClient that can fetch any Fetchable type and decode it from a specific API, and then extracted a Transport protocol to abstract away the network layer. In this part, I‚Äôll reconsider the top of the stack, the models, and see if I can make those more flexible. The current models are User and Document: struct User: Codable, Hashable { let id: Int let name: String } struct Document: Codable, Hashable { let id: Int let title: String } But now the server API is changing. Document IDs will be Strings, not Ints. (True story.) But really, IDs never really were Ints. I mean, IDs aren‚Äôt numbers. What would it mean to add two IDs together? Or divide them? How can I pretend that an ID is a kind of number if most number-like operations would be nonsense? The current design allows me to pass document IDs when I mean user IDs. It even lets me pass random integers when I mean an ID. That can‚Äôt be right. IDs are their own thing. They want a type. As usual, I‚Äôll start very concretely with User and see if anything generic develops. The first step is to lift the ID into its own type. struct User: Codable, Hashable { struct ID: Codable, Hashable { let value: Int } let id: ID let name: String } So now creating a User looks like this: let user = User(id: User.ID(value: 1), name: &quot;Alice&quot;) That‚Äôs ok, but I don‚Äôt like the value: label. It violates one of the principles of the API Design Guidelines: In initializers that perform value preserving type conversions, omit the first argument label, e.g. Int64(someUInt32). To comply, I should I add another initializer. struct User: Codable, Hashable { struct ID: Codable, Hashable { let value: Int init(_ value: Int) { self.value = value } } let id: ID let name: String } let user = User(id: User.ID(1), name: &quot;Alice&quot;) Much better. Document will be almost exactly the same. struct Document: Codable, Hashable { struct ID: Codable, Hashable { let value: String init(_ value: String) { self.value = value } } let id: ID let title: String } It‚Äôs not a lot of code, but anytime I‚Äôm tempted to cut and paste, it‚Äôs time to wonder if there‚Äôs generic code hiding in there. After all, most of the model types in this system will probably have an ID. Maybe a protocol? When I see code duplication, I often reach first for a protocol so I can extract a generic algorithm. That‚Äôs something protocols are very good at. In the case of ID, there are two duplicated concepts: identifiers conform to Codable and Hashable, and identifiers have a ‚Äúno label‚Äù initializer. It‚Äôs important to focus on the duplication of concepts, not keystrokes. DRY doesn‚Äôt mean ‚Äúnever type the same letters twice.‚Äù The point is to extract things that will vary together. I don‚Äôt want to capture ‚Äútypes that include the characters : Codable, Hashable and init(_....‚Äù I want to capture ‚Äúthings that behave as identifiers.‚Äù So I‚Äôm going to capture that concept as Identifier: protocol Identifier: Codable, Hashable { associatedtype Value: Codable, Hashable var value: Value { get } init(value: Value) } extension Identifier { init(_ value: Value) { self.init(value: value) } } With that, User.ID is simplified to: struct User: Codable, Hashable { struct ID: Identifier { let value: Int } let id: ID let name: String } To use it, APIClient.fetch needs to accept an ID type rather than an Int: func fetch&amp;lt;Model: Fetchable&amp;gt;(_ model: Model.Type, id: Model.ID, completion: @escaping (Result&amp;lt;Model, Error&amp;gt;) -&amp;gt; Void) And of course Fetchable needs to add an ID type: protocol Fetchable: Decodable { associatedtype ID: Identifier static var apiBase: String { get } // The part of the URL for this fetchable type } Wait a minute‚Ä¶ There‚Äôs nothing ‚Äúof course‚Äù about that last change. Fetchable used to be a simple protocol. Now it‚Äôs a PAT (protocol with associated type). That‚Äôs a big change in Swift. Whenever you find yourself typing associatedtype, you need to stop for a moment and think ‚Äúwould I ever want to put this in an Array?‚Äù Once you put an associated type on a protocol in Swift today, it‚Äôs no longer a ‚Äúthing.‚Äù It‚Äôs only a constraint that can be used for extensions and generic functions. It can‚Äôt put put in a variable, or be passed to a function, or in any other way be treated as a value. Yes, someday generalized existentials will improve this in some cases. But before you pine for those days, or reach for a type-eraser, it‚Äôs time to think harder about the protocol. What‚Äôs the next line of code? I want to roll back to the Identifier protocol and ask that question, ‚Äúwould I ever want to put an Identifier in an Array?‚Äù I‚Äôve used this protocol in production projects for a long time now, and the answer so far has been no. It just hasn‚Äôt come up. As I wrote this article, I tried to invent use cases that needed an Array of Identifiers, and each time the example kind of fell apart. I was always forcing it. But it‚Äôs worth walking through the thought process anyway. If I try to create an Array of Identifiers today, it spits out that infamous error: let ids: [Identifier] = [User.ID(1), Document.ID(&quot;password&quot;)] // Protocol 'Identifier' can only be used as a generic constraint because it has Self or associated type requirements And this it the point where you cry out ‚Äúgeneralized existential!‚Äù But that wouldn‚Äôt actually change anything. Let‚Äôs just imagine that we have a generalized existential or I‚Äôve written an AnyIdentifier type-eraser. Eventually I‚Äôm going to wind up with some loop over ids: for id in ids { // ??? the only property is .value, which is an unknown type ??? } I call this the ‚Äúwhat now?‚Äù problem. The only thing I can do with id is get its value, because that‚Äôs the only thing in the protocol. But each ID can have a different value type. So what can I do with it? Even with the fabled generalized existential, the type of .value would have to be Any. What else could it be? I can‚Äôt call fetch with that. I don‚Äôt even know the Model type. ‚ÄúI don‚Äôt even know the Model type.‚Äù As I said, I‚Äôve used this protocol in several projects and I‚Äôve never needed a list of Identifiers, but as soon as I started writing this article, I realized how weird it is that an Identifier doesn‚Äôt know what type it identifies. Originally I was going to just rewrite this article to ignore it, but these kinds of‚Ä¶mistakes?‚Ä¶are important to explore. I hesitate to call it a mistake, because it‚Äôs never mattered in any shipping software I‚Äôve worked on. If a type is solving your problems, it‚Äôs not wrong. But maybe it could be better. When you think about it, everything‚Äôs a function. Before I make it better, I want to show how to solve a ‚Äúwhat now?‚Äù problem without changing Identifier. I know that sounds a little strange, but sometimes you inherit types that you can‚Äôt easily change, and it‚Äôs good to have lots of tools in your belt that don‚Äôt require rewriting half your project every time something is less than ideal. So let me walk through an example where you think you want to use an Array of Identifiers, but don‚Äôt. Let‚Äôs say that once an hour I want to refresh all the model objects by re-fetching them. So I build a list of Identifiers to refresh, and get the ‚Äúcan only be used as a generic constraint‚Äù error, and now have to decide what to do. The answer is to look again at what I really want. I don‚Äôt want a list of Identifiers. I want a list of refresh requests. A refresh request is a future action, and a future action is closure. I typically like to wrap that closure into a type. Maybe something specialized to this problem like: struct RefreshRequest { // The delayed action to perform. let perform: () -&amp;gt; Void init&amp;lt;Model: Fetchable&amp;gt;(id: Model.ID, with client: APIClient = APIClient.shared, updateHandler: @escaping (Model) -&amp;gt; Void, // On success errorHandler: @escaping (Model.ID, Error) -&amp;gt; Void = logError) // On failure, with a default { // Smash together updateHandler and errorHandler into a single () -&amp;gt; Void. perform = { client.fetch(Model.self, id: id) { switch $0 { case .success(let model): updateHandler(model) case .failure(let error): errorHandler(id, error) } } } } // Just a helper so errorHandler can have a default value static func logError&amp;lt;ID: Identifier&amp;gt;(id: ID, error: Error) { print(&quot;Failure fetching \(id): \(error)&quot;) } } let requests = [ RefreshRequest(id: userID, updateHandler: { users[$0.id] = $0 }), RefreshRequest(id: documentID, updateHandler: { documents[$0.id] = $0 }), ] The point of all of this isn‚Äôt this specific data structure. It‚Äôs that () -&amp;gt; Void is an incredibly powerful and flexible type, and you can construct it from all kinds of other functions. It‚Äôs another case of ‚Äúcommon currency.‚Äù If you want a delayed action, that‚Äôs just a function. A lot of complicated generic code comes from trying to keep track of all the parameters to a generic function you intend to call later. You don‚Äôt need to keep track of parameters (and their types) if all you need is the function itself. This is the heart of type-erasure rather than focusing on type-erasers. It‚Äôs hiding types I don‚Äôt care about any more, like Model. Note in this example how two generic closures that rely on Model (updateHandler and errorHandler) are combined into a single () -&amp;gt; Void, non-generic closure that relies on nothing. This is very common technique, and it‚Äôll come up again in this series. There are more improvements I could make here. The basic closure { someModel[$0.id] = $0 } is going to be duplicated a lot and I could fix that. But I‚Äôm going to leave it for now and focus on a better identifier. A Real Identifier What I really want is the model type to know its ID type, and the ID type to know its model type. If you remember the APIClient.fetch method, it takes both a type and an identifier: func fetch&amp;lt;Model: Fetchable&amp;gt;(_ model: Model.Type, id: Model.ID, completion: @escaping (Result&amp;lt;Model, Error&amp;gt;) -&amp;gt; Void) This creates awkward repetition in the API: client.fetch(User.self, id: User.ID(1), completion: { print($0)} ) I could add an extra ‚ÄúModel‚Äù associated type to the Identifier protocol, but it gets a bit messy. Some of it is just Swift syntax (where clauses and the like), but it really comes down to Identifier not being a very good protocol. Look at the implementations: struct User.ID: Identifier { let value: Int } struct Document.ID: Identifier { let value: String } If you think about any other implementations, they‚Äôre going to be almost identical: a struct with a single property called value. It‚Äôs hard to imagine any other way you‚Äôd want to implement this protocol. If every instance of a protocol conforms in exactly the same way, it should probably be a generic struct. // An identifier (of some Value type) that applies to a specific Model type struct Identifier&amp;lt;Model, Value&amp;gt; where Value: Codable &amp;amp; Hashable { let value: Value init(_ value: Value) { self.value = value } } extension Identifier: Codable, Hashable { init(from decoder: Decoder) throws { self.init(try decoder.singleValueContainer().decode(Value.self)) } func encode(to encoder: Encoder) throws { var container = encoder.singleValueContainer() try container.encode(value) } } Identifier has two type parameters. The Model is the type this identifier applies to. The Value is the kind of identifier it requires (Int, UInt64, String, etc). The Model isn‚Äôt actually used anywhere, but it means that Identifier&amp;lt;User, Int&amp;gt; and Identifier&amp;lt;Document, Int&amp;gt; are completely different types and can‚Äôt be mixed up. So User becomes: struct User: Codable, Hashable { let id: Identifier&amp;lt;User, Int&amp;gt; let name: String } That‚Äôs ok, but it‚Äôd be nicer to typealias it so I can refer to User.ID as a type: struct User: Codable, Hashable { typealias ID = Identifier&amp;lt;User, Int&amp;gt; let id: ID let name: String } And it can be even a little nicer if I extract a protocol, and apply it to Fetchable: // Something identified with an Identifier protocol Identified: Codable { associatedtype IDType: Codable &amp;amp; Hashable typealias ID = Identifier&amp;lt;Self, IDType&amp;gt; var id: ID { get } } // Something that can be fetched from the API by ID protocol Fetchable: Identified { static var apiBase: String { get } // The part of the URL for this fetchable type } // User model object struct User: Identified { typealias IDType = Int let id: ID let name: String } extension User: Fetchable { static var apiBase: String { return &quot;user&quot; } } And finally, fetch doesn‚Äôt need any type parameters. The only thing that could be fetched with a User.ID is a User: func fetch&amp;lt;Model: Fetchable&amp;gt;(_ id: Model.ID, completion: @escaping (Result&amp;lt;Model, Error&amp;gt;) -&amp;gt; Void) client.fetch(User.ID(1), completion: { print($0)} ) Trials and Witnesses There are a lot of people who are a lot better than I am at this, and I‚Äôm sure they would have built this (or something better!) all at once on the first try. But I‚Äôm not bad at this stuff, and this is how it usually works for me. I want to stress that I‚Äôve shipped the protocol version of Identifier successfully in several products, and have never run into a case where I actually wanted a more powerful Identifier that knew its Model. It‚Äôs just that by playing around (and thinking a lot about Brandon Williams‚Äô excellent Protocol Witnesses talk) I discovered another approach. Of course I‚Äôve never actually shipped this Identified protocol. Maybe I‚Äôm wrong. Maybe it has quirks when you try to use it in real code. Maybe it turns out to awkward or limited for some reason. I won‚Äôt know until I ship it in a production project. I‚Äôll now remind you that stdlib‚Äôs Collection protocol required a pretty major overhaul in Swift 3, and tweaks in Swift 4.1 and Swift 5. The stdlib team is definitely better at this than I am, and Collection is probably the most foundational and carefully considered protocol in Swift. And still, it‚Äôs hard to get it right on the first try. (For another major example, see the four iterations of Protocol-oriented integers.) Generic code is hard. There are trade-offs. Some things are hard because Swift is still evolving. And some things are hard because generic code is just hard. Build simply and concretely, and extract solutions as you discover problems. Don‚Äôt invent problems for yourself. ‚ÄúIt isn‚Äôt generic enough‚Äù is not a problem. Make sure your generic code is solving a problem you really have, and put it off as long as you can get away with. You‚Äôll probably have to redesign it anyway. Next time I‚Äôll move beyond fetching models. There are so many other things an API can do. What would that look like? Swift Playground</summary></entry><entry><title type="html">Protocols III: Existential Spelling</title><link href="https://robnapier.net/existential-spelling" rel="alternate" type="text/html" title="Protocols III: Existential Spelling" /><published>2019-05-12T00:00:00-04:00</published><updated>2019-05-12T00:00:00-04:00</updated><id>https://robnapier.net/existential-spelling</id><content type="html" xml:base="https://robnapier.net/existential-spelling">&lt;p&gt;&lt;em&gt;This was supposed to be a quick sidebar, but it turned into a full-length article, so I‚Äôm calling it part 3. The original part 3, continuing the network stack, is mostly done, but I wanted to explain this weird word ‚Äúexistentials‚Äù first, and it turned out longer than I‚Äôd expected. Blame Joe Groff; he‚Äôs written too much interesting stuff lately and I want to talk about it.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;If you‚Äôre interested in the future of generics in Swift, Joe Groff has a must-read post called &lt;a href=&quot;https://forums.swift.org/t/improving-the-ui-of-generics/22814&quot;&gt;Improving the UI of generics&lt;/a&gt;. (You should also read the linked &lt;a href=&quot;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&quot;&gt;Generics Manifesto&lt;/a&gt; for background.) In it, he touches on a common confusion in Swift. If you don‚Äôt understand what he‚Äôs talking about here, don‚Äôt worry. Explaining this paragraph is the point of this article.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;We gave existential types an extremely lightweight spelling, just the bare protocol name, partially following the example of other languages like Java and C# where interfaces also serve as value-abstracted types, and partially out of a hope that they would ‚Äújust work‚Äù the way people expect; if you want a type that can hold any type conforming to a protocol, just use the protocol as a type, and you don‚Äôt have to know what ‚Äúexistential‚Äù means or anything like that. In practice, for a number of reasons, this hasn‚Äôt worked out as smoothly as we had originally hoped. Although the syntax strongly suggests that the protocol as a constraint and the protocol as a type are one thing, in practice, they‚Äôre related but different things, and this manifests most confusingly in the ‚ÄúProtocol (the type) does not to conform to Protocol (the constraint)‚Äù error.
&lt;!-- more --&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;spelling&quot;&gt;Spelling?&lt;/h2&gt;

&lt;p&gt;In programming languages, the ‚Äúspelling‚Äù of something is the sequence of characters a programmer would type to represent a concept. This is often the most visible and argued-over part of a language. It‚Äôs also often a fairly shallow concern to the design, which is why it‚Äôs common to use intentionally bad ‚Äústraw man‚Äù names to discuss a concept without getting bogged down in spelling. Consider the concept ‚Äútrue if &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;  or &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;, otherwise false.‚Äù Swift spells that  &lt;code class=&quot;highlighter-rouge&quot;&gt;x || y&lt;/code&gt;. In &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_ML&quot;&gt;SML&lt;/a&gt; the same concept is spelled &lt;code class=&quot;highlighter-rouge&quot;&gt;x orelse y&lt;/code&gt;. But the spelling difference, the difference between the characters &lt;code class=&quot;highlighter-rouge&quot;&gt;||&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;orelse&lt;/code&gt;, isn‚Äôt very important. It doesn‚Äôt tell you much about how the language works. A more interesting difference, at least to me, is that &lt;code class=&quot;highlighter-rouge&quot;&gt;||&lt;/code&gt; is a &lt;a href=&quot;https://github.com/apple/swift/blob/c2ecf6d9fb030e767f43bb85fc6ac862ec6fe493/stdlib/public/core/Bool.swift#L320-L323&quot;&gt;stdlib function in Swift&lt;/a&gt;, while &lt;code class=&quot;highlighter-rouge&quot;&gt;orelse&lt;/code&gt; is hard-coded into the SML compiler, which would likely be true no matter how they were spelled.&lt;/p&gt;

&lt;p&gt;In English, some spellings have multiple meanings. The same thing happens in programming languages, and it happened in the &lt;a href=&quot;/a-mockery-of-protocols&quot;&gt;last article&lt;/a&gt;:&lt;/p&gt;

&lt;style&gt;
    .chl { color: yellow; } /* code highlight */
&lt;/style&gt;

&lt;pre&gt;
final class AddHeaders: &lt;span class=&quot;chl&quot;&gt;Transport&lt;/span&gt;
{
    let base: &lt;span class=&quot;chl&quot;&gt;Transport&lt;/span&gt;
    ...
}
&lt;/pre&gt;

&lt;p&gt;The spelling ‚ÄúTransport‚Äù has two related, but distinct, meanings. The first refers to the &lt;em&gt;protocol&lt;/em&gt; Transport. The second refers to the &lt;em&gt;existential of&lt;/em&gt; Transport.&lt;/p&gt;

&lt;h2 id=&quot;existential&quot;&gt;Existential?&lt;/h2&gt;

&lt;p&gt;The ‚Äúexistential of a protocol‚Äù can mean several things, but here it refers to a compiler-generated box that holds a value that conforms to the protocol. To see why Swift needs this box, consider an Array of Transports:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// URLSession and TestTransport both conform to Transport&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;transports&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Transport&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;URLSession&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TestTransport&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Swift would like to store Arrays contiguously in memory. So for an Array of Ints, the storage looks like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+---+---+---+
| 0 | 1 | 2 |
+---+---+---+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There are no pointers or indirection. The Ints are stored one after the other. To find the offset of index 2, you just have to multiply the size of an Int times two. That‚Äôs really fast and how you probably expect Arrays to work. Swift does the same thing for structs. It just lays them out field after field (there might be some padding, but that‚Äôs not important here).&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct S {
    let a: Int
    let b: Int
}

++--------+--------++--------+--------++--------+--------++
|| S[0].a | S[0].b || S[1].a | S[1].b || S[2].a | S[2].b ||
++--------+--------++--------+--------++--------+--------++
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Again, to find the offset of &lt;code class=&quot;highlighter-rouge&quot;&gt;S[2]&lt;/code&gt;, Swift just has to multiply two times the size of S (which is the same as two Ints). But what happens in a ‚Äúprotocol-typed‚Äù Array like &lt;code class=&quot;highlighter-rouge&quot;&gt;[Transport]&lt;/code&gt;? Each element might be a different size. What can Swift do?&lt;/p&gt;

&lt;p&gt;It makes a box that‚Äôs a fixed size (&lt;a href=&quot;https://twitter.com/johannesweiss/status/1127858044640141312&quot;&gt;currently five machine words, with three for storage&lt;/a&gt;). If the type can fit in the box, then it‚Äôs stored in the box. If it can‚Äôt fit, then the compiler allocates some  space, copies the data there, and puts a pointer in the box. Reference types are already pointers, so it just puts the pointer in the box. In Swift, that box is called an &lt;em&gt;existential container&lt;/em&gt;. The thing in the box is called a &lt;em&gt;witness&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;See &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2016/416/&quot;&gt;WWDC 2016: Understanding Swift Performance&lt;/a&gt; for more on the implementation details.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;sure-but-existential&quot;&gt;Sure, but ‚Äúexistential?‚Äù&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;This section is a bit more technical; feel free to skip it if you like.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Why ‚Äúexistential?‚Äù Because the Transport protocol asserts that there &lt;em&gt;exists&lt;/em&gt; some type that satisfies its requirements. By ‚Äúsome type,‚Äù I mean ‚Äúin the universe of all possible types,‚Äù not ‚Äútypes that happen to be in your program.‚Äù That assertion may be wrong. It‚Äôs possible to define a protocol that nothing could ever conform to. For example:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Impossible&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(If you don‚Äôt believe me, spend some time trying to implement &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt;. You need to return an instance of &lt;em&gt;whatever&lt;/em&gt; the caller requests.)&lt;/p&gt;

&lt;p&gt;An existential container is a placeholder box for some unknown type that satisfies the protocol. It‚Äôs possible there is no such type, or there may not be any such type in your program. Nothing can be done with it at runtime until a real, concrete value, a &lt;em&gt;witness&lt;/em&gt;, is put in the box. The existence of a witness proves that such a type really does exist.&lt;/p&gt;

&lt;p&gt;This implicit box isn‚Äôt the only example of an existential in Swift. The ‚ÄúAny‚Äù types like AnySequence, AnyHashable, and AnyKeyPath often get called ‚Äútype-erasers‚Äù because they hide the concrete type, but they‚Äôre also explicit existentials. &lt;a href=&quot;https://forums.swift.org/t/improving-the-ui-of-generics/22814#heading--clarifying-existentials&quot;&gt;In future Swift,&lt;/a&gt; we may spell implicit existentials as &lt;code class=&quot;highlighter-rouge&quot;&gt;any Transport&lt;/code&gt; to parallel the explicit spelling.&lt;/p&gt;

&lt;p&gt;While protocols create existential (‚Äúthere exists‚Äù) types, generics create universal (‚Äúfor all‚Äù) types. When you write &lt;code class=&quot;highlighter-rouge&quot;&gt;struct Array&amp;lt;Element&amp;gt; {...}&lt;/code&gt;, that‚Äôs an assertion that ‚Äúfor all types (Element), there is another type (Array&amp;lt;Element&amp;gt;) with the following attributes‚Ä¶.‚Äù&lt;/p&gt;

&lt;p&gt;Existentials and universals are ‚Äúduals,‚Äù which means that one can be transformed into the other without losing its structure. So AnySequence is a universal type (generic) that‚Äôs equivalent to an explicit existential of Sequence (protocol). That‚Äôs why when you run into problems with protocols, your solution may be to convert it into generic structs (or vice versa). They solve the same problems in different ways with different trade-offs.&lt;/p&gt;

&lt;h2 id=&quot;copy-values-or-code&quot;&gt;Copy values or code?&lt;/h2&gt;

&lt;p&gt;If you have a function with a parameter whose type is a protocol, that really means it requires an existential of that protocol.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Transport&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;transmit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;over&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;transport&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Transport&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In order to call &lt;code class=&quot;highlighter-rouge&quot;&gt;transmit&lt;/code&gt; with URLSession, Swift needs to copy the URLSession into an existential, and then pass that to &lt;code class=&quot;highlighter-rouge&quot;&gt;transmit&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What if you used a generic function instead?&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transmit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Transport&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;over&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;transport&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This says that the caller gets to decide the type of T. If they pass URLSession, then the compiler creates an implicit overload:&lt;/p&gt;

&lt;pre&gt;
func transmit(data: Data, over transport: &lt;span class=&quot;chl&quot;&gt;URLSession&lt;/span&gt;) { ... }
&lt;/pre&gt;

&lt;p&gt;If somewhere else in the code they pass TestTransport, then the compiler creates another overload:&lt;/p&gt;

&lt;pre&gt;
func transmit(data: Data, over transport: &lt;span class=&quot;chl&quot;&gt;TestTransport&lt;/span&gt;) { ... }
&lt;/pre&gt;

&lt;p&gt;The entire &lt;code class=&quot;highlighter-rouge&quot;&gt;transmit&lt;/code&gt; function is (in principle) copied, just as if you‚Äôd written an overload &lt;code class=&quot;highlighter-rouge&quot;&gt;transmit&lt;/code&gt; for each type. This is an over-simplification, and the compiler may not actually make all the copies, or it may generate an existential version instead (or in addition). It depends on a lot of things, including the optimization flags. But when you call a generic function, you should think of it as creating a new version of the function written specifically for the type you called it with.&lt;sup id=&quot;fnref:performance&quot;&gt;&lt;a href=&quot;#fn:performance&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;In an existential (protocol parameter) function, the parameters may need to be copied into an existential at &lt;em&gt;run-time&lt;/em&gt;.&lt;/li&gt;
  &lt;li&gt;In a generic function, duplicate copies of the code may be generated at &lt;em&gt;compile-time&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This run-time/compile-time distinction is a key difference between existentials and generics. Existentials are containers that are filled at run-time. Generics are compile-time functions for generating new code.&lt;/p&gt;

&lt;p&gt;Existentials are used when you need to store heterogeneous values that are only known at run-time, for example in a heterogeneous collection.&lt;/p&gt;

&lt;p&gt;Generics are used to apply algorithms to types that are known at compile-time. Protocols constrain what types can be used with those generics.&lt;/p&gt;

&lt;p&gt;You don‚Äôt pass ‚Äúa protocol value‚Äù to a function. You pass the existential of the protocol. Because Swift often converts concrete types into existentials for you, it‚Äôs easy to forget that they‚Äôre not the same thing. So when Swift doesn‚Äôt perform the conversion, it comes as a surprise, and we get the ‚Äúcan only be used as a generic constraint‚Äù (i.e. ‚Äúas a protocol‚Äù) error.&lt;/p&gt;

&lt;h2 id=&quot;what-if-we-made-things-more-generallyumexistential&quot;&gt;What if we made things more generally‚Ä¶um‚Ä¶existential?&lt;/h2&gt;

&lt;p&gt;So couldn‚Äôt Swift just create an existential all the time, even for protocols with associated types (PATs)? Yes, but‚Ä¶it‚Äôs complicated. For the most common cases, yes, Swift could automatically create an &lt;code class=&quot;highlighter-rouge&quot;&gt;any Collection&amp;lt;.Element == T&amp;gt;&lt;/code&gt;&lt;sup id=&quot;fnref:protocol-syntax&quot;&gt;&lt;a href=&quot;#fn:protocol-syntax&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; implicit existential just like it currently has an &lt;code class=&quot;highlighter-rouge&quot;&gt;AnyCollection&amp;lt;T&amp;gt;&lt;/code&gt; explicit existential. That idea is called &lt;em&gt;generalized existentials&lt;/em&gt;, and I‚Äôm pretty certain Swift will add it eventually (maybe even soon). That‚Äôll knock off several of protocols‚Äô sharp edges for some of the most common cases.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;pullquote-right&quot; data-pullquote=&quot;Many protocol problems I see in the wild are really just design problems that have little to do with missing Swift features.&quot;&gt;
But it probably won‚Äôt solve as many problems as people expect. Many protocol problems I see in the wild are really just design problems that have little to do with missing Swift features. A generalized existential will get you past the compiler error, but in the process it may let you go much further down a wrong road.
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;And there are many kinds of types that don‚Äôt lend themselves to automatically-generated existentials. The compiler can‚Äôt fulfill an &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; requirement or any &lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt; requirements on its own. It needs help from the programmer to determine what the default implementations are. It‚Äôs similar for protocols with a Self requirement. It may not always be possible to create a sensible default implementation. For protocols like Decodable that have no instance methods, an existential may not make sense at all.&lt;/p&gt;

&lt;h2 id=&quot;why-you-gotta-talk-about-math-so-much&quot;&gt;Why you gotta talk about math so much?&lt;/h2&gt;

&lt;p&gt;As Joe said, the hope was that existentials wouldn‚Äôt really matter. They‚Äôre created by the compiler, you can‚Äôt access them, and you can‚Äôt even refer to them directly in the language today. You‚Äôd think they‚Äôd be an implementation detail. But sometimes when you type the name of a protocol you mean the protocol and sometimes you mean the box, and sometimes that matters. We‚Äôd like to ignore reference counting, too, and mostly we can‚Ä¶except when we can‚Äôt.&lt;/p&gt;

&lt;p&gt;The point of a protocol is algorithms. Protocols express what a type must be able to do in order to be used in certain ways. Ideally, protocols should have a very small number of requirements, and enable a large number of extensions and generic functions. A good protocol is short, but shows up in a lot of &lt;code class=&quot;highlighter-rouge&quot;&gt;where&lt;/code&gt; clauses and extensions. They‚Äôre fundamentally about compile-time type concerns. ‚ÄúI want to apply this algorithm to many different concrete types.‚Äù&lt;/p&gt;

&lt;p&gt;The point of an existential is heterogeneous collections, or ‚Äútype-erasure‚Äù where you want to know less about the specific type and just use it according to an interface. They‚Äôre fundamentally about run-time values. ‚ÄúI want to assign values of many different concrete types to this variable.‚Äù&lt;/p&gt;

&lt;p&gt;They‚Äôre not unrelated, but they‚Äôre not the same thing. When I say &lt;a href=&quot;/nonconformist&quot;&gt;‚Äúprotocols do not (generally) conform to protocols,‚Äù&lt;/a&gt; I &lt;em&gt;really&lt;/em&gt; mean ‚Äúexistentials do not (generally) conform to protocols.‚Äù And when you see ‚Äúcan only be used as a generic constraint,‚Äù what the compiler is really telling you is that protocols with associated types (PATs) don‚Äôt have an existential.&lt;/p&gt;

&lt;h2 id=&quot;so-what-about-these-opaque-result-things&quot;&gt;So what about these opaque result things?&lt;/h2&gt;

&lt;p&gt;My hope is that after reading all this, you‚Äôll feel more comfortable reading &lt;a href=&quot;https://github.com/apple/swift-evolution/blob/master/proposals/0244-opaque-result-types.md&quot;&gt;SE-244&lt;/a&gt;, which adds opaque return types in Swift 5.1. I don‚Äôt expect opaque return types to be an important feature for most developers. Please don‚Äôt assume you need to rewrite your code to use them. The problems they solve impact stdlib much more than day-to-day app development in my opinion. Looking over my code, I haven‚Äôt found a single place I want to use one.&lt;/p&gt;

&lt;p&gt;The importance of SE-244 isn‚Äôt opaque return types. It‚Äôs that it lays the groundwork for the future of Swift generic code. If that interests you, then you definitely want to study it, and in particular get comfortable with &lt;code class=&quot;highlighter-rouge&quot;&gt;any P&lt;/code&gt; (an existential) versus &lt;code class=&quot;highlighter-rouge&quot;&gt;some P&lt;/code&gt; (an unknown but concrete type that conforms). Hopefully this article demystifies some of the terminology.&lt;/p&gt;

&lt;p&gt;Next time, back to the networking stack and hopefully some more practical concerns.&lt;/p&gt;

&lt;hr /&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:performance&quot;&gt;
      &lt;p&gt;All these ‚Äúmay‚Äù qualifiers are why you shouldn‚Äôt assume that protocols or generics are ‚Äúbetter for performance‚Äù (for whatever meaning you‚Äôre attaching to ‚Äúperformance‚Äù). It depends on a lot of things. If your code is sensitive to the performance of generics or protocols, you need to profile it and look at what the compiler is actually generating. Do not take away from this discussion that ‚Äúgenerics are faster‚Äù or ‚Äúprotocols create smaller binaries.‚Äù That might be true in certain cases, but it can also be the other way around. Write you code clearly and correctly, and say what you mean in types. The Swift compiler teams works very hard to make sure that kind of code will be performant. Don‚Äôt guess what the compiler will do. Test.¬†&lt;a href=&quot;#fnref:performance&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:protocol-syntax&quot;&gt;
      &lt;p&gt;For an introduction to that proposed syntax, see the &lt;a href=&quot;https://forums.swift.org/t/protocol-assoctype-t-shorthand-for-combined-protocol-and-associated-type-constraints-without-naming-the-constrained-type/21217&quot;&gt;Protocol&amp;lt;.AssocType == T&amp;gt; shorthand&lt;/a&gt; forum thread.¬†&lt;a href=&quot;#fnref:protocol-syntax&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Rob Napier</name></author><summary type="html">This was supposed to be a quick sidebar, but it turned into a full-length article, so I‚Äôm calling it part 3. The original part 3, continuing the network stack, is mostly done, but I wanted to explain this weird word ‚Äúexistentials‚Äù first, and it turned out longer than I‚Äôd expected. Blame Joe Groff; he‚Äôs written too much interesting stuff lately and I want to talk about it. If you‚Äôre interested in the future of generics in Swift, Joe Groff has a must-read post called Improving the UI of generics. (You should also read the linked Generics Manifesto for background.) In it, he touches on a common confusion in Swift. If you don‚Äôt understand what he‚Äôs talking about here, don‚Äôt worry. Explaining this paragraph is the point of this article. We gave existential types an extremely lightweight spelling, just the bare protocol name, partially following the example of other languages like Java and C# where interfaces also serve as value-abstracted types, and partially out of a hope that they would ‚Äújust work‚Äù the way people expect; if you want a type that can hold any type conforming to a protocol, just use the protocol as a type, and you don‚Äôt have to know what ‚Äúexistential‚Äù means or anything like that. In practice, for a number of reasons, this hasn‚Äôt worked out as smoothly as we had originally hoped. Although the syntax strongly suggests that the protocol as a constraint and the protocol as a type are one thing, in practice, they‚Äôre related but different things, and this manifests most confusingly in the ‚ÄúProtocol (the type) does not to conform to Protocol (the constraint)‚Äù error. Spelling? In programming languages, the ‚Äúspelling‚Äù of something is the sequence of characters a programmer would type to represent a concept. This is often the most visible and argued-over part of a language. It‚Äôs also often a fairly shallow concern to the design, which is why it‚Äôs common to use intentionally bad ‚Äústraw man‚Äù names to discuss a concept without getting bogged down in spelling. Consider the concept ‚Äútrue if x or y, otherwise false.‚Äù Swift spells that x || y. In SML the same concept is spelled x orelse y. But the spelling difference, the difference between the characters || and orelse, isn‚Äôt very important. It doesn‚Äôt tell you much about how the language works. A more interesting difference, at least to me, is that || is a stdlib function in Swift, while orelse is hard-coded into the SML compiler, which would likely be true no matter how they were spelled. In English, some spellings have multiple meanings. The same thing happens in programming languages, and it happened in the last article: final class AddHeaders: Transport { let base: Transport ... } The spelling ‚ÄúTransport‚Äù has two related, but distinct, meanings. The first refers to the protocol Transport. The second refers to the existential of Transport. Existential? The ‚Äúexistential of a protocol‚Äù can mean several things, but here it refers to a compiler-generated box that holds a value that conforms to the protocol. To see why Swift needs this box, consider an Array of Transports: // URLSession and TestTransport both conform to Transport var transports: [Transport] = [URLSession.shared, TestTransport(...)] Swift would like to store Arrays contiguously in memory. So for an Array of Ints, the storage looks like this: +---+---+---+ | 0 | 1 | 2 | +---+---+---+ There are no pointers or indirection. The Ints are stored one after the other. To find the offset of index 2, you just have to multiply the size of an Int times two. That‚Äôs really fast and how you probably expect Arrays to work. Swift does the same thing for structs. It just lays them out field after field (there might be some padding, but that‚Äôs not important here). struct S { let a: Int let b: Int } ++--------+--------++--------+--------++--------+--------++ || S[0].a | S[0].b || S[1].a | S[1].b || S[2].a | S[2].b || ++--------+--------++--------+--------++--------+--------++ Again, to find the offset of S[2], Swift just has to multiply two times the size of S (which is the same as two Ints). But what happens in a ‚Äúprotocol-typed‚Äù Array like [Transport]? Each element might be a different size. What can Swift do? It makes a box that‚Äôs a fixed size (currently five machine words, with three for storage). If the type can fit in the box, then it‚Äôs stored in the box. If it can‚Äôt fit, then the compiler allocates some space, copies the data there, and puts a pointer in the box. Reference types are already pointers, so it just puts the pointer in the box. In Swift, that box is called an existential container. The thing in the box is called a witness. See WWDC 2016: Understanding Swift Performance for more on the implementation details. Sure, but ‚Äúexistential?‚Äù This section is a bit more technical; feel free to skip it if you like. Why ‚Äúexistential?‚Äù Because the Transport protocol asserts that there exists some type that satisfies its requirements. By ‚Äúsome type,‚Äù I mean ‚Äúin the universe of all possible types,‚Äù not ‚Äútypes that happen to be in your program.‚Äù That assertion may be wrong. It‚Äôs possible to define a protocol that nothing could ever conform to. For example: protocol Impossible { func make&amp;lt;A&amp;gt;() -&amp;gt; A } (If you don‚Äôt believe me, spend some time trying to implement make. You need to return an instance of whatever the caller requests.) An existential container is a placeholder box for some unknown type that satisfies the protocol. It‚Äôs possible there is no such type, or there may not be any such type in your program. Nothing can be done with it at runtime until a real, concrete value, a witness, is put in the box. The existence of a witness proves that such a type really does exist. This implicit box isn‚Äôt the only example of an existential in Swift. The ‚ÄúAny‚Äù types like AnySequence, AnyHashable, and AnyKeyPath often get called ‚Äútype-erasers‚Äù because they hide the concrete type, but they‚Äôre also explicit existentials. In future Swift, we may spell implicit existentials as any Transport to parallel the explicit spelling. While protocols create existential (‚Äúthere exists‚Äù) types, generics create universal (‚Äúfor all‚Äù) types. When you write struct Array&amp;lt;Element&amp;gt; {...}, that‚Äôs an assertion that ‚Äúfor all types (Element), there is another type (Array&amp;lt;Element&amp;gt;) with the following attributes‚Ä¶.‚Äù Existentials and universals are ‚Äúduals,‚Äù which means that one can be transformed into the other without losing its structure. So AnySequence is a universal type (generic) that‚Äôs equivalent to an explicit existential of Sequence (protocol). That‚Äôs why when you run into problems with protocols, your solution may be to convert it into generic structs (or vice versa). They solve the same problems in different ways with different trade-offs. Copy values or code? If you have a function with a parameter whose type is a protocol, that really means it requires an existential of that protocol. protocol Transport { ... } func transmit(data: Data, over transport: Transport) { ... } In order to call transmit with URLSession, Swift needs to copy the URLSession into an existential, and then pass that to transmit. What if you used a generic function instead? func transmit&amp;lt;T: Transport&amp;gt;(data: data, over transport: T) { ... } This says that the caller gets to decide the type of T. If they pass URLSession, then the compiler creates an implicit overload: func transmit(data: Data, over transport: URLSession) { ... } If somewhere else in the code they pass TestTransport, then the compiler creates another overload: func transmit(data: Data, over transport: TestTransport) { ... } The entire transmit function is (in principle) copied, just as if you‚Äôd written an overload transmit for each type. This is an over-simplification, and the compiler may not actually make all the copies, or it may generate an existential version instead (or in addition). It depends on a lot of things, including the optimization flags. But when you call a generic function, you should think of it as creating a new version of the function written specifically for the type you called it with.1 In an existential (protocol parameter) function, the parameters may need to be copied into an existential at run-time. In a generic function, duplicate copies of the code may be generated at compile-time. This run-time/compile-time distinction is a key difference between existentials and generics. Existentials are containers that are filled at run-time. Generics are compile-time functions for generating new code. Existentials are used when you need to store heterogeneous values that are only known at run-time, for example in a heterogeneous collection. Generics are used to apply algorithms to types that are known at compile-time. Protocols constrain what types can be used with those generics. You don‚Äôt pass ‚Äúa protocol value‚Äù to a function. You pass the existential of the protocol. Because Swift often converts concrete types into existentials for you, it‚Äôs easy to forget that they‚Äôre not the same thing. So when Swift doesn‚Äôt perform the conversion, it comes as a surprise, and we get the ‚Äúcan only be used as a generic constraint‚Äù (i.e. ‚Äúas a protocol‚Äù) error. What if we made things more generally‚Ä¶um‚Ä¶existential? So couldn‚Äôt Swift just create an existential all the time, even for protocols with associated types (PATs)? Yes, but‚Ä¶it‚Äôs complicated. For the most common cases, yes, Swift could automatically create an any Collection&amp;lt;.Element == T&amp;gt;2 implicit existential just like it currently has an AnyCollection&amp;lt;T&amp;gt; explicit existential. That idea is called generalized existentials, and I‚Äôm pretty certain Swift will add it eventually (maybe even soon). That‚Äôll knock off several of protocols‚Äô sharp edges for some of the most common cases. But it probably won‚Äôt solve as many problems as people expect. Many protocol problems I see in the wild are really just design problems that have little to do with missing Swift features. A generalized existential will get you past the compiler error, but in the process it may let you go much further down a wrong road. And there are many kinds of types that don‚Äôt lend themselves to automatically-generated existentials. The compiler can‚Äôt fulfill an init requirement or any static requirements on its own. It needs help from the programmer to determine what the default implementations are. It‚Äôs similar for protocols with a Self requirement. It may not always be possible to create a sensible default implementation. For protocols like Decodable that have no instance methods, an existential may not make sense at all. Why you gotta talk about math so much? As Joe said, the hope was that existentials wouldn‚Äôt really matter. They‚Äôre created by the compiler, you can‚Äôt access them, and you can‚Äôt even refer to them directly in the language today. You‚Äôd think they‚Äôd be an implementation detail. But sometimes when you type the name of a protocol you mean the protocol and sometimes you mean the box, and sometimes that matters. We‚Äôd like to ignore reference counting, too, and mostly we can‚Ä¶except when we can‚Äôt. The point of a protocol is algorithms. Protocols express what a type must be able to do in order to be used in certain ways. Ideally, protocols should have a very small number of requirements, and enable a large number of extensions and generic functions. A good protocol is short, but shows up in a lot of where clauses and extensions. They‚Äôre fundamentally about compile-time type concerns. ‚ÄúI want to apply this algorithm to many different concrete types.‚Äù The point of an existential is heterogeneous collections, or ‚Äútype-erasure‚Äù where you want to know less about the specific type and just use it according to an interface. They‚Äôre fundamentally about run-time values. ‚ÄúI want to assign values of many different concrete types to this variable.‚Äù They‚Äôre not unrelated, but they‚Äôre not the same thing. When I say ‚Äúprotocols do not (generally) conform to protocols,‚Äù I really mean ‚Äúexistentials do not (generally) conform to protocols.‚Äù And when you see ‚Äúcan only be used as a generic constraint,‚Äù what the compiler is really telling you is that protocols with associated types (PATs) don‚Äôt have an existential. So what about these opaque result things? My hope is that after reading all this, you‚Äôll feel more comfortable reading SE-244, which adds opaque return types in Swift 5.1. I don‚Äôt expect opaque return types to be an important feature for most developers. Please don‚Äôt assume you need to rewrite your code to use them. The problems they solve impact stdlib much more than day-to-day app development in my opinion. Looking over my code, I haven‚Äôt found a single place I want to use one. The importance of SE-244 isn‚Äôt opaque return types. It‚Äôs that it lays the groundwork for the future of Swift generic code. If that interests you, then you definitely want to study it, and in particular get comfortable with any P (an existential) versus some P (an unknown but concrete type that conforms). Hopefully this article demystifies some of the terminology. Next time, back to the networking stack and hopefully some more practical concerns. All these ‚Äúmay‚Äù qualifiers are why you shouldn‚Äôt assume that protocols or generics are ‚Äúbetter for performance‚Äù (for whatever meaning you‚Äôre attaching to ‚Äúperformance‚Äù). It depends on a lot of things. If your code is sensitive to the performance of generics or protocols, you need to profile it and look at what the compiler is actually generating. Do not take away from this discussion that ‚Äúgenerics are faster‚Äù or ‚Äúprotocols create smaller binaries.‚Äù That might be true in certain cases, but it can also be the other way around. Write you code clearly and correctly, and say what you mean in types. The Swift compiler teams works very hard to make sure that kind of code will be performant. Don‚Äôt guess what the compiler will do. Test.¬†&amp;#8617; For an introduction to that proposed syntax, see the Protocol&amp;lt;.AssocType == T&amp;gt; shorthand forum thread.¬†&amp;#8617;</summary></entry><entry><title type="html">Protocols II: A mockery of protocols</title><link href="https://robnapier.net/a-mockery-of-protocols" rel="alternate" type="text/html" title="Protocols II: A mockery of protocols" /><published>2019-04-29T11:18:00-04:00</published><updated>2019-04-29T11:18:00-04:00</updated><id>https://robnapier.net/a-mockery-of-protocols</id><content type="html" xml:base="https://robnapier.net/a-mockery-of-protocols">&lt;p&gt;&lt;a href=&quot;/start-with-a-protocol&quot;&gt;In the last section&lt;/a&gt;, I ended my little network stack at this point:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Something that can be fetched from the API&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Fetchable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Decodable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;apiBase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// The part of the URL for this type&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// A client that fetches things from the API&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;APIClient&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;baseURL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;https://www.example.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;session&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URLSession&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URLSession&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shared&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Fetch any Fetchable type given an ID, and return it asynchronously&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Fetchable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                 &lt;span class=&quot;nv&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;@escaping&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Construct the URLRequest&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;baseURL&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;appendingPathComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;apiBase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;appendingPathComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;urlRequest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URLRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Send it to URLSession&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;session&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;dataTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;urlRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;JSONDecoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
                &lt;span class=&quot;nf&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;resume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This can decode any Fetchable model from an API endpoint that has a URL something like &lt;code class=&quot;highlighter-rouge&quot;&gt;https://&amp;lt;base&amp;gt;/&amp;lt;model&amp;gt;/&amp;lt;id&amp;gt;&lt;/code&gt;. That‚Äôs pretty good, but we can do a lot better. A natural first question is ‚Äúhow do I test it?‚Äù It relies explicitly on URLSession, which is very hard to test against. A natural approach would be to create a protocol to mock URLSession.&lt;/p&gt;

&lt;p&gt;I hope by the time you‚Äôre done with this series, hearing ‚Äúcreate a protocol to mock‚Äù makes you flinch just a little.
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;pullquote-right&quot; data-pullquote=&quot;If the only reason you can imagine using a protocol is for testing, then you&amp;#8217;re not getting all you could out of it.&quot;&gt;
The basic premise of a mock is to build a test object that mimics some other object you want to replace. That encourages you to design a protocol that very closely matches the existing interface, and then your ‚Äúmock object‚Äù will also closely match that interface. This makes your ‚Äúreal‚Äù object, the protocol, and the mock evolve tightly in lockstep, and it cuts off opportunities for more powerful protocols that aren‚Äôt tied to one implementation. If the only reason you can imagine using a protocol is for testing, then you‚Äôre not getting all you could out of it. Protocols can be so much more.
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;So my goal isn‚Äôt to ‚Äúmock‚Äù URLSession, but to abstract the functionality I need. What I want is to map a URLRequest to Data, asynchronously:&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// A transport maps a URLRequest to Data, asynchronously&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Transport&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URLRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;@escaping&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Notice that nothing about that says ‚ÄúHTTP server over the network.‚Äù Anything that can map a URLRequest to Data asynchronously is fine. It could be a database. It could be static unit test data. It could be flat files. It could be different routes depending on the scheme.&lt;/p&gt;

&lt;p&gt;Now comes the power of retroactive modeling. I can extend URLSession to be a Transport:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URLSession&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Transport&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URLRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;@escaping&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;dataTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;resume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And then anything that requires a Transport can use a URLSession directly. No need for wrappers or adapters. It just works, even though URLSession is a Foundation type and Apple doesn‚Äôt know anything about my Transport protocol. A few lines of code and it just works, without giving up any of the power of URLSession.&lt;/p&gt;

&lt;style&gt;
    .chl { color: yellow; } /* code highlight */
&lt;/style&gt;

&lt;p&gt;With that in place, &lt;code class=&quot;highlighter-rouge&quot;&gt;APIClient&lt;/code&gt; can use Transport rather than URLSession.&lt;/p&gt;

&lt;pre&gt;
final class APIClient {
    let baseURL = URL(string: &amp;quot;https://www.example.com&amp;quot;)!
    &lt;span class=&quot;chl&quot;&gt;let transport: Transport&lt;/span&gt;   

    &lt;span class=&quot;chl&quot;&gt;init(transport: Transport = URLSession.shared) { self.transport = transport }&lt;/span&gt;

    // Fetch any Fetchable type given an ID, and return it asynchronously
    func fetch&amp;lt;Model: Fetchable&amp;gt;(_ model: Model.Type, id: Int,
                                 completion: @escaping (Result&amp;lt;Model, Error&amp;gt;) -&amp;gt; Void)
    {
        // Construct the URLRequest
        let url = baseURL
            .appendingPathComponent(Model.apiBase)
            .appendingPathComponent(&amp;quot;\(id)&amp;quot;)
        let urlRequest = URLRequest(url: url)

        // Send it to the transport
        &lt;span class=&quot;chl&quot;&gt;transport.send(request: urlRequest) { data in
            let result = Result { try JSONDecoder().decode(Model.self, from: data.get()) }
            completion(result)
        }&lt;/span&gt;
    }
}
&lt;/pre&gt;

&lt;p&gt;By using a default value in &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;, callers can still use the &lt;code class=&quot;highlighter-rouge&quot;&gt;APIClient()&lt;/code&gt; syntax if they want the standard network transport.&lt;/p&gt;

&lt;p&gt;Transport is a lot more powerful than just ‚Äúa URLSession mock.‚Äù It‚Äôs a function that converts URLRequests into Data. That means it can be composed. I can build a Transport that wraps other Transports. For example, I can build a Transport that adds headers to every request.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Add headers to an existing transport&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AddHeaders&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Transport&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Transport&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;headers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

    &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Transport&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;headers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;base&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;headers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;headers&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URLRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;@escaping&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;newRequest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;headers&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;addValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;forHTTPHeaderField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;transport&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AddHeaders&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URLSession&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                           &lt;span class=&quot;nv&quot;&gt;headers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Authorization&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;...&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now, rather than having every request deal with authorization, that can be centralized to a single Transport transparently. If the authorization token changes, then I can update a single object, and all future requests will get the right headers. But this is still unit testable (even the AddHeaders part). I can swap in whatever lower-level Transport I want.&lt;/p&gt;

&lt;p&gt;This means I can extend existing systems in a really flexible way. I can add encryption or logging or caching or priority queues or automatic retries or whatever without intermingling that with the actual network layer. I can tunnel all the network traffic over a custom VPN protocol (I‚Äôve done exactly that with a system like this), all without losing the ability to unit test. So yes, I get mocks, yes, I get unit testing, but I get so much more.&lt;/p&gt;

&lt;p&gt;For completeness, here‚Äôs a ‚Äúmock‚Äù Transport, but it‚Äôs probably the least interesting thing we can do with this protocol.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// A transport that returns static values for tests&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TestTransportError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Swift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tooManyRequests&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TestTransport&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Transport&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;history&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;URLRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;responseData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

    &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;responseData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;responseData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;responseData&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URLRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;@escaping&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;history&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;responseData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isEmpty&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;responseData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;removeFirst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;TestTransportError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tooManyRequests&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And I still haven‚Äôt used an associated type or a Self requirement. Transport doesn‚Äôt need any of that. It‚Äôs not even generic.&lt;/p&gt;

&lt;h2 id=&quot;common-currency&quot;&gt;Common currency&lt;/h2&gt;

&lt;p&gt;The split between a &lt;code class=&quot;highlighter-rouge&quot;&gt;APIClient.fetch&lt;/code&gt;, which is generic, and &lt;code class=&quot;highlighter-rouge&quot;&gt;Transport.send&lt;/code&gt;, which is not, is a common structure that I look for. &lt;code class=&quot;highlighter-rouge&quot;&gt;Transport.send&lt;/code&gt; operates on a small set of concrete types: URLRequest in, Data out. When you‚Äôre working with a small set of concrete types, then composition is easy. Anything that can generate a URLRequest or can consume Data can participate. &lt;code class=&quot;highlighter-rouge&quot;&gt;APIClient.fetch&lt;/code&gt; converts Data into any kind of generic Fetchable. When angle-brackets and associated types start creeping in, the code becomes more expressive, but harder to compose because you have to make sure all the types line up.&lt;/p&gt;

&lt;p&gt;The power of the Internet is that it mostly operates on just one type: the packet. It doesn‚Äôt care what‚Äôs in the packet or what the packet ‚Äúmeans.‚Äù It just moves packets from one place to another; packets in, packets out. And that‚Äôs why the Internet is so flexible, and the equipment that makes it work can be implemented by numerous vendors in wildly different ways, and they can all work together.&lt;/p&gt;

&lt;p&gt;At each layer above the network layer, additional context and meaning is applied to the information. It‚Äôs interpreted as user information or commands to execute or video to display. That‚Äôs composition, gluing together independent layers, each with their own concerns. When designing protocols, I try to employ the same approach. Particularly at the lowest layers I look for common, concrete types to work with. URL and URLRequest. Data and Int. Simple functions like &lt;code class=&quot;highlighter-rouge&quot;&gt;() -&amp;gt; Void&lt;/code&gt;. As I move up the stack, then greater meaning is applied to the data in the form of model types and the like. That means it‚Äôs easy to write Transports and many different things can use Transports. And that‚Äôs the goal.&lt;/p&gt;

&lt;p&gt;This network stack still is nowhere near as flexible and powerful as I want. But now it can fetch a wide variety of model types from a particular type of API in a very composable and testable way. That‚Äôs great progress. For some very simple APIs, it might even be done. There‚Äôs no need to make it more flexible for its own sake. But I think we‚Äôll quickly find more features we need to add.&lt;/p&gt;

&lt;p&gt;Next time, I‚Äôll jump back up to the very top of the stack, to the models, and show where a PAT (protocol with associated type) can really shine.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/protocols/StartWithAProtocol.zip&quot;&gt;Swift Playground&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;Throughout this series, whenever it‚Äôs unambiguous, I‚Äôll refer to &lt;code class=&quot;highlighter-rouge&quot;&gt;Result&amp;lt;Value, Error&amp;gt;&lt;/code&gt; as just ‚ÄúValue.‚Äù¬†&lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Rob Napier</name></author><summary type="html">In the last section, I ended my little network stack at this point: // Something that can be fetched from the API protocol Fetchable: Decodable { static var apiBase: String { get } // The part of the URL for this type } // A client that fetches things from the API final class APIClient { let baseURL = URL(string: &quot;https://www.example.com&quot;)! let session: URLSession = URLSession.shared // Fetch any Fetchable type given an ID, and return it asynchronously func fetch&amp;lt;Model: Fetchable&amp;gt;(_ model: Model.Type, id: Int, completion: @escaping (Result&amp;lt;Model, Error&amp;gt;) -&amp;gt; Void) { // Construct the URLRequest let url = baseURL .appendingPathComponent(Model.apiBase) .appendingPathComponent(&quot;\(id)&quot;) let urlRequest = URLRequest(url: url) // Send it to URLSession let task = session.dataTask(with: urlRequest) { (data, _, error) in if let error = error { completion(.failure(error)) } else if let data = data { let result = Result { try JSONDecoder().decode(Model.self, from: data) } completion(result) } } task.resume() } } This can decode any Fetchable model from an API endpoint that has a URL something like https://&amp;lt;base&amp;gt;/&amp;lt;model&amp;gt;/&amp;lt;id&amp;gt;. That‚Äôs pretty good, but we can do a lot better. A natural first question is ‚Äúhow do I test it?‚Äù It relies explicitly on URLSession, which is very hard to test against. A natural approach would be to create a protocol to mock URLSession. I hope by the time you‚Äôre done with this series, hearing ‚Äúcreate a protocol to mock‚Äù makes you flinch just a little.</summary></entry><entry><title type="html">Protocols Sidebar I: Protocols are nonconformists</title><link href="https://robnapier.net/nonconformist" rel="alternate" type="text/html" title="Protocols Sidebar I: Protocols are nonconformists" /><published>2019-04-28T12:43:00-04:00</published><updated>2019-04-28T12:43:00-04:00</updated><id>https://robnapier.net/nonconformist</id><content type="html" xml:base="https://robnapier.net/nonconformist">&lt;p&gt;&lt;a href=&quot;/start-with-a-protocol&quot;&gt;Last time&lt;/a&gt;, I mentioned something in passing:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I need a new protocol.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Fetchable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Decodable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;apiBase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;I need a protocol that requires that the type be Decodable, and also requires that it provide this extra string, &lt;code class=&quot;highlighter-rouge&quot;&gt;apiBase&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Read that again. It &lt;em&gt;requires&lt;/em&gt; that the type be Decodable and also &lt;em&gt;requires&lt;/em&gt; other things. I didn‚Äôt say that Fetchable &lt;em&gt;is&lt;/em&gt; Decodable. It isn‚Äôt.
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;protocols-do-not-conform&quot;&gt;Protocols do not conform&lt;/h2&gt;

&lt;p&gt;Protocols (with a few exceptions) do not conform to protocols, not even to themselves. A type that conforms to Fetchable, must also conform to Decodable, but Fetchable is not Decodable. Fetchable is not Fetchable. Decodable is not Decodable. Why do I keep repeating this. Because you will forget, and it will bite you. What would it mean if Decodable were Decodable?&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Decodable&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Well, remember that JSONDecoder‚Äôs &lt;code class=&quot;highlighter-rouge&quot;&gt;decode&lt;/code&gt; method requires a type that conforms to Decodable. If Decodable (or Fetchable) conformed to Decodable, I could write:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;JSONDecoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Decodable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And in fact, I see people try to write that all the time. But how could that possibly work? How can JSONDecoder know which of an unbounded number of possible types you want this JSON to be decoded into? Even if you did it, what could you possibly do with &lt;code class=&quot;highlighter-rouge&quot;&gt;result&lt;/code&gt;? It‚Äôs only known method would be &lt;code class=&quot;highlighter-rouge&quot;&gt;init(from: Decoder)&lt;/code&gt;. There are no instance methods on Decodable.&lt;/p&gt;

&lt;p&gt;And so again: Protocols do not conform to protocols, not even to themselves.&lt;/p&gt;

&lt;h2 id=&quot;when-will-it-bite-me&quot;&gt;When will it bite me?&lt;/h2&gt;

&lt;p&gt;When I say this bites people all the time, here‚Äôs a common example: Say you have a protocol and an extension on Array:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyProtocol&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Array&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyProtocol&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doThing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And then you have some array of MyProtocol:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;things&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;MyProtocol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You might imagine that you could call &lt;code class=&quot;highlighter-rouge&quot;&gt;things.doThing()&lt;/code&gt;. After all, &lt;code class=&quot;highlighter-rouge&quot;&gt;doThing()&lt;/code&gt; applies to any array of MyProtocol, and what‚Äôs more MyProtocol than MyProtocol? But that‚Äôs exactly what you can‚Äôt do. The syntax &lt;code class=&quot;highlighter-rouge&quot;&gt;where Element: MyProtocol&lt;/code&gt; means ‚ÄúElement conforms to MyProtocol.‚Äù And as I‚Äôve repeated many times now: MyProtocol does not conform to itself. In order to add an extension on &lt;code class=&quot;highlighter-rouge&quot;&gt;[MyProtocol]&lt;/code&gt;, you would need to write an extension with &lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt; rather than &lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Array&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyProtocol&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doThing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This says that Element &lt;em&gt;is exactly&lt;/em&gt; MyProtocol. That doesn‚Äôt include types that conform to MyProtocol. It only applies exactly to &lt;code class=&quot;highlighter-rouge&quot;&gt;[MyProtocol]&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;theres-always-usually-an-exception&quot;&gt;There‚Äôs &lt;strike&gt;always&lt;/strike&gt; usually an exception&lt;/h2&gt;

&lt;p&gt;OK, what about the exceptions? There &lt;em&gt;are&lt;/em&gt; a some protocols that do conform to themselves. &lt;code class=&quot;highlighter-rouge&quot;&gt;@objc&lt;/code&gt; protocols do unless they have ‚Äústatic‚Äù requirements such as &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;, or static properties or methods. And in Swift 5, Error conforms to itself so that you can have ‚Äúuntyped error‚Äù Results like &lt;code class=&quot;highlighter-rouge&quot;&gt;Result&amp;lt;T, Error&amp;gt;&lt;/code&gt;. If Error didn‚Äôt conform to itself, you‚Äôd have to use a concrete type for the error. But these are compiler-enforced special cases. You can‚Äôt make &lt;em&gt;your&lt;/em&gt; protocol conform to itself.&lt;/p&gt;

&lt;h2 id=&quot;impossible-or-just-not-implemented&quot;&gt;Impossible? Or just not implemented?&lt;/h2&gt;

&lt;p&gt;But could they? Yes, some could in principle. The rule is pretty straightforward: if a protocol includes an &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt; requirement, or includes a &lt;code class=&quot;highlighter-rouge&quot;&gt;Self&lt;/code&gt; method parameter, then self-conformance is tricky. If there is no such requirement, then it it‚Äôs much more straightforward (basically the same as for &lt;code class=&quot;highlighter-rouge&quot;&gt;@objc&lt;/code&gt;). There‚Äôs no deep reason that Encodable can‚Äôt be Encodable. The following could work, and I think would be both sensible and useful, it just doesn‚Äôt today:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;encodables&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Encodable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;json&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;JSONEncoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encodables&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Will this ever work? I don‚Äôt know. It‚Äôs been brought up a few times on &lt;a href=&quot;https://forums.swift.org/t/will-existentials-ever-conform-to-their-protocols/4919&quot;&gt;Swift Evolution&lt;/a&gt;, and hasn‚Äôt been rejected outright. One concern is that adding an &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; requirement to an existing protocol could break existing usage (possibly in downstream code) in ways that might surprise developers. I haven‚Äôt found a clear statement, but it seems the team wants to make this work someday.&lt;/p&gt;

&lt;p&gt;It‚Äôs even possible that ‚Äúchallenging‚Äù protocols could self-conform if there were default implementations. One could imagine a Swift where &lt;code class=&quot;highlighter-rouge&quot;&gt;Collection(1, 2, 3)&lt;/code&gt; would return an Array in a Collection existential. (I‚Äôm not suggesting that would be a good idea; I really don‚Äôt know. It‚Äôs just that it‚Äôs the kind of thing one could imagine.)&lt;/p&gt;

&lt;p&gt;In this series I‚Äôm generally going to talk about things I know from experience using today‚Äôs Swift or can predict about likely-near-term Swift (i.e. there‚Äôs an SE in the works). So any time I say something like ‚Äúthat won‚Äôt work,‚Äù I mean ‚Äúwithout adding a significant feature to Swift that I don‚Äôt know is planned.‚Äù (Hopefully folks will continue to correct me if I‚Äôm misleading about how hard something would be.)&lt;/p&gt;

&lt;h2 id=&quot;i-of-course-mean-existentials&quot;&gt;I of course mean ‚Äúexistentials‚Äù&lt;/h2&gt;

&lt;p&gt;I want to talk about this more later, but when I say ‚Äúa protocol doesn‚Äôt conform to itself,‚Äù it‚Äôs more accurate to say ‚Äúthe existential of a protocol doesn‚Äôt conform to that protocol.‚Äù But again, that‚Äôs for a later sidebar‚Ä¶. The thing to keep in mind is that these two things are different:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// This requires a concrete T that conforms to P&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;// This requires a variable of type P (pedantically: &quot;a P existential&quot;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So that‚Äôs just a quick side-bar. Next time, I‚Äôll continue expanding the network stack.&lt;/p&gt;</content><author><name>Rob Napier</name></author><summary type="html">Last time, I mentioned something in passing: I need a new protocol. protocol Fetchable: Decodable { static var apiBase: String { get } } I need a protocol that requires that the type be Decodable, and also requires that it provide this extra string, apiBase. Read that again. It requires that the type be Decodable and also requires other things. I didn‚Äôt say that Fetchable is Decodable. It isn‚Äôt.</summary></entry><entry><title type="html">Protocols I: ‚ÄúStart with a protocol,‚Äù he said</title><link href="https://robnapier.net/start-with-a-protocol" rel="alternate" type="text/html" title="Protocols I: &quot;Start with a protocol,&quot; he said" /><published>2019-04-22T00:00:00-04:00</published><updated>2019-04-22T00:00:00-04:00</updated><id>https://robnapier.net/start-with-a-protocol</id><content type="html" xml:base="https://robnapier.net/start-with-a-protocol">&lt;h2 id=&quot;in-the-beginning-crusty&quot;&gt;In the beginning, Crusty&lt;/h2&gt;

&lt;p&gt;In 2015, at WWDC, &lt;a href=&quot;https://twitter.com/DaveAbrahams&quot;&gt;Dave Abrahams&lt;/a&gt; gave what I believe is still the greatest Swift talk ever given, and certainly the most influential. &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2015/408/&quot;&gt;‚ÄùProtocol-Oriented Programming in Swift,‚Äù&lt;/a&gt; or as it is more affectionately known, ‚ÄúThe Crusty Talk.‚Äù&lt;/p&gt;

&lt;p&gt;This is the talk that introduced the phrase ‚Äúprotocol oriented programming.‚Äù The first time I watched it, I took away just one key phrase:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Start with a protocol.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;And so, dutifully, I started with a protocol. I made a UserProtocol and a DocumentProtocol and a ShapeProtocol and on and on, and then started implementing all those protocols with generic subclasses and eventually I found myself in a corner.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Protocol 'P' can only be used as a generic constraint because it has Self or associated type requirements
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And then I started throwing things.
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;For a couple of years, I was rather annoyed at the phrase ‚Äúprotocol-oriented programming.‚Äù If by ‚Äúprotocol‚Äù you just mean ‚Äúinterface,‚Äù then Go is much more ‚Äúprotocol oriented‚Äù than Swift. But the more I‚Äôve wrestled with this new paradigm, the more I realized that protocols are more than just interfaces, and POP isn‚Äôt deeply about the protocols anyway. It‚Äôs about the extensions. But ‚Äúextension-oriented programming‚Äù would be an even worse name. And more than extensions, it‚Äôs really, deeply, about generic algorithms. And ‚Äúalgorithm-oriented programming,‚Äù well, aren‚Äôt we all?&lt;/p&gt;

&lt;p&gt;Naming a paradigm is always fraught with trouble. Most modern ‚Äúobject-oriented‚Äù languages aren‚Äôt object-oriented at all. They‚Äôre class-oriented (vs Smalltalk and JavaScript). And most ‚Äúfunctional programming‚Äù languages are mostly value-oriented (vs FP and point-free). But the point of the names is shorthand for concepts bigger than a word, so let‚Äôs not get too caught up on the ‚Äúprotocol‚Äù in protocol-oriented programming. The Holy Roman Empire was in no way holy, nor Roman, nor an empire. Discuss.&lt;/p&gt;

&lt;h2 id=&quot;beware-quotes-traveling-sans-context&quot;&gt;Beware quotes traveling sans context&lt;/h2&gt;

&lt;p&gt;The famous ‚Äústart with a protocol‚Äù quote is actually the end of a longer paragraph:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;For example, if you want to write a generalized sort or binary search‚Ä¶Don‚Äôt start with a class. Start with a protocol.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Or as Dave &lt;a href=&quot;https://twitter.com/cocoaphony/status/1104114233288151043&quot;&gt;clarified on Twitter&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Use value types, then if you need polymorphism, make them conform to protocols.  Avoid classes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;If&lt;/em&gt; you‚Äôre reaching for class inheritance, try a protocol and value type instead. That‚Äôs very different from ‚Äústart with a protocol for every problem.‚Äù &lt;a href=&quot;https://twitter.com/AirspeedSwift&quot;&gt;Ben Cohen&lt;/a&gt; covered this in much more detail in the WWDC 2018 talk &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2018/406/&quot;&gt;Swift Generics (Expanded)&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;So notice that we considered a varied number of concrete types first. And now, we‚Äôre thinking about a kind of protocol that could join them all together. And, it‚Äôs important to think of things as this way around. To start with some concrete types, and then try and unify them with a protocol.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span class=&quot;pullquote-right&quot; data-pullquote=&quot;Write concrete code first. Then work out the generics.&quot;&gt;
If you take away just one thing from this series, I want it to be this: &lt;em&gt;Write concrete code first. Then work out the generics.&lt;/em&gt; Start with concrete types and clear use cases, and find the places that duplication happens. Then find abstractions. The power of protocol-oriented programming is that you don‚Äôt have to decide when you create a type exactly how it will be used. When you use class inheritance, you have to design your class hierarchy very early. But with protocols, you can wait until later.
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;When I most get into trouble with protocols is when I try to write code ‚Äúas generically as possible.‚Äù That doesn‚Äôt really mean anything. Abstractions are choices, and when you make a choice to be flexible in one direction, you generally make it harder to be flexible in other directions. Without some clear use cases, you don‚Äôt know what abstractions make sense.&lt;/p&gt;

&lt;p&gt;So today, I want to come to protocol-oriented programming fresh, with a focus on very every-day problems we face when developing iOS apps in Swift.&lt;/p&gt;

&lt;h2 id=&quot;setting-the-stage&quot;&gt;Setting the stage&lt;/h2&gt;

&lt;p&gt;Over the next several articles I‚Äôll be developing a very common system, a general-purpose networking stack that can fetch data asynchronously and decode arbitrary types. You may have built a system like this yourself in Swift. You may have used a framework that does it. The point of this exercise isn‚Äôt really the end result (though I think it‚Äôs quite useful code), but the process. What questions should you ask, and when, and how do you know what good answers look like? And most importantly, how does this ‚Äúprotocol-oriented‚Äù thing guide us? How is it different than other approaches?&lt;/p&gt;

&lt;p&gt;I expect that you‚Äôre somewhat familiar with Swift, and particularly that you understand the syntax of generic functions and types, and have at least seen an &lt;code class=&quot;highlighter-rouge&quot;&gt;associatedtype&lt;/code&gt; before. If you‚Äôre just getting started in Swift, maybe bookmark this series for later.&lt;/p&gt;

&lt;p&gt;So to get started, I want to show a common starting point that never goes well for me. I‚Äôve made this mistake many times, and I always find myself in a corner eventually. I see a lot of other people make this mistake, too.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// A network Request knows the URLRequest to fetch some data, and then can parse it.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// This will not go well.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Request&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;associatedtype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Response&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Response&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;urlRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URLRequest&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class=&quot;pullquote-right&quot; data-pullquote=&quot;will I ever want to put this in an Array?&quot;&gt;
How do I know this won‚Äôt go well? I‚Äôll discuss it much more in depth later, but Request is a protocol with associated type (PAT). Any time you create a PAT, you should ask yourself ‚Äúwill I ever want to put this in an Array?‚Äù If the answer is yes, you don‚Äôt want a PAT. Requests are certainly something you‚Äôd want to put in an Array. Lists of pending requests, lists of requests that need to be retried, request priority queues. There are lots of reasons to put a Request in an Array.
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;You might be tempted to look for a work-around, but don‚Äôt. Type-eraser? No. Generalized Existential?!?! ‚Ä¶no‚Ä¶ Even if you find some ‚Äúwork-around‚Äù to the problem at hand you‚Äôll run into other walls very quickly (and I‚Äôve seen that again and again). That ‚Äúcan only be used as a generic constraint‚Äù is telling you something important. This isn‚Äôt a problem with Swift. This just isn‚Äôt what PATs are for. There are other tools for this problem. In later articles I‚Äôll explain why you don‚Äôt want these work-arounds, but the basic problem is starting with a protocol before we even know what algorithm we want to write.&lt;/p&gt;

&lt;p&gt;So what does ‚Äúknow the algorithm‚Äù look like in practice?&lt;/p&gt;

&lt;h2 id=&quot;start-concrete&quot;&gt;Start concrete&lt;/h2&gt;

&lt;p&gt;A good way to find a generic algorithm is to start with several concrete algorithms, and then make a parameter out of what varies. In this case, I want to fetch several model types from an API and decode them. In order to start concretely, I‚Äôll make some actual types.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Codable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Hashable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Codable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Hashable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This may not be our final implementations, but they‚Äôre good enough to get started. They‚Äôre pretty similar, but not identical, and that‚Äôs good for the first concrete types. I‚Äôll want to push the envelope a bit more later, but this is good enough for now.&lt;/p&gt;

&lt;p&gt;I also want a client to manage my connection to the server. I‚Äôm marking classes ‚Äúfinal‚Äù to remind you that there‚Äôs no class inheritance here. I‚Äôm not suggesting you need to include ‚Äúfinal‚Äù on all your class definitions. It‚Äôs not usually necessary. I‚Äôm making it a reference type because the client might eventually have some shared state. For example, if a login step were required, I‚Äôd want all references to the client to be logged in together.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// A client that fetches things from the API&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;APIClient&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;baseURL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;https://www.example.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;session&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URLSession&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shared&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// ... methods to come ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And now I want the code to fetch and decode a User, as a method on APIClient.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fetchUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;@escaping&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Construct the URLRequest&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;baseURL&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;appendingPathComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;user&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;appendingPathComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;urlRequest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URLRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Send it to the URLSession&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;session&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;dataTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;urlRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
            &lt;span class=&quot;nf&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;JSONDecoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;resume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I‚Äôm sure many of you have written code kind of like this many times. Construct a URLRequest. Fetch it. Parse it. Pass it to the completion handler. Now, what does the code for &lt;code class=&quot;highlighter-rouge&quot;&gt;fetchDocument&lt;/code&gt; look like?&lt;/p&gt;

&lt;style&gt;
    .chl { color: yellow; } /* code highlight */
    .cer { color: red; } /* code error */
&lt;/style&gt;

&lt;pre&gt;
func fetch&lt;span class=&quot;chl&quot;&gt;Document&lt;/span&gt;(id: Int, completion: @escaping (Result&amp;lt;&lt;span class=&quot;chl&quot;&gt;Document&lt;/span&gt;, Error&amp;gt;) -&amp;gt; Void)
{
    // Construct the URLRequest
    let url = baseURL
        .appendingPathComponent(&lt;span class=&quot;chl&quot;&gt;&quot;document&quot;&lt;/span&gt;)
        .appendingPathComponent(&quot;\(id)&quot;)
    let urlRequest = URLRequest(url: url)

    // Send it to the URLSession
    let task = session.dataTask(with: urlRequest) { (data, _, error) in
        if let error = error { 
            completion(.failure(error)) 
        } else if let data = data {
            let result = Result { try JSONDecoder().decode(&lt;span class=&quot;chl&quot;&gt;Document&lt;/span&gt;.self, from: data) }
            completion(result)
        }
    }
    task.resume()
}
&lt;/pre&gt;

&lt;p&gt;Unsurprisingly, &lt;code class=&quot;highlighter-rouge&quot;&gt;fetchDocument&lt;/code&gt; is almost identical except for four changes: the function name, the type to pass to the closure, the URL path, and the type to decode. It‚Äôs so similar because I copied and pasted it. And when you find yourself copying and pasting, that‚Äôs where I know there‚Äôs probably some reusable code. So I extract that into a generic function:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Decodable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
                             &lt;span class=&quot;nv&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;@escaping&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;where-should-type-parameters-go&quot;&gt;Where should type parameters go?&lt;/h2&gt;

&lt;p&gt;Before going on, it‚Äôs worth exploring the signature. Notice that I pass the type of Model as a parameter. It doesn‚Äôt even need a name, because the value won‚Äôt be used. It‚Äôs just there to nail down the type parameter in the function‚Äôs parameters rather than in completion handler‚Äôs parameters. I‚Äôm mostly doing this to show a technique, and because &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch(2) { ... }&lt;/code&gt; is a bit ambiguous to the reader (since all ID types are Int currently). Sometimes this makes sense, sometimes it doesn‚Äôt.&lt;/p&gt;

&lt;p&gt;A good example where I think it makes a lot of sense is JSONDecoder‚Äôs &lt;code class=&quot;highlighter-rouge&quot;&gt;decode&lt;/code&gt; method. It‚Äôs called this way:&lt;/p&gt;

&lt;pre&gt;
let value = try JSONDecoder().decode(&lt;span class=&quot;chl&quot;&gt;Int.self&lt;/span&gt;, from: data)
&lt;/pre&gt;

&lt;p&gt;It could have been designed this way instead:&lt;/p&gt;

&lt;pre&gt;
let value&lt;span class=&quot;chl&quot;&gt;: Int&lt;/span&gt; = try JSONDecoder().decode(data)
&lt;/pre&gt;

&lt;p&gt;It would have even been a little shorter that way. But it forces the caller to add a type annotation on the variable, which is a little ugly, and unusual in Swift. If the only place the type parameter shows up is in the return value, I usually recommend passing it as a parameter. But in any case, try writing some code with it, and focus on making things clear at the call-site. &lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h2 id=&quot;making-fetch-generic&quot;&gt;Making &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; generic&lt;/h2&gt;

&lt;p&gt;Implementing &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; is pretty straightforward, except for one small &lt;span class=&quot;cer&quot;&gt;problem&lt;/span&gt;:&lt;/p&gt;

&lt;pre&gt;
func &lt;span class=&quot;chl&quot;&gt;fetch&amp;lt;Model&amp;gt;(_ model: Model.Type,&lt;/span&gt; id: Int,
                  completion: @escaping (Result&amp;lt;&lt;span class=&quot;chl&quot;&gt;Model&lt;/span&gt;, Error&amp;gt;) -&amp;gt; Void)
    &lt;span class=&quot;chl&quot;&gt;where Model: Fetchable&lt;/span&gt;
{
    // Construct the URLRequest
    let url =  baseURL
        .appendingPathComponent(&lt;span class=&quot;cer&quot;&gt;&quot;??? user | document ???&quot;&lt;/span&gt;)
        .appendingPathComponent(&quot;\(id)&quot;)
    let urlRequest = URLRequest(url: url)

    // Send it to the URLSession
    let task = session.dataTask(with: urlRequest) { (data, _, error) in
        if let error = error { 
           completion(.failure(error)) 
        } else if let data = data {
            let result = Result { try JSONDecoder().decode(&lt;span class=&quot;chl&quot;&gt;Model&lt;/span&gt;.self, from: data) }
            completion(result)
        }
    }
    task.resume()
}
&lt;/pre&gt;

&lt;p&gt;There‚Äôs this string that‚Äôs either ‚Äúuser‚Äù or ‚Äúdocument‚Äù. That‚Äôs something that this algorithm requires, but isn‚Äôt part of Decodable. So Decodable isn‚Äôt powerful enough to implement this. I need a new protocol.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Something that can be fetched from the API&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Fetchable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Decodable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;apiBase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I need a protocol that requires that the type be Decodable, and also requires that it provide this extra string, &lt;code class=&quot;highlighter-rouge&quot;&gt;apiBase&lt;/code&gt;. (See &lt;a href=&quot;/nonconformist&quot;&gt;Protocols are nonconformists&lt;/a&gt; for more on the difference between ‚Äú&lt;em&gt;requires&lt;/em&gt; Decodable‚Äù and ‚Äú&lt;em&gt;is&lt;/em&gt; Decodable.‚Äù) With that, I can finish writing &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;
// Fetch any Fetchable type given an ID, and return it asynchronously
func fetch&amp;lt;Model&amp;gt;(_ model: Model.Type, id: Int,
                  completion: @escaping (Result&amp;lt;Model, Error&amp;gt;) -&amp;gt; Void)
    where Model: Fetchable
{
    let url = baseURL
        .appendingPathComponent(&lt;span class=&quot;chl&quot;&gt;Model.apiBase&lt;/span&gt;)
        .appendingPathComponent(&quot;\(id)&quot;)
    let urlRequest = URLRequest(url: url)

    let task = session.dataTask(with: urlRequest) { (data, _, error) in
        if let error = error { completion(.failure(error)) }
        else if let data = data {
            let result = Result { try JSONDecoder().decode(Model.self, from: data) }
            completion(result)
        }
    }
    task.resume()
}
&lt;/pre&gt;

&lt;h2 id=&quot;retroactive-modeling&quot;&gt;Retroactive modeling&lt;/h2&gt;

&lt;p&gt;Now to use it, I need to make User and Document conform to Fetchable.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Fetchable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;apiBase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;user&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Fetchable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;apiBase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;document&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;These tiny extensions represent one of the most powerful, and easiest to overlook, aspects of protocol-oriented programming: retroactive modeling. It is quite non-obvious that I can take a type like User that wasn‚Äôt designed to be Fetchable, and make it Fetchable in an extension. And that extension doesn‚Äôt even have to be in the same module. That‚Äôs not something you can typically do with class inheritance. You need to choose a superclass when you define a type.&lt;/p&gt;

&lt;p&gt;I can take any type I want and conform it to my own protocols to use it in new and more powerful ways that the original type creator may never have thought of. There‚Äôs no need to tie User to this one use case and this one API. That‚Äôs why this protocol is called Fetchable rather than something like Model. It &lt;em&gt;isn‚Äôt&lt;/em&gt; a ‚Äúmodel.‚Äù It‚Äôs ‚Äúsomething that can be fetched‚Äù and it only provides the methods and properties that allow that. I‚Äôm not suggesting that you should create a protocol for every use case, just the opposite. Really good protocols are usable by many algorithms. But you want most uses of the protocol to need most of the requirements. If the protocol is just a copy of the type‚Äôs entire API, it‚Äôs not doing its job. I‚Äôll talk about that more in later articles.&lt;/p&gt;

&lt;h2 id=&quot;first-checkpoint&quot;&gt;First checkpoint&lt;/h2&gt;

&lt;p&gt;I know this has been basic so far. I know many of you ‚Äúknow all this.‚Äù This article is a warm-up, and the point of the exercise is not &lt;em&gt;what&lt;/em&gt; was built, but &lt;em&gt;how&lt;/em&gt; it was built. I started with simple, concrete code, and extracted first a generic function, and then a simple (no associated type) protocol. This is exactly the opposite of starting with a Request PAT and then trying to figure out the callers. This was just the first step. This system is nowhere near as flexible and powerful as it could be, but already it‚Äôs meeting the goal I set at the beginning: ‚Äúfetch a several model types from an API and decode them.‚Äù Keep the current goal in mind and don‚Äôt let the protocols get out in front of you.&lt;/p&gt;

&lt;p&gt;Next time, I‚Äôll push this example further, and start seeing what protocol oriented programming can really accomplish. Eventually I‚Äôll even need a PAT!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/protocols/StartWithAProtocol.zip&quot;&gt;Swift Playground&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;(I don‚Äôt have comments on this site, but if you‚Äôre interested in any conversations about it, follow the thread on &lt;a href=&quot;https://twitter.com/cocoaphony/status/1121549665789411333&quot;&gt;Twitter&lt;/a&gt;.)&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;A previous version of this post advocated for this approach much more strongly, but &lt;a href=&quot;https://twitter.com/peres/status/1121824695211429888&quot;&gt;some questions on Twitter&lt;/a&gt; made me rethink this.¬†&lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Rob Napier</name></author><summary type="html">In the beginning, Crusty In 2015, at WWDC, Dave Abrahams gave what I believe is still the greatest Swift talk ever given, and certainly the most influential. ‚ÄùProtocol-Oriented Programming in Swift,‚Äù or as it is more affectionately known, ‚ÄúThe Crusty Talk.‚Äù This is the talk that introduced the phrase ‚Äúprotocol oriented programming.‚Äù The first time I watched it, I took away just one key phrase: Start with a protocol. And so, dutifully, I started with a protocol. I made a UserProtocol and a DocumentProtocol and a ShapeProtocol and on and on, and then started implementing all those protocols with generic subclasses and eventually I found myself in a corner. Protocol 'P' can only be used as a generic constraint because it has Self or associated type requirements And then I started throwing things.</summary></entry><entry><title type="html">A Conditional Breakpoint</title><link href="https://robnapier.net/conditional-breakpoint" rel="alternate" type="text/html" title="A Conditional Breakpoint" /><published>2017-04-23T11:59:20-04:00</published><updated>2017-04-23T11:59:20-04:00</updated><id>https://robnapier.net/conditional-breakpoint</id><content type="html" xml:base="https://robnapier.net/conditional-breakpoint">&lt;p&gt;&lt;a href=&quot;https://twitter.com/jamesdempsey/status/855979622655291392&quot;&gt;I‚Äôm now a Conditional Breakpoint.&lt;/a&gt; It‚Äôs been a dream of mine for long time, and it finally happened at &lt;a href=&quot;http://cocoaconf.com/chicago-2017/sessions/breakpoint-jam&quot;&gt;CocoaConf Chicago&lt;/a&gt;. There are folks who have played extensively with &lt;a href=&quot;http://jamesdempsey.net/2013/03/02/introducing-the-breakpoint-jam-at-cocoaconf-chicago/&quot;&gt;James Dempsey&lt;/a&gt;, and those are the Breakpoints. If you‚Äôve only played occasionally (even once), you‚Äôre a Conditional Breakpoint.
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;Originally, I wasn‚Äôt comfortable being a full ‚ÄúConditional.‚Äù I‚Äôm not much of a guitarist. I can play along reasonably if there‚Äôs someone to cover my mistakes, and a group probably sounds slightly better with me than without. But listening to me play alone is an act of love and friendship, not something you‚Äôd do on purpose. So I kind of wanted to be called a ‚ÄúProvisional Breakpoint‚Äù instead. But that was wrong. Someone who‚Äôs played at a Breakpoint Jam is a Conditional Breakpoint. That‚Äôs what it means. If you‚Äôve done it, you‚Äôve earned it.&lt;/p&gt;

&lt;p&gt;Everyone who played guitar that night was a Conditional, but &lt;a href=&quot;https://twitter.com/designatednerd&quot;&gt;Ellen Shapiro&lt;/a&gt; was clearly our leader. She plays with an energy and style that I want to emulate. She‚Äôs much better than I am, but what I‚Äôve played in years, she‚Äôs played in decades, so maybe that‚Äôs natural. &lt;a href=&quot;/copying&quot;&gt;Choosing the right people to copy is a worthwhile skill in itself.&lt;/a&gt; There‚Äôs nothing wrong with being a beginner. There‚Äôs nothing wrong with learning and flailing and trying again. There‚Äôs nothing wrong with letting someone mentor you. And there are a lot of ways to mentor. You might not even know when you‚Äôre doing it.&lt;/p&gt;

&lt;p&gt;When I first asked to play with the Breakpoints a few weeks ago, James said yes, and I immediately panicked a little on the inside, and I asked for the whole setlist so I could practice. And he said sure and sent them. But then he said, you know, it‚Äôs fine to just play some of the songs, or even drop out of parts if you‚Äôre not up for it. It‚Äôs better to have a few songs you‚Äôre good at than a bunch you stumble through. And I said yeah, yeah, yeah, I know that. I‚Äôm cool. And I did kind of know. But not really. I‚Äôd been planning to practice them all and just beat myself up a lot everywhere I stumbled. I needed someone who knows more than me to give me permission to be a beginner, but still let me play. Sometimes you‚Äôll never know the impact of a small kindness.&lt;/p&gt;

&lt;p&gt;After the show, &lt;a href=&quot;https://twitter.com/ejknapp&quot;&gt;Eric Knapp&lt;/a&gt; asked me a very useful question. ‚ÄúSo, that was your dream, and now you‚Äôve done it. What‚Äôs your next dream?‚Äù It‚Äôs easy to lose your direction when you get to a destination. If you want to keep growing, your goals have to grow with you. My next goal is to be good enough that I can play alone and you‚Äôd rather stay than leave, even if you‚Äôre not my friend. It‚Äôs what I call ‚Äúa mediocre guitarist.‚Äù Eric thought it was a good goal, but suggested a more concrete one: Play one song at an open mic night. And he passed on some wisdom he‚Äôd received and I needed. ‚ÄúDon‚Äôt wait until you‚Äôre ready. Go play before you‚Äôre ready. There are lessons you can only learn by doing.‚Äù Eric has forgotten more about playing than I know (and I don‚Äôt believe I‚Äôm exaggerating). It‚Äôs good advice.&lt;/p&gt;

&lt;p&gt;I talk a bit about learning guitar and make a bit of noise about being a beginner. Some of that is because I love to tell stories, and I hope my stories can help other people. But of course saying ‚ÄúI‚Äôm a beginner‚Äù lowers expectations and overdone is a cheap way of getting praise. It‚Äôs a dangerous thing to make too big a deal about. For all my ‚ÄúI‚Äôm a beginner and I‚Äôm scared,‚Äù &lt;a href=&quot;https://twitter.com/savinola&quot;&gt;Laura Savino&lt;/a&gt; has been playing guitar for less time than I have, and this &lt;em&gt;wasn‚Äôt&lt;/em&gt; her first Breakpoint Jam. So sometimes the brave ones don‚Äôt make as much noise. You have to look or you‚Äôll never notice.&lt;/p&gt;

&lt;p&gt;I may just have been lucky so far, but I‚Äôve found the guitar community to be incredibly welcoming. James isn‚Äôt alone in inviting beginners to play, but the Breakpoints has a special history of it. Except for Ellen, the rest of us (Laura, myself, and &lt;a href=&quot;https://twitter.com/kognate&quot;&gt;Josh Smith&lt;/a&gt;) all made our first public performances at Breakpoint Jams. Creating that kind of opportunity is a gift and how you create and sustain a community. If we all ‚Äúonly hire the best,‚Äù where do you think the next generation will grow? Thankfully, James is willing to play with folks who are just trying their best. Are we as willing to develop software the same way?&lt;/p&gt;

&lt;p&gt;There are senior developers and there are junior developers, and there are developers in between. Different people have different experience and skill. You might be a senior developer in one language or platform or style, and just learning another. But there‚Äôs no point talking about ‚Äúreal‚Äù developers. If you write software and it runs, you‚Äôre a real developer. That‚Äôs what it means. You develop software. If you‚Äôve done it, you‚Äôve earned it.&lt;/p&gt;

&lt;p&gt;And if you develop software in Cocoa, then you really want to listen to &lt;a href=&quot;https://itunes.apple.com/us/album/backtrace/id926558924&quot;&gt;Backtrace&lt;/a&gt;. Hope to see you at the &lt;a href=&quot;http://jamesdempsey.net/splash/jdbp2017&quot;&gt;next show&lt;/a&gt; to benefit &lt;a href=&quot;http://appcamp4girls.com&quot;&gt;App Camp For Girls&lt;/a&gt;!&lt;/p&gt;</content><author><name>Rob Napier</name></author><summary type="html">I‚Äôm now a Conditional Breakpoint. It‚Äôs been a dream of mine for long time, and it finally happened at CocoaConf Chicago. There are folks who have played extensively with James Dempsey, and those are the Breakpoints. If you‚Äôve only played occasionally (even once), you‚Äôre a Conditional Breakpoint.</summary></entry><entry><title type="html">Refactoring Slow and Steady</title><link href="https://robnapier.net/refactoring" rel="alternate" type="text/html" title="Refactoring Slow and Steady" /><published>2017-02-13T12:21:55-05:00</published><updated>2017-02-13T12:21:55-05:00</updated><id>https://robnapier.net/refactoring</id><content type="html" xml:base="https://robnapier.net/refactoring">&lt;p&gt;I‚Äôve been talking with folks on a Slack about refactoring today, and I thought I‚Äôd put some of my thoughts here. Maybe a little less polished than I‚Äôd like, but I wanted to get them out of my head and down on ‚Äúpaper.‚Äù&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;em&gt;The conversation started by referencing the classic Joel piece, &lt;a href=&quot;https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/&quot;&gt;Things You should Never Do, Part I&lt;/a&gt;. Leading to my thoughts:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Just finished some major refactoring work, moving ObjC to Swift and completely redesigning its state machine. I absolutely stand behind the pieces I rewrote (which were a constant source of subtle race conditions and bugs, with every fix causing two new problems). I absolutely stand behind the pieces that I have delayed rewriting (which are a spaghetti mess, and incredibly difficult to safely modify, but after some minor tweaks are stable enough to leave alone).&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;pullquote-right&quot; data-pullquote=&quot;I‚Äôm a big fan of &amp;#8220;radical refactoring.&amp;#8221;&quot;&gt;
I‚Äôm a big fan of ‚Äúradical refactoring.‚Äù I‚Äôve refactored several code bases until there was almost nothing left of the original code. But it was done steadily, only doing major rewrites to individual pieces after painstakingly detangling them from the rest of the code (usually over the course of several releases). And at the end, there was always some ‚Äúball of mud‚Äù part that was a bit crazy, but just worked and didn‚Äôt need to be touched that often, so we let it be.
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;I‚Äôve even refactored a C program into a Go program, by turning it into two independent processes that communicated over sockets, and moving bits from one side of the API to the other.&lt;/p&gt;

&lt;p&gt;(So even ‚Äúwe need to switch languages/platforms entirely‚Äù doesn‚Äôt stop you from evolving towards a goal.)&lt;/p&gt;

&lt;p&gt;But there‚Äôs an exception that Joel doesn‚Äôt mention (but I think Martin Fowler does): if you have incredibly &lt;em&gt;buggy&lt;/em&gt; code, that is, if you &lt;em&gt;don‚Äôt&lt;/em&gt; have working code, then that‚Äôs the time to consider a rewrite. Not ugly code. Not badly designed or horrible to work with code. But code that doesn‚Äôt actually work, and several attempts to make it work have failed. That‚Äôs when a rewrite (at least of those portions) is likely appropriate.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The discussion then turned to unit testing, and particluarly &lt;a href=&quot;http://hamletdarcy.blogspot.com/2009/06/forgotten-refactorings.html&quot;&gt;Forgotten Refactorings&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Having had some very successful radical refactors on code without solid unit test coverage, I think it‚Äôs worth discussing how that can be done.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;pullquote-right&quot; data-pullquote=&quot;redesigning for testablity will *itself* require massive refactoring without unit tests&quot;&gt;
First, unit test coverage is absolutely the best first step. That said, sometimes it is impossible in any meaningful way. When all the most likely and common bugs in your system are race conditions and corner cases involving things outside the program (non-trivial networking, bluetooth, version-specific OS interactions, complex animations, etc), I‚Äôve found unit tests rapidly become tests of mocks, and not tests of the system. We can debate whether or not it is possible or profitable to redesign your system so it is more testable. I‚Äôll even concede that it is and leave arguments about TDD for another day (I‚Äôm actually a fan of TDD). But redesigning for testablity will &lt;em&gt;itself&lt;/em&gt; require massive refactoring without unit tests (because you can‚Äôt unit test until you make it testable). Even if you have lots of tests, refactoring often means changing the tests dramatically (which means you‚Äôre not really testing the same thing). So at &lt;em&gt;some&lt;/em&gt; point, you‚Äôre going to find yourself needing to refactor without perfect (or even barely sufficient) unit tests. How do you do it?
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Slow down.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;pullquote-right&quot; data-pullquote=&quot;Slow. Down. Expect your refactor to take many releases.&quot;&gt;
I cannot stress this enough. Slow. Down. Expect your refactor to take many releases. Do a small piece of refactoring, and run it through a full QA cycle (whatever that means for you) and ship it. Do it again and again. My ‚Äúconvert a C project to Go‚Äù project included a release where we just shipped the Go code alongside the C code, without even calling the Go code, just to prove it would install and not break anything. Then we built one, tiny, new feature in the Go code. It was so minor and impacted so few users, we were ready to declare it unsupported if it didn‚Äôt work. We‚Äôd been working on the Go code for almost two years before we cut over to it ‚Äúfor real‚Äù (and the vast majority of the code was still in C at that point). But at each step along the way, the system was better, and saner, and more reliable. And at each step along the way, it shipped, and got real field exercise. And we built a lot of tests for it, and we still found bugs that we were unable to build automated tests for. ‚ÄúFails to determine domain on Mac previously joined to AD domain, but then removed, only on OS X prior to 10.8‚Äù or ‚ÄúSMB connection fails to Window 2000 server if username contains space‚Äù or ‚Äúfails to determine correct IP address on Mac with case-sensitive file system if on Cisco VPN.‚Äù That kind of stuff.
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Second point that goes along with this is to keep your refactor steps contained. I‚Äôve had so many experimental refactor branches that I threw away because they spiraled out of control and touched too many pieces of the system in non-trivial ways. Don‚Äôt be afraid to throw away several attempts at refactoring until you can get your change focused enough that the risk is contained. Sometimes that means creating ‚Äúfirebreaks,‚Äù an object that wraps the thing you‚Äôre refactoring and provides the old API for code you don‚Äôt want to touch yet. Creating a firebreak often starts as just a pass-through that does nothing but call methods on the original. Tedious, but often invaluable. They make it possible to move to your new API piece by piece rather than having to touch half the system in one go.&lt;/p&gt;

&lt;p&gt;I strongly recommend keeping your commits very focused. ‚ÄúRename FooAdapter to Foo‚Äù should be its own commit. Don‚Äôt mix it with changes to API. ‚ÄúRename X to Y‚Äù commits are really easy to code review, even if they touch hundreds of files. But if you also changed logic in there, then it‚Äôs a monster. Similarly, anything that is an easy win with little risk (like naming things sanely, or moving some duplicated code into a function), do those first and get them into the main code base. That way, when you discover that your ambitious new design is out of control and have to start over, you don‚Äôt lose your easy wins.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;pullquote-right&quot; data-pullquote=&quot;go slow and steady and keep shipping.&quot;&gt;
Testing is great. Testing is critical. Testing is necessary. But unit testing is not sufficient. And when there are hundreds of test cases that need to be rewritten, they can be a &lt;em&gt;hindrance&lt;/em&gt; to refactoring. The more important rule in my experience is go slow and steady and keep shipping.
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;And yes. Write your unit tests. We‚Äôre professionals here.&lt;/p&gt;</content><author><name>Rob Napier</name></author><summary type="html">I‚Äôve been talking with folks on a Slack about refactoring today, and I thought I‚Äôd put some of my thoughts here. Maybe a little less polished than I‚Äôd like, but I wanted to get them out of my head and down on ‚Äúpaper.‚Äù</summary></entry><entry><title type="html">Talking and Teaching</title><link href="https://robnapier.net/talking" rel="alternate" type="text/html" title="Talking and Teaching" /><published>2016-11-29T10:35:09-05:00</published><updated>2016-11-29T10:35:09-05:00</updated><id>https://robnapier.net/talking</id><content type="html" xml:base="https://robnapier.net/talking">&lt;p&gt;&lt;a href=&quot;https://twitter.com/pepibumur&quot;&gt;Pedro Pi√±era&lt;/a&gt; makes some important points in his article &lt;a href=&quot;http://ppinera.es/2016/11/16/in-a-world.html&quot;&gt;In a world‚Ä¶&lt;/a&gt;. There are a number of things in there, and you should go read it, but I want to focus on one part, which is the observation that the core ‚ÄúiOS speaker circle‚Äù is a fairly small group of people. Pedro notes:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;There‚Äôs a huge difference when you compare a talk from someone that has been working a lot on the topic and from someone that studied the topic for giving a talk. Why do people do it then? Talks with a lot of value usually come from unknown people. From these people that from the anonymity worked on a topic and they achieved something that they were willing to share. ‚Ä¶ People don‚Äôt care about the company that person had worked for, or the newsletter that the person had written, but instead, what that person wants to share.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;While I agree with Pedro‚Äôs concern, I disagree that this is the proper ideal.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;I‚Äôve learned more about programming from listening to &lt;a href=&quot;https://twitter.com/dimsumthinking&quot;&gt;Daniel Steinberg&lt;/a&gt; talk about baking cookies than I have from a dozen talks from intelligent, highly experienced people who don‚Äôt have his skill for teaching. There are a number of speakers whose sessions I will attend no matter their topic because it‚Äôll always be worth the time. I get inspired every time I listen to &lt;a href=&quot;https://twitter.com/jaimeejaimee&quot;&gt;Jaimee Newberry&lt;/a&gt;, even though almost everything about her life and style is different than mine. If I watch &lt;a href=&quot;https://twitter.com/chriseidhof&quot;&gt;Chris Eidhof&lt;/a&gt; live-code, I know I‚Äôm going to see some amazing idea that forces me to rethink something in my code.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;pullquote-right&quot; data-pullquote=&quot;I absolutely care who&amp;#8217;s giving the talk.&quot;&gt;
I absolutely care who‚Äôs giving the talk. And if we‚Äôre going to ask people to spend hours or days of their time and hundreds or thousands of dollars to attend conferences, I think we owe the best we can offer.
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;But while I disagree with some of Pedro‚Äôs analysis, he raises a very important point. A community with many teachers and broad sharing is better than one with few teachers and a hierarchical flow of knowledge. How do we improve?&lt;sup id=&quot;fnref:marginalized&quot;&gt;&lt;a href=&quot;#fn:marginalized&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;We should recognize that there‚Äôs nothing wrong with having a core group of known, skilled speakers who draw a crowd. We should celebrate that. We should grow that group, and we should use them to make things even better.&lt;/p&gt;

&lt;p&gt;At dotSwift, Daniel Steinberg reached out to all the speakers and offered assistance refining their talks. Conference organizers should encourage and facilitate that kind of mentorship, and use it to reduce the risks of inexperienced speakers. I hope conference organizers speak to each other and share names of promising speakers whom they didn‚Äôt have room for. CocoaHeads and other local groups should strive to video their local talks and &lt;a href=&quot;http://cocoaheads.tv&quot;&gt;make them available&lt;/a&gt;. Conference organizers should use those to find and contact promising speakers outside the usual suspects. Local lightning talks have a very low barrier to entry and make an excellent way to get into speaking. Not everyone has a local group, but it‚Äôs a start.&lt;/p&gt;

&lt;p&gt;For those without a local group to video them, I always recommend blogging. Learning to write well is a major part of learning to speak well, and the barrier to entry for blogs is lower. A blog doesn‚Äôt have to be constantly updated to be helpful. A single, well-written article can be a huge value. This is another important place for conference organizers to search for new speakers, and I think those who are already well known have a duty to amplify lesser-known blogs that are well written and insightful.&lt;/p&gt;

&lt;p&gt;To those who want to speak, I‚Äôd like to offer a little advice. I‚Äôm not a top-tier speaker. I don‚Äôt get invited to many different conferences (thanks to &lt;a href=&quot;http://cocoaconf.com&quot;&gt;CocoaConf&lt;/a&gt; for making room for me so often), and most of my CfP submissions are rejected, but I‚Äôve spoken at 11 conferences over the last 4 years and some of my talks have been very well received, so take my advice for what it‚Äôs worth, remembering that it comes from someone with a lot of privilege. Not all of it applies easily to marginalized groups, but hopefully it can be of some help.&lt;/p&gt;

&lt;p&gt;First, I want to quote Pedro again:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;New announcements from Apple are the perfect source of topics for talks, grabbing it quickly is crucial: Protocol Oriented, Swift Open Source, Extension, Swift in the server‚Ä¶ You can build your developer brand around the topic. After a few conferences talking about it, the community will tag you as the expert in the topic X. You might not have worked in a production environment with that new thing, you might not have faced the real use cases and issues, but documentation is perfect to prepare a talk based on it, isn‚Äôt it?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span class=&quot;pullquote-right&quot; data-pullquote=&quot;You don&amp;#8217;t have to chase the &amp;#8220;current cool thing.&amp;#8221;&quot;&gt;
Yes! I totally agree with most of this, except that this is &lt;em&gt;positive&lt;/em&gt;. I take exception to a few points, though. First, ‚Äúgrabbing it quickly‚Äù is not crucial. Few people talk about Bluetooth or CoreMotion despite them being around for years. If those interest you, there‚Äôs plenty of room for new talks. (I sure would love some more on Bluetooth!) Would you be a better speaker if you shipped many production products with them? Of course. But you can still help a lot of people understand what‚Äôs possible by spending a few months going a little further than most and coming back and teaching. Don‚Äôt think you have to know everything before you‚Äôre allowed to say something! Just be honest and don‚Äôt pretend to know more than you do. There are many topics to explore. &lt;a href=&quot;https://twitter.com/batalia&quot;&gt;Natalia Berdys&lt;/a&gt; gives a &lt;a href=&quot;https://realm.io/news/tryswift-natalia-berdy-random-talk-consistent-world-noise-swift-gamekit-ios/&quot;&gt;brilliant talk&lt;/a&gt; on random number generation. You can‚Äôt get much more niche than that. You don‚Äôt have to chase the ‚Äúcurrent cool thing.‚Äù
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;I don‚Äôt know how it is for most speakers, but for me, preparing a talk is very difficult. It took me nearly five months to develop my &lt;a href=&quot;https://realm.io/news/tryswift-rob-napier-swift-legacy-functional-programming/&quot;&gt;talk for try! Swift&lt;/a&gt;. I completely rewrote it four times and practiced it for weeks. I think many speakers are much faster at this than I am, so it may not be so hard for you. But if you find it challenging and find yourself throwing away draft after draft because you can‚Äôt figure out what you‚Äôre trying to say, just know you‚Äôre not alone. If it matters to you, keep at it, and don‚Äôt be afraid to throw away a draft that isn‚Äôt working.&lt;sup id=&quot;fnref:privilege&quot;&gt;&lt;a href=&quot;#fn:privilege&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;If you want to give a talk, and think I can help you make it better, please reach out. I‚Äôve critiqued talks before, and I‚Äôm happy to keep doing it. (I will start by asking you to evaluate the talk using &lt;a href=&quot;http://www.slideshare.net/garrets/goethes-three-questions&quot;&gt;Goethe‚Äôs Three Questions&lt;/a&gt;. You have been warned.)&lt;/p&gt;

&lt;p&gt;And if you read all this and say ‚Äúhey, I don‚Äôt even &lt;em&gt;want&lt;/em&gt; to give a talk,‚Äù that is absolutely fine. Most people don‚Äôt. As anyone who‚Äôs scheduled CocoaHeads talks before knows, public speaking isn‚Äôt for everyone and one reason there‚Äôs a small group who speaks so often is because they‚Äôre the ones willing to do it. It‚Äôs hard and it‚Äôs scary and it‚Äôs rewarding and it‚Äôs valuable. And sometimes it‚Äôs even fun. I hope we can include everyone who wants to be part of it. And I hope there‚Äôs always a venue for those who want to listen.&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:marginalized&quot;&gt;
      &lt;p&gt;I‚Äôm only talking here about whether and how to broaden the number of unique speakers, because I believe this is Pedro‚Äôs point. I think there‚Äôs a different, very important discussion about diversity of background and drawing from marginalized groups. What I‚Äôm going to discuss can help, but that problem requires and deserves more targeted effort than I‚Äôm discussing here.¬†&lt;a href=&quot;#fnref:marginalized&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:privilege&quot;&gt;
      &lt;p&gt;This advice assumes a lot of privilege. I know there are many people who don‚Äôt have the kind of time I do and don‚Äôt have the kind of family support I have. I don‚Äôt know the answer for that. If I didn‚Äôt have much of the privilege I have, I don‚Äôt know how I would speak at conferences. Take my advice for what it‚Äôs worth; it doesn‚Äôt apply to everyone.¬†&lt;a href=&quot;#fnref:privilege&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Rob Napier</name></author><summary type="html">Pedro Pi√±era makes some important points in his article In a world‚Ä¶. There are a number of things in there, and you should go read it, but I want to focus on one part, which is the observation that the core ‚ÄúiOS speaker circle‚Äù is a fairly small group of people. Pedro notes: There‚Äôs a huge difference when you compare a talk from someone that has been working a lot on the topic and from someone that studied the topic for giving a talk. Why do people do it then? Talks with a lot of value usually come from unknown people. From these people that from the anonymity worked on a topic and they achieved something that they were willing to share. ‚Ä¶ People don‚Äôt care about the company that person had worked for, or the newsletter that the person had written, but instead, what that person wants to share. While I agree with Pedro‚Äôs concern, I disagree that this is the proper ideal.</summary></entry></feed>