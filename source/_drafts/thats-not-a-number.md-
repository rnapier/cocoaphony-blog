---
layout: post
title: "Protocols III: That's not a number"
---

So far in this series, I've [created a simple APIClient]({% link _posts/2019-04-20-start-with-a-protocol.markdown %}) that can fetch any Fetchable type and decode it from a specific API, and then [extracted a Transport protocol]({% link _posts/2019-04-29-a-mockery-of-protocols.md %}) to abstract away the network layer. In this part, I'll reconsider the top of the stack, the models, and see if I can make those more flexible.
<!-- more -->

The current models are User and Document:

```swift
struct User: Codable, Hashable {
    let id: Int
    let name: String
}

struct Document: Codable, Hashable {
    let id: Int
    let title: String
}
```

But now the server API is changing. Document IDs will be Strings, not Ints. (True story.) But really, IDs never really *were* Ints. I mean, IDs aren't *numbers*. What would it mean to add two IDs together? Or divide them? How can I pretend that an ID is a kind of number if most number-like operations would be nonsense? The current design allows me to pass document IDs when I mean a user ID. It even lets me pass an Array's count when I mean a user ID. That can't be right. IDs are their own thing. They want a type.

As usual, I'll start very concretely with User and see if anything generic develops. The first step is to lift the ID into its own type.

<style>
    .chl { color: yellow; } /* code highlight */
</style>

<pre>
struct User: Codable, Hashable {
    <span class="chl">struct ID: Codable, Hashable { 
        let value: Int 
    }
    let id: ID</span>
    let name: String
}
</pre>

So now creating a User looks like this:

```swift
let user = User(id: User.ID(value: 1), name: "Alice")
```

That's ok, but I don't like the `value:` label. It violates one of the principles of the [API Design Guidelines](https://swift.org/documentation/api-design-guidelines/#argument-labels):

> In initializers that perform value preserving type conversions, omit the first argument label, e.g. `Int64(someUInt32)`.

To comply, I should I add an initializer.

<pre>
struct User: Codable, Hashable {
    struct ID: Codable, Hashable { 
        let value: Int 
        <span class="chl">init(_ value: Int) { self.value = value }</span>
    }
    let id: ID
    let name: String
}

let user = User(id: <span class="chl">User.ID(1)</span>, name: "Alice")
</pre>

Much better. Document will be almost exactly the same.

<pre>
struct Document: Codable, Hashable {
    struct ID: Codable, Hashable {
        let value: <span class="chl">String</span>
        init(_ value: <span class="chl">String</span>) { self.value = value }
    }
    let id: ID
    let title: String
}
</pre>

It's not a lot of code, but anytime I'm tempted to cut and paste, it's time to wonder if there's generic code hiding in there. After all, most of the model types in this system will probably have an ID.

## A Real Identifier

What I really want is for the model type to know its ID type, and the ID type to know its model type. If you remember the `APIClient.fetch` method, it takes a type and an identifier:

<pre>
func fetch&lt;Model: Fetchable&gt;(_ model: <span class="chl">Model.Type</span>, id: <span class="chl">Int</span>,
                             completion: @escaping (Result<Model, Error>) -&gt; Void)
</pre>

Now that Fetchable types have their own ID type, that Int is going to have to change. If I can bundle the type and the identifier together, then it'll be easier to use. The most concrete way to do that is with a generic struct.

```swift
// An identifier (of some Value type) that applies to a specific Target type
struct Identifier<Target, Value>: Codable, Hashable where Value: Codable & Hashable {
    let value: Value
    init(_ value: Value) { self.value = value }
}
```

Identifier has two type parameters. The Target is the model type that this identifier applies to. The Value is the kind of identifier it requires (Int, UInt64, String, etc). The Target isn't actually used anywhere, but it means that `Identifier<User, Int>` and `Identifier<Document, Int>` are completely different types and can't be mixed up.

So User becomes:

<pre>
struct User: Codable, Hashable {
    <span class="chl">let id: Identifier&lt;User, Int&gt;</span>
    let name: String
}
</pre>

That's ok, but it'd be nicer to typealias it so I can refer to User.ID as a type:

<pre>
struct User: Codable, Hashable {
    <span class="chl">typealias ID = Identifier&lt;User, Int&gt;
    let id: ID</span>
    let name: String
}
</pre>

## Protocols drive algorithms





```swift
// Something identified with an Identifier
protocol Identified {
    associatedtype IDType: Codable & Hashable
    typealias ID = Identifier<Self, IDType>
    var id: ID { get }
}

// User model object
struct User: Identified, Codable {
    typealias IDType = Int
    let id: ID
    let name: String
}
```

Fetchable needs to add the Identified requirement:

<pre>
// Something that can be fetched from the API
protocol Fetchable: <span class="chl">Identified,</span> Codable {
    static var apiBase: String { get }  // The part of the URL for this fetchable type
}
</pre>

And `APIClient.fetch` gets simpler. No need to pass the type as the first parameter. It's implied by the ID.

```swift
func fetch<Model: Fetchable>(id: Model.ID,
                             completion: @escaping (Result<Model, Error>) -> Void) { ... }
...

client.fetch(id: User.ID(1), completion: { print($0)} )
```

I say that like it's obvious, but I'm actually amazed that the compiler can figure this out. The only type passed here is User.ID, which only references User as its Target. `fetch` never mentions Target. I can see how this the Identified protocol proves that Target has to equal Model, but it's not obvious at all.

## A funny thing happened on the way to a blog post

I've been creating "id" types for a long time in several production code bases. I've never actually used this Identifier type. I almost always do it this way, with an IDType protocol and a per-type struct:

```swift
// Makes the definition of IDs really simple by hoisting all the requirements here
protocol IDType: Codable, Hashable {
    associatedtype Value: Codable, Hashable
    var value: Value { get }
    init(value: Value)
}

// Adds an extra "conversion" init.
extension IDType {
    init(_ value: Value) { self.init(value: value) }
}

// Each type has this `ID` struct that doesn't know anything about its containing type
struct User: Codable, Hashable {
    struct ID: IDType { let value: Int }
    let id: ID
    let name: String
}
```

This is the approach I originally wrote up for this blog post, and I used it to discuss PATs (protocols with associated types). But then I started writing up various other options to show why the PAT was the best, and I discovered that the two-parameter Identifier struct was more powerful (because of how it simplifies `fetch`). It then took me several hours of playing around with various other approaches over several days to work out the Identified protocol. It still amazes me that it works. It definitely was not obvious.

There are a lot of people who are a lot better than I am at this, and I'm sure they would have built this (or something better!) all at once on the first try. But I'm not bad at this stuff, and this is how it usually works for me. I want to stress that I've shipped the IDType protocol very successfully in several products, and have never run into a case where I actually wanted a more powerful type. It's just that by playing around (and thinking a lot about [Brandon Williams'](https://twitter.com/mbrandonw) [Protocol Witnesses](https://www.youtube.com/watch?v=3BVkbWXcFS4) talk) I discovered one existed.

Of course I've never actually shipped this Identified type. Maybe I'm wrong. Maybe it has quirks when you try to use it in "real" code. Maybe it turns out to awkward or limited for some reason. I won't know until I ship it in a real project.

And that's the point.

{% pullquote %}
Go watch Brandon's talk. The most important thing is the impact on the SnapshotTesting framework. The structs he describes don't exist for their own sake. They're not example code to demonstrate an architecture or an algebra. They came into existence through the process of refactoring a shipping framework to be more flexible. {" If the tools you're using are solving your problems, you're doing it right. "} When I found a possibly better way to implement IDs, it didn't make IDType "wrong." IDType has been very useful. But now I have a new tool that may solve future problems better. You can be doing it right and still improve.
{% endpullquote %}

## What's the next line of code?

OK, back to the problem at hand. This Identified protocol is pretty useful, but it includes an associated type. And since Fetchable now requires Identified, Fetchable *also* has an associated type. Adding an associated type in Swift today is a big decision. It should not be taken lightly. Some day that may be less true, but it will always be important. Whenever you're creating an associated type, you need to ask the question "would this ever go into an Array?" Because a PAT (protocol with associated type) can't be put in an Array.

    let identifiedObjects: [Identified] = [user, document]
    // error: protocol 'Identified' can only be used as a generic constraint because it has Self or associated type requirements

It also can't be the type of a variable, or property, or function parameter, or return value, or...really anything except a generic constraint or extension. The error does not lie. There's no tricky syntax to make this work (if there were, the error would probably say that instead).

Now faced with this error, you might search around a bit, and discover a seemingly magical tool called [a type-eraser](http://robnapier.net/erasure). But generally this isn't what type-erasers are for. (I wish I'd understood that better when I started writing about them.) If you find yourself reaching for type-erasers constantly, you probably want to watch Brandon's talk on Protocol Witnesses. It's the same "convert protocol requirements to function properties" technique, but Brandon "de-protocolizing" is a better way to think about it.

But before you even do that, I want you to ask a more important question: what would you do with `identifiedObjects` if you had it? What would be the next line of code:

```swift
for object in identifiedObjects {
    ??? the only property on object is .id, which is an unknown type ???
}
```

The only think you can do with `object` is get its ID. But each object can have a different ID type. So what would you do with it? You can't call `fetch`. That requires a closure that accepts the model type. But you don't know the model type. `object` is just "something with an ID." If you start `as?` casting the value to some short list of types you know, then you didn't want a struct or protocol anyway; you wanted an enum.

Instead of looking at Identified and trying to put it in an Array, you should start with the for loop, and figure out what it needs. For example, maybe you have a list of model objects you want to reload from the server. Once you reload them, though, you're going to have to do something with them. Maybe you have a bunch of views that need to be refreshed. Then build that. Create a RefreshRequest that captures the refresh operation, and make an array of them. No type-erasers needed.

```swift
// A protocol for things that can be refreshed with a model object (such as a UIView or UIViewController)
protocol ModelRefreshable: class {
    associatedtype Model: Fetchable
    var model: Model { get set }
}

// A request to refresh a ModelRefreshable
struct RefreshRequest {
    let perform: () -> Void

    init<ModelView>(model: ModelView.Model,
                    updating modelView: ModelView,
                    onError: @escaping (Error) -> Void,
                    using client: APIClient)
        where ModelView: ModelRefreshable
    {
        perform = {
            client.fetch(id: model.id) {
                switch $0 {
                case .success(let newModel): modelView.model = newModel
                case .failure(let error): onError(error)
                }
            }
        }
    }
}

for request in requests {
    request.perform()
}
```

This is another case of "common currency." If you want a delayed action, that's just a function. You don't need to keep track of all the parameters to the function if all you need is the function itself. This could just be a top-level function that returns a function, but I often find it nice to go ahead and wrap those up in a type to give it more context and to allow more extensions. It could also be an extension on APIClient that returns a RefreshRequest.

