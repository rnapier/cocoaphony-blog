---
layout: post
title: "Protocols IV: That's not a number"
---

So far in this series, I've [created a simple APIClient]({% link _posts/2019-04-20-start-with-a-protocol.markdown %}) that can fetch any Fetchable type and decode it from a specific API, and then [extracted a Transport protocol]({% link _posts/2019-04-29-a-mockery-of-protocols.md %}) to abstract away the network layer. In this part, I'll reconsider the top of the stack, the models, and see if I can make those more flexible.
<!-- more -->

The current models are User and Document:

```swift
struct User: Codable, Hashable {
    let id: Int
    let name: String
}

struct Document: Codable, Hashable {
    let id: Int
    let title: String
}
```

But now the server API is changing. Document IDs will be Strings, not Ints. (True story.) But really, IDs never really *were* Ints. I mean, IDs aren't *numbers*. What would it mean to add two IDs together? Or divide them? How can I pretend that an ID is a kind of number if most number-like operations would be nonsense? The current design allows me to pass document IDs when I mean user IDs. It even lets me pass random integers when I mean an ID. That can't be right. IDs are their own thing. They want a type.

As usual, I'll start very concretely with User and see if anything generic develops. The first step is to lift the ID into its own type.

<style>
    .chl { color: yellow; } /* code highlight */
</style>

<pre>
struct User: Codable, Hashable {
    <span class="chl">struct ID: Codable, Hashable { 
        let value: Int 
    }
    let id: ID</span>
    let name: String
}
</pre>

So now creating a User looks like this:

```swift
let user = User(id: User.ID(value: 1), name: "Alice")
```

That's ok, but I don't like the `value:` label. It violates one of the principles of the [API Design Guidelines](https://swift.org/documentation/api-design-guidelines/#argument-labels):

> In initializers that perform value preserving type conversions, omit the first argument label, e.g. `Int64(someUInt32)`.

To comply, I should I add another initializer.

<pre>
struct User: Codable, Hashable {
    struct ID: Codable, Hashable { 
        let value: Int 
        <span class="chl">init(_ value: Int) { self.value = value }</span>
    }
    let id: ID
    let name: String
}

let user = User(id: <span class="chl">User.ID(1)</span>, name: "Alice")
</pre>

Much better. Document will be almost exactly the same.

<pre>
struct Document: Codable, Hashable {
    struct ID: Codable, Hashable {
        let value: <span class="chl">String</span>
        init(_ value: <span class="chl">String</span>) { self.value = value }
    }
    let id: ID
    let title: String
}
</pre>

It's not a lot of code, but anytime I'm tempted to cut and paste, it's time to wonder if there's generic code hiding in there. After all, most of the model types in this system will probably have an ID.

## Maybe a protocol?

When I see code duplication, I often reach first for a protocol so I can extract a generic algorithm. That's something protocols are very good at. In the case of ID, there are two duplicated concepts: identifiers conform to Codable and Hashable, and identifiers have a "no label" initializer.

{% pullquote %}
{" It's important to focus on the duplication of concepts, not keystrokes. "} [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) doesn't mean "never type the same letters twice." The point is to extract things that will *vary together*. I don't want to capture "types that include the characters `: Codable, Hashable` and `init(_...`." I want to capture "things that behave as identifiers." So I'm going to capture that concept as Identifier:
{% endpullquote %}

```swift
protocol Identifier: Codable, Hashable {
    associatedtype Value: Codable, Hashable
    var value: Value { get }
    init(value: Value)
}

extension Identifier {
    init(_ value: Value) { self.init(value: value) }
}
```

With that, User.ID is simplified to:

<pre>
struct User: Codable, Hashable {
    <span class="chl">struct ID: Identifier { let value: Int }</span>
    let id: ID
    let name: String
}
</pre>

To use it, `APIClient.fetch` needs to accept an ID type rather than an Int:

<pre>
func fetch&lt;Model: Fetchable&gt;(_ model: Model.Type, <span class="chl">id: Model.ID</span>,
                             completion: @escaping (Result&lt;Model, Error&gt;) -&gt; Void)
</pre>

And of course Fetchable needs to add an ID type:

<pre>
protocol Fetchable: Decodable {
    <span class="chl">associatedtype ID: Identifier</span>
    static var apiBase: String { get }  // The part of the URL for this fetchable type
}
</pre>

Wait a minute... There's nothing "of course" about that last change. Fetchable used to be a simple protocol. Now it's a PAT (protocol with associated type). That's a big change in Swift. Whenever you find yourself typing `associatedtype`, you need to stop for a moment and think "would I ever want to put this in an Array?" Once you put an associated type on a protocol in Swift today, it's no longer a "thing." It's only a constraint that can be used for extensions and generic functions. It can't put put in a variable, or be passed to a function, or in any other way be treated as a value.

Yes, someday [generalized existentials]({% link _posts/2019-05-12-existential-spelling.md %}) will improve this in some cases. But before you pine for those days, or reach for a [type-eraser]({% link _posts/2015-08-04-erasure.markdown %}), it's time to think harder about the protocol.

## What's the next line of code?

I want to roll back to the Identifier protocol and ask that question, "would I ever want to put an Identifier in an Array?" I've used this protocol in production projects for a long time now, and the answer so far has been no. It just hasn't come up. But I can imagine cases where it would be useful. Consider the case where model objects are quite large. Purging little-used data from memory would be very useful, but keeping track of the identifiers would also be important to later refresh the information from the network, much as Core Data does with local storage.

If I tried to create that today, it spits out that infamous error:

```swift
let ids: [Identifier] = [User.ID(1), Document.ID("password")]
// Protocol 'Identifier' can only be used as a generic constraint because it has Self or associated type requirements
```

And this it the point where you might cry out "generalized existential!" But that wouldn't actually help here. Any generalized existential can be written as an explicit existential. (I'll discuss this in more detail in a later article.) So let's pretend there's an `AnyIdentifier` already written. Eventually I'm going to wind up with some loop over `[AnyIdentifier]`:

```swift
for id in ids {
    // ??? the only property is .value, which is an unknown type ???
}
```

I call this the "what now?" problem. The only thing I can do with `id` is get its value. But each ID can have a different value type. So what can I do with it? Even with the fabled generalized existential, the type of `.value` would be Any. I can't call `fetch` with that. I don't even know the Model type.

{% pullquote %}
"I don't even know the Model type." As I said, I've used this protocol in several projects and I've never needed to a list of Identifiers, but as soon as I started writing this article, I realized how weird it is that an Identifier doesn't know what type it identifies. Originally I was going to just rewrite this article to ignore it, but these kinds of...mistakes?...are important to explore. I hesitate to call it a mistake, because it's never mattered in any shipping software I've worked on. {" If a type is solving your problems, it's not wrong. "} But maybe it could be better.
{% endpullquote %}

## Sometimes you use the tools you got

Before I make it better, I want to solve the problem I raised *without* making it better. I know that sounds a littles strange, but sometimes you inherit types that you can't easily change, and it's good to have lots of tools in your belt that don't require rewriting half your project every time something is less than ideal. So how can I solve the "list of identifiers I may need to refresh" problem?

The key is to focus on the real problem, and that's why it's important to state an actual use case, not just "I want a list of identifiers." That's not what I want at all. I want a list of refresh requests. A refresh request is a future action, and a future action is closure. I typically like to wrap that closure into a type.

```swift
struct Action {
    let perform: () -> Void
}

for action in actions {
    action.perform()
}
```

This is the most basic and powerful "type-eraser" available. I can construct any future action out of it, and perform them at any future time. But this may be a little too basic. Creating an update request would look like this:

```swift
let userRequest = Action {
    client.fetch(User.self, id: userID) {
        switch $0 {
        case .success(let model): users[userID] = model
        case .failure(let error): print("Failure fetching \(userID): \(error)")
        }
    }
}
```

There's going to be a lot of duplicated code for every kind of request. So maybe I want something a little more custom:

```swift
struct RefreshRequest {
    let perform: () -> Void

    init<Model: Fetchable>(id: Model.ID,
                           with client: APIClient = APIClient.shared,
                           completion: @escaping (Result<Model, Error>) -> Void)
    {
        perform = {
            client.fetch(Model.self, id: id, completion: completion)
        }
    }
}
```

Same idea, but the initializer is a little nicer. Still, most of the time the completion handler is going to be very similar, so maybe it's worth making it even a little more custom.

<pre>
struct RefreshRequest {
    let perform: () -&gt; Void

    <span class="chl">static func logError&lt;ID: Identifier&gt;(id: ID, error: Error) {
        print(&quot;Failure fetching \(id): \(error)&quot;)
    }</span>

    init&lt;Model: Fetchable&gt;(id: Model.ID,
                           with client: APIClient = APIClient.shared,
                           completion: @escaping (Result&lt;Model, Error&gt;) -&gt; Void)
    {
        perform = {
            client.fetch(Model.self, id: id, completion: completion)
        }
    }

    <span class="chl">init&lt;Model: Fetchable&gt;(id: Model.ID,
                           with client: APIClient = APIClient.shared,
                           updateHandler: @escaping (Model) -&gt; Void,
                           errorHandler: @escaping (Model.ID, Error) -&gt; Void = logError)
    {
        self.init(id: id, with: client) { (result: Result&lt;Model, Error&gt;) in
            switch result {
            case .success(let model): updateHandler(model)
            case .failure(let error): errorHandler(id, error)
            }
        }
    }</span>
}

let requests = [
    RefreshRequest(id: userID, updateHandler: { users[$0.id] = $0 }),
    RefreshRequest(id: documentID, updateHandler: { documents[$0.id] = $0 }),
]
</pre>

{% pullquote %}
The point of all of this isn't this specific data structure. It's that `() -> Void` is an incredibly powerful and flexible type, and you can construct it from all kinds of other functions. It's another case of "common currency." If you want a delayed action, that's just a function. {" You don't need to keep track of all the parameters to a function if all you need is the function itself. "} This could just be a top-level function that returns a function, but I often find it nice to wrap them up in a type to give it more context and allow extensions.
{% endpullquote %}

## A Real Identifier

But what I really want is for the model type to know its Identifier type, and the Identifier type to know its model type. That way an Identifier can be used all by itself. There are two approaches: a more powerful protocol








 If you remember the `APIClient.fetch` method, it takes a type and an identifier:

<pre>
func fetch&lt;Model: Fetchable&gt;(_ model: <span class="chl">Model.Type</span>, id: <span class="chl">Int</span>,
                             completion: @escaping (Result&lt;Model, Error&gt;) -&gt; Void)
</pre>

Now that Fetchable types have their own ID type, that Int is going to have to change. If I can bundle the type and the identifier together, then it'll be easier to use. The most concrete way to do that is with a generic struct.

```swift
// An identifier (of some Value type) that applies to a specific Target type
struct Identifier<Target, Value>: Codable, Hashable where Value: Codable & Hashable {
    let value: Value
    init(_ value: Value) { self.value = value }
}
```

Identifier has two type parameters. The Target is the model type that this identifier applies to. The Value is the kind of identifier it requires (Int, UInt64, String, etc). The Target isn't actually used anywhere, but it means that `Identifier<User, Int>` and `Identifier<Document, Int>` are completely different types and can't be mixed up.

So User becomes:

<pre>
struct User: Codable, Hashable {
    <span class="chl">let id: Identifier&lt;User, Int&gt;</span>
    let name: String
}
</pre>

That's ok, but it'd be nicer to typealias it so I can refer to User.ID as a type:

<pre>
struct User: Codable, Hashable {
    <span class="chl">typealias ID = Identifier&lt;User, Int&gt;
    let id: ID</span>
    let name: String
}
</pre>

## Protocols drive algorithms


<<<<<< HERE


```swift
// Something identified with an Identifier
protocol Identified {
    associatedtype IDType: Codable & Hashable
    typealias ID = Identifier<Self, IDType>
    var id: ID { get }
}

// User model object
struct User: Identified, Codable {
    typealias IDType = Int
    let id: ID
    let name: String
}
```

Fetchable needs to add the Identified requirement:

<pre>
// Something that can be fetched from the API
protocol Fetchable: <span class="chl">Identified,</span> Codable {
    static var apiBase: String { get }  // The part of the URL for this fetchable type
}
</pre>

And `APIClient.fetch` gets simpler. No need to pass the type as the first parameter. It's implied by the ID.

```swift
func fetch<Model: Fetchable>(id: Model.ID,
                             completion: @escaping (Result<Model, Error>) -> Void) { ... }
...

client.fetch(id: User.ID(1), completion: { print($0)} )
```

I say that like it's obvious, but I'm actually amazed that the compiler can figure this out. The only type passed here is User.ID, which only references User as its Target. `fetch` never mentions Target. I can see how this the Identified protocol proves that Target has to equal Model, but it's not obvious at all.

## A funny thing happened on the way to a blog post

I've been creating "id" types for a long time in several production code bases. I've never actually used this Identifier type. I almost always do it this way, with an IDType protocol and a per-type struct:

```swift
// Makes the definition of IDs really simple by hoisting all the requirements here
protocol IDType: Codable, Hashable {
    associatedtype Value: Codable, Hashable
    var value: Value { get }
    init(value: Value)
}

// Adds an extra "conversion" init.
extension IDType {
    init(_ value: Value) { self.init(value: value) }
}

// Each type has this `ID` struct that doesn't know anything about its containing type
struct User: Codable, Hashable {
    struct ID: IDType { let value: Int }
    let id: ID
    let name: String
}
```

This is the approach I originally wrote up for this blog post, and I used it to discuss PATs (protocols with associated types). But then I started writing up various other options to show why the PAT was the best, and I discovered that the two-parameter Identifier struct was more powerful (because of how it simplifies `fetch`). It then took me several hours of playing around with various other approaches over several days to work out the Identified protocol. It still amazes me that it works. It definitely was not obvious.

There are a lot of people who are a lot better than I am at this, and I'm sure they would have built this (or something better!) all at once on the first try. But I'm not bad at this stuff, and this is how it usually works for me. I want to stress that I've shipped the IDType protocol very successfully in several products, and have never run into a case where I actually wanted a more powerful type. It's just that by playing around (and thinking a lot about [Brandon Williams'](https://twitter.com/mbrandonw) [Protocol Witnesses](https://www.youtube.com/watch?v=3BVkbWXcFS4) talk) I discovered one existed.

Of course I've never actually shipped this Identified type. Maybe I'm wrong. Maybe it has quirks when you try to use it in "real" code. Maybe it turns out to awkward or limited for some reason. I won't know until I ship it in a real project.

And that's the point.

{% pullquote %}
Go watch Brandon's talk. The most important thing is the impact on the SnapshotTesting framework. The structs he describes don't exist for their own sake. They're not example code to demonstrate an architecture or an algebra. They came into existence through the process of refactoring a shipping framework to be more flexible. {" If the tools you're using are solving your problems, you're doing it right. "} When I found a possibly better way to implement IDs, it didn't make IDType "wrong." IDType has been very useful. But now I have a new tool that may solve future problems better. You can be doing it right and still improve.
{% endpullquote %}

## What's the next line of code?

OK, back to the problem at hand. This Identified protocol is pretty useful, but it includes an associated type. And since Fetchable now requires Identified, Fetchable *also* has an associated type. Adding an associated type in Swift today is a big decision. It should not be taken lightly. Some day that may be less true, but it will always be important. Whenever you're creating an associated type, you need to ask the question "would this ever go into an Array?" Because a PAT (protocol with associated type) can't be put in an Array.

    let identifiedObjects: [Identified] = [user, document]
    // error: protocol 'Identified' can only be used as a generic constraint because it has Self or associated type requirements

It also can't be the type of a variable, or property, or function parameter, or return value, or...really anything except a generic constraint or extension. The error does not lie. There's no tricky syntax to make this work (if there were, the error would probably say that instead).

Now faced with this error, you might search around a bit, and discover a seemingly magical tool called [a type-eraser](http://robnapier.net/erasure). But generally this isn't what type-erasers are for. (I wish I'd understood that better when I started writing about them.) If you find yourself reaching for type-erasers constantly, you probably want to watch Brandon's talk on Protocol Witnesses. It's the same "convert protocol requirements to function properties" technique, but Brandon "de-protocolizing" is a better way to think about it.

But before you even do that, I want you to ask a more important question: what would you do with `identifiedObjects` if you had it? What would be the next line of code:

```swift
for object in identifiedObjects {
    ??? the only property on object is .id, which is an unknown type ???
}
```

The only think you can do with `object` is get its ID. But each object can have a different ID type. So what would you do with it? You can't call `fetch`. That requires a closure that accepts the model type. But you don't know the model type. `object` is just "something with an ID." If you start `as?` casting the value to some short list of types you know, then you didn't want a struct or protocol anyway; you wanted an enum.

Instead of looking at Identified and trying to put it in an Array, you should start with the for loop, and figure out what it needs. For example, maybe you have a list of model objects you want to reload from the server. Once you reload them, though, you're going to have to do something with them. Maybe you have a bunch of views that need to be refreshed. Then build that. Create a RefreshRequest that captures the refresh operation, and make an array of them. No type-erasers needed.

```swift
// A protocol for things that can be refreshed with a model object (such as a UIView or UIViewController)
protocol ModelRefreshable: class {
    associatedtype Model: Fetchable
    var model: Model { get set }
}

// A request to refresh a ModelRefreshable
struct RefreshRequest {
    let perform: () -> Void

    init<ModelView>(model: ModelView.Model,
                    updating modelView: ModelView,
                    onError: @escaping (Error) -> Void,
                    using client: APIClient)
        where ModelView: ModelRefreshable
    {
        perform = {
            client.fetch(id: model.id) {
                switch $0 {
                case .success(let newModel): modelView.model = newModel
                case .failure(let error): onError(error)
                }
            }
        }
    }
}

for request in requests {
    request.perform()
}
```

This is another case of "common currency." If you want a delayed action, that's just a function. You don't need to keep track of all the parameters to the function if all you need is the function itself. This could just be a top-level function that returns a function, but I often find it nice to go ahead and wrap those up in a type to give it more context and to allow more extensions. It could also be an extension on APIClient that returns a RefreshRequest.
